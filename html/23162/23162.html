<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ゼロから学ぶScala</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/css/mainday.css" title="default">
<link rel="alternate stylesheet" href="/css/mainnight.css" title="alternate">
<script type="text/javascript" src="/js/styleswitcher.js"></script>
<script type="text/javascript" src="/js/global.js"></script>
</head>
<body>
<div class="novelpage">
<div class="novelbody">
<div id="tateyoko">
<div id="_top"></div>
<a href="/">🏠</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('default'); return false;">日</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('alternate'); return false;">月</a>&emsp;
<a href="#_top" onclick="myFunction()" style="cursor: pointer;">縦書き／横書き</a>
<div id="calibre_link-50">
<div>
<div>
<table class="noveltitle">
<tr>
<td colspan="2"><i><span><i>ゼロから学ぶScala</i></span></i></td>
</tr>
<tr>
                    
                    
      </tr>
<tr>
<td colspan="2">飯田 健二</td>
</tr>
<tr>
<td colspan="2">Uejima Kikaku Publishing (2016)</td>
</tr>
<tr>
<td colspan="2"></td>
</tr>
</table>
<div></div>
</div>
<div></div>
</div>
</div>



<div id="calibre_link-210">
<div>
<p>&nbsp;</p>
<p><span>ゼロから学ぶScala</span></p>
<p>&nbsp;</p>
<p><span>[著者]飯田　健二</span></p>
<p><span>株式会社　うえじま企画</span></p>
<p>&nbsp;</p>
<p>
<div id="calibre_link-225"></div>
</p>
</div>
</div>
<div id="calibre_link-40">
<div>
<p>
<br id="calibre_link-226" /><span>本書に掲載されている会社名、商品名、製品名などは、一般に各社の商標または登録商標です。なお、本書中では、TM、®マークは明記しておりません。</span></p>
<p>&nbsp;</p>
<p><span>本書の内容に関して運用した結果の影響については、責任を負いかねます。予めご了承ください。</span></p>
<p>&nbsp;</p>
<p><span>© 2016 Kenji Iida</span></p>
<p><span>本書の内容は、著作権法による保護を受けております。著作権者および出版権者の文書による許諾を得ずに、本書の内容の一部あるいは全部を無断で複写、複製することは禁じられております。</span></p>
<p>
<div id="calibre_link-227"></div>
</p>
</div>
</div>
<div id="calibre_link-86">
<div>
<p>
<br id="calibre_link-228" /></p>
<p><span>目次</span></p>
<p><a id="calibre_link-229"></a><a href="#calibre_link-87"><span><b><u>はじめに</u></b></span></a></p>
<p><a href="#calibre_link-88"><span><b><u>第１章　まずは入門</u></b></span></a></p>
<p><a href="#calibre_link-89"><span><u>1-0</u></span><span><u>1　</u></span><span><u>Scal</u></span><span><u>a</u></span><span><u>とは？</u></span></a></p>
<p><a href="#calibre_link-90"><span><u>1-0</u></span><span><u>2</u></span><span><u>　予約語</u></span></a></p>
<p><a href="#calibre_link-91"><span><u>1-0</u></span><span><u>3</u></span><span><u>　識別子</u></span></a></p>
<p><a href="#calibre_link-92"><span><u>1-0</u></span><span><u>4</u></span><span><u>　シングルトンオブジェクト</u></span><span><u>と</u></span><span><u>mai</u></span><span><u>n</u></span><span><u>メソッド</u></span></a></p>
<p><a href="#calibre_link-93"><span><u>1-0</u></span><span><u>5</u></span><span><u>　コンパイルと実行</u></span></a></p>
<p><a href="#calibre_link-94"><span><u>1-0</u></span><span><u>6</u></span><span><u>　コメント</u></span></a></p>
<p><a href="#calibre_link-95"><span><b><u>第２章　次に基本</u></b></span></a></p>
<p><a href="#calibre_link-96"><span><u>2-0</u></span><span><u>1</u></span><span><u>　型とリテラル</u></span></a></p>
<p><a href="#calibre_link-97"><span><u>2-01-0</u></span><span><u>1</u></span><span><u>　整数型と整数リテラル</u></span></a></p>
<p><a href="#calibre_link-98"><span><u>2-01-0</u></span><span><u>2</u></span><span><u>　浮動小数点数型と浮動小数点数リテラル</u></span></a></p>
<p><a href="#calibre_link-99"><span><u>2-01-0</u></span><span><u>3　</u></span><span><u>Boolea</u></span><span><u>n</u></span><span><u>型</u></span><span><u>と</u></span><span><u>Boolea</u></span><span><u>n</u></span><span><u>リテラル</u></span></a></p>
<p><a href="#calibre_link-100"><span><u>2-01-0</u></span><span><u>4</u></span><span><u>　文字型と文字リテラル</u></span></a></p>
<p><a href="#calibre_link-101"><span><u>2-01-0</u></span><span><u>5</u></span><span><u>　文字列型と文字列リテラル（生文字列リテラル）</u></span></a></p>
<p><a href="#calibre_link-102"><span><u>2-0</u></span><span><u>2</u></span><span><u>　変数</u></span></a></p>
<p><a href="#calibre_link-103"><span><u>2-0</u></span><span><u>3</u></span><span><u>　型推論</u></span></a></p>
<p><a href="#calibre_link-104"><span><u>2-0</u></span><span><u>4</u></span><span><u>　演算子</u></span></a></p>
<p><a href="#calibre_link-105"><span><u>2-04-0</u></span><span><u>1</u></span><span><u>　算術演算子と文字列連結演算子</u></span></a></p>
<p><a href="#calibre_link-106"><span><u>2-04-0</u></span><span><u>2</u></span><span><u>　関係演算子</u></span></a></p>
<p><a href="#calibre_link-107"><span><u>2-04-0</u></span><span><u>3</u></span><span><u>　論理演算子</u></span></a></p>
<p><a href="#calibre_link-108"><span><u>2-04-0</u></span><span><u>4</u></span><span><u>　算術代入演算子</u></span></a></p>
<p><a href="#calibre_link-109"><span><u>2-0</u></span><span><u>4</u></span><span><u>　演算子の演習問題</u></span></a></p>
<p><a href="#calibre_link-110"><span><u>2-0</u></span><span><u>5　</u></span><span><u>i</u></span><span><u>f</u></span><span><u>式</u></span></a></p>
<p><a href="#calibre_link-111"><span><u>2-0</u></span><span><u>5　</u></span><span><u>i</u></span><span><u>f</u></span><span><u>式の演習問題</u></span></a></p>
<p><a href="#calibre_link-112"><span><u>2-0</u></span><span><u>6　</u></span><span><u>whil</u></span><span><u>e</u></span><span><u>ループ</u></span><span><u>と</u></span><span><u>do-whil</u></span><span><u>e</u></span><span><u>ループ</u></span></a></p>
<p><a href="#calibre_link-113"><span><u>2-06-0</u></span><span><u>1　</u></span><span><u>whil</u></span><span><u>e</u></span><span><u>ループ</u></span></a></p>
<p><a href="#calibre_link-114"><span><u>2-06-0</u></span><span><u>2　</u></span><span><u>do-whil</u></span><span><u>e</u></span><span><u>ループ</u></span></a></p>
<p><a href="#calibre_link-115"><span><u>2-0</u></span><span><u>6　</u></span><span><u>whil</u></span><span><u>e</u></span><span><u>ループの演習問題</u></span></a></p>
<p><a href="#calibre_link-116"><span><u>2-0</u></span><span><u>7</u></span><span><u>　メソッド</u></span></a></p>
<p><a href="#calibre_link-117"><span><u>2-0</u></span><span><u>7</u></span><span><u>　メソッドの演習問題</u></span></a></p>
<p><a href="#calibre_link-118"><span><u>2-0</u></span><span><u>8</u></span><span><u>　オーバーロード</u></span></a></p>
<p><a href="#calibre_link-119"><span><u>2-0</u></span><span><u>8</u></span><span><u>　オーバーロードの演習問題</u></span></a></p>
<p><a href="#calibre_link-120"><span><b><u>第３章　いよいよオブジェクト指向</u></b></span></a></p>
<p><a href="#calibre_link-121"><span><u>3-0</u></span><span><u>1</u></span><span><u>　クラス</u></span></a></p>
<p><a href="#calibre_link-122"><span><u>3-0</u></span><span><u>1</u></span><span><u>　クラスの基本の演習問題</u></span></a></p>
<p><a href="#calibre_link-123"><span><u>3-0</u></span><span><u>2</u></span><span><u>　基本コンストラクタ</u></span></a></p>
<p><a href="#calibre_link-124"><span><u>3-0</u></span><span><u>2</u></span><span><u>　基本コンストラクタの演習問題</u></span></a></p>
<p><a href="#calibre_link-125"><span><u>3-0</u></span><span><u>3</u></span><span><u>　アクセス修飾子 private</u></span></a></p>
<p><a href="#calibre_link-126"><span><u>3-0</u></span><span><u>3</u></span><span><u>　アクセス修飾子 privat</u></span><span><u>e</u></span><span><u>の演習問題</u></span></a></p>
<p><a href="#calibre_link-127"><span><u>3-0</u></span><span><u>4</u></span><span><u>　補助コンストラクタ</u></span></a></p>
<p><a href="#calibre_link-128"><span><u>3-0</u></span><span><u>4</u></span><span><u>　補助コンストラクタの演習問題</u></span></a></p>
<p><a href="#calibre_link-129"><span><u>3-0</u></span><span><u>5</u></span><span><u>　パラメーターフィールド</u></span></a></p>
<p><a href="#calibre_link-130"><span><u>3-0</u></span><span><u>5</u></span><span><u>　パラメーターフィールドの演習問題</u></span></a></p>
<p><a href="#calibre_link-131"><span><u>3-0</u></span><span><u>6</u></span><span><u>　自己参照</u></span><span><u>の</u></span><span><u>this</u></span></a></p>
<p><a href="#calibre_link-132"><span><u>3-0</u></span><span><u>6</u></span><span><u>　自己参照</u></span><span><u>の</u></span><span><u>thi</u></span><span><u>s</u></span><span><u>の演習問題</u></span></a></p>
<p><a href="#calibre_link-133"><span><u>3-0</u></span><span><u>7</u></span><span><u>　コンパニオンクラス・オブジェクト</u></span></a></p>
<p><a href="#calibre_link-134"><span><u>3-0</u></span><span><u>7</u></span><span><u>　コンパニオンクラス・オブジェクトの演習問題</u></span></a></p>
<p><a href="#calibre_link-135"><span><b><u>第４章　もっとオブジェクト指向</u></b></span></a></p>
<p><a href="#calibre_link-136"><span><u>4-0</u></span><span><u>1</u></span><span><u>　継承</u></span></a></p>
<p><a href="#calibre_link-137"><span><u>4-0</u></span><span><u>1</u></span><span><u>　継承の演習問題</u></span></a></p>
<p><a href="#calibre_link-138"><span><u>4-0</u></span><span><u>2</u></span><span><u>　オーバーライド</u></span></a></p>
<p><a href="#calibre_link-139"><span><u>4-0</u></span><span><u>2</u></span><span><u>　オーバーライドの演習問題</u></span></a></p>
<p><a href="#calibre_link-140"><span><u>4-0</u></span><span><u>3</u></span><span><u>　予約語 super</u></span></a></p>
<p><a href="#calibre_link-141"><span><u>4-0</u></span><span><u>3</u></span><span><u>　予約</u></span><span><u>語</u></span><span><u>supe</u></span><span><u>r</u></span><span><u>の演習問題</u></span></a></p>
<p><a href="#calibre_link-142"><span><u>4-0</u></span><span><u>4</u></span><span><u>　アクセス修飾子 protected</u></span></a></p>
<p><a href="#calibre_link-143"><span><u>4-0</u></span><span><u>4</u></span><span><u>　アクセス修飾</u></span><span><u>子</u></span><span><u>protecte</u></span><span><u>d</u></span><span><u>の演習問題</u></span></a></p>
<p><a href="#calibre_link-144"><span><u>4-0</u></span><span><u>5</u></span><span><u>　抽象クラスと抽象メンバ</u></span></a></p>
<p><a href="#calibre_link-145"><span><u>4-0</u></span><span><u>5</u></span><span><u>　抽象クラスと抽象メンバの演習問題</u></span></a></p>
<p><a href="#calibre_link-146"><span><u>4-0</u></span><span><u>6　</u></span><span><u>fina</u></span><span><u>l</u></span><span><u>クラス</u></span><span><u>と</u></span><span><u>fina</u></span><span><u>l</u></span><span><u>メンバ</u></span></a></p>
<p><a href="#calibre_link-147"><span><u>4-0</u></span><span><u>7　</u></span><span><u>toStrin</u></span><span><u>g</u></span><span><u>メソッドのオーバーライド</u></span></a></p>
<p><a href="#calibre_link-148"><span><u>4-0</u></span><span><u>7　</u></span><span><u>toStrin</u></span><span><u>g</u></span><span><u>メソッドのオーバーライドの演習問題</u></span></a></p>
<p><a href="#calibre_link-149"><span><u>4-0</u></span><span><u>8</u></span><span><u>　トレイト</u></span></a></p>
<p><a href="#calibre_link-150"><span><u>4-0</u></span><span><u>8</u></span><span><u>　トレイトの演習問題</u></span></a></p>
<p><a href="#calibre_link-151"><span><b><u>第５章　高度なテクニック</u></b></span></a></p>
<p><a href="#calibre_link-152"><span><u>5-0</u></span><span><u>1</u></span><span><u>　さまざまなメソッド</u></span></a></p>
<p><a href="#calibre_link-153"><span><u>5-0</u></span><span><u>2</u></span><span><u>　配列</u></span></a></p>
<p><a href="#calibre_link-154"><span><u>5-0</u></span><span><u>2</u></span><span><u>　配列の演習問題</u></span></a></p>
<p><a href="#calibre_link-155"><span><u>5-0</u></span><span><u>3</u></span><span><u>　コマンドライン引数</u></span></a></p>
<p><a href="#calibre_link-156"><span><u>5-0</u></span><span><u>3</u></span><span><u>　コマンドライン引数の演習問題</u></span></a></p>
<p><a href="#calibre_link-157"><span><u>5-0</u></span><span><u>4</u></span><span><u>　タプル</u></span></a></p>
<p><a href="#calibre_link-158"><span><u>5-0</u></span><span><u>4</u></span><span><u>　タプルの演習問題</u></span></a></p>
<p><a href="#calibre_link-159"><span><u>5-0</u></span><span><u>5　</u></span><span><u>List</u></span></a></p>
<p><a href="#calibre_link-160"><span><u>5-0</u></span><span><u>5　</u></span><span><u>Lis</u></span><span><u>t</u></span><span><u>の演習問題</u></span></a></p>
<p><a href="#calibre_link-161"><span><u>5-0</u></span><span><u>6　</u></span><span><u>fo</u></span><span><u>r</u></span><span><u>式</u></span></a></p>
<p><a href="#calibre_link-162"><span><u>5-0</u></span><span><u>6　</u></span><span><u>fo</u></span><span><u>r</u></span><span><u>式の演習問題</u></span></a></p>
<p><a href="#calibre_link-163"><span><u>5-0</u></span><span><u>7　</u></span><span><u>matc</u></span><span><u>h</u></span><span><u>式</u></span></a></p>
<p><a href="#calibre_link-164"><span><u>5-0</u></span><span><u>7　</u></span><span><u>matc</u></span><span><u>h</u></span><span><u>式の演習問題</u></span></a></p>
<p><a href="#calibre_link-165"><span><u>5-0</u></span><span><u>8</u></span><span><u>　例外処</u></span><span><u>理</u></span><span><u>tr</u></span><span><u>y</u></span><span><u>式</u></span></a></p>
<p><a href="#calibre_link-166"><span><u>5-0</u></span><span><u>8</u></span><span><u>　例外処</u></span><span><u>理</u></span><span><u>tr</u></span><span><u>y</u></span><span><u>式の演習問題</u></span></a></p>
<p><a href="#calibre_link-167"><span><u>5-0</u></span><span><u>9</u></span><span><u>　関数リテラルと関数値</u></span></a></p>
<p><a href="#calibre_link-168"><span><u>5-0</u></span><span><u>9</u></span><span><u>　関数リテラルと関数値の演習問題</u></span></a></p>
<p><a href="#calibre_link-169"><span><u>5-1</u></span><span><u>0</u></span><span><u>　パッケージ</u></span></a></p>
<p><a href="#calibre_link-170"><span><u>5-1</u></span><span><u>1</u></span><span><u>　インポート</u></span></a></p>
<p><a href="#calibre_link-171"><span><b><u>付録　演習問題の解答例</u></b></span></a></p>
<p><a href="#calibre_link-172"><span><u>2-0</u></span><span><u>4</u></span><span><u>　演算子の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-173"><span><u>2-0</u></span><span><u>5　</u></span><span><u>i</u></span><span><u>f</u></span><span><u>式の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-174"><span><u>2-0</u></span><span><u>6　</u></span><span><u>whil</u></span><span><u>e</u></span><span><u>ループの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-175"><span><u>2-0</u></span><span><u>7</u></span><span><u>　メソッドの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-176"><span><u>2-0</u></span><span><u>8</u></span><span><u>　オーバーロードの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-177"><span><u>3-0</u></span><span><u>1</u></span><span><u>　クラスの基本の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-178"><span><u>3-0</u></span><span><u>2</u></span><span><u>　基本コンストラクタの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-179"><span><u>3-0</u></span><span><u>3</u></span><span><u>　アクセス修飾子 privat</u></span><span><u>e</u></span><span><u>の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-180"><span><u>3-0</u></span><span><u>4</u></span><span><u>　補助コンストラクタの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-181"><span><u>3-0</u></span><span><u>5</u></span><span><u>　パラメーターフィールドの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-182"><span><u>3-0</u></span><span><u>6</u></span><span><u>　自己参照</u></span><span><u>の</u></span><span><u>thi</u></span><span><u>s</u></span><span><u>の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-183"><span><u>3-0</u></span><span><u>7</u></span><span><u>　コンパニオンクラス・オブジェクトの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-184"><span><u>4-0</u></span><span><u>1</u></span><span><u>　継承の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-185"><span><u>4-0</u></span><span><u>2</u></span><span><u>　オーバーライドの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-186"><span><u>4-0</u></span><span><u>3</u></span><span><u>　予約</u></span><span><u>語</u></span><span><u>supe</u></span><span><u>r</u></span><span><u>の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-187"><span><u>4-0</u></span><span><u>4</u></span><span><u>　アクセス修飾</u></span><span><u>子</u></span><span><u>protecte</u></span><span><u>d</u></span><span><u>の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-188"><span><u>4-0</u></span><span><u>5</u></span><span><u>　抽象クラスと抽象メンバの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-189"><span><u>4-0</u></span><span><u>7　</u></span><span><u>toStrin</u></span><span><u>g</u></span><span><u>メソッドのオーバーライドの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-190"><span><u>4-0</u></span><span><u>8</u></span><span><u>　トレイトの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-191"><span><u>5-0</u></span><span><u>2</u></span><span><u>　配列の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-192"><span><u>5-0</u></span><span><u>3</u></span><span><u>　コマンドライン引数の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-193"><span><u>5-0</u></span><span><u>4</u></span><span><u>　タプルの演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-194"><span><u>5-0</u></span><span><u>5　</u></span><span><u>Lis</u></span><span><u>t</u></span><span><u>の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-195"><span><u>5-0</u></span><span><u>6　</u></span><span><u>fo</u></span><span><u>r</u></span><span><u>式の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-196"><span><u>5-0</u></span><span><u>7　</u></span><span><u>matc</u></span><span><u>h</u></span><span><u>式の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-197"><span><u>5-0</u></span><span><u>8</u></span><span><u>　例外処</u></span><span><u>理</u></span><span><u>tr</u></span><span><u>y</u></span><span><u>式の演習問題の解答例</u></span></a></p>
<p><a href="#calibre_link-198"><span><u>5-0</u></span><span><u>9</u></span><span><u>　関数リテラルと関数値の演習問題の解答</u></span></a></p>
<p>&nbsp;</p>
<p>
<div id="calibre_link-230"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-41">
<div>
<h1 id="calibre_link-231"><b><a id="calibre_link-87"><b><span><b><u>はじめに</u></b></span></b></a></b></h1><p><span>皆様、こんにちは。私は都内でプログラミングの講師をしています飯田健二と申します。私は主にJavaやC#といったプログラミング言語を、たくさんの未経験者にレクチャーしてきました。毎日、どのように解説すれば未経験の方でもしっかりプログラミングできるようになるのか、そればかり考えて生活している次第です。</span></p>
<p>&nbsp;</p>
<p><span>そんな私が数年前、Scalaという歴史的に新しい言語を知りました。私はJava、C#以外にもPHP、Ruby、Python、VBといった言語を理解していますが、Scalaには今までにない感覚を覚えました。「この言語は面白い！」と直感的に思い、それ以来たくさんの書籍に目を通しながら毎日学習を続けています。しかし、その反面、「この言語を初心者の方に教えるのは大変だろうな」とも思いました。Scalaはいろんなアイディアが盛り込まれていて優れている反面、覚えることもたくさんあるのです。</span></p>
<p>&nbsp;</p>
<p><span>現在、書店に並んでいるScalaの書籍は、どちらかというと既に何らかのプログラミング言語（特にJava）を習得済みの方に対して書かれているものが多いように見受けられます。そこで、本書はプログラミング未経験の方でも無理なくScalaを習得していただけるように、説明をできるだけ易しくわかりやすくしました。また、初心者の方でもストレスなく学習できるように、説明内容の順番にはかなりこだわりました。そして、演習問題もたくさんご用意しましたので、すぐに習得具合を確認できるようになっています。</span></p>
<p>&nbsp;</p>
<p><span>本書を通して、皆様がScalaプログラミングの楽しさを知って頂ければ、これに勝る喜びはありません。</span></p>
<p><span>2016年7月　飯田健二</span></p>
<p>
<div id="calibre_link-232"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-222">
<div>
<h1 id="calibre_link-233"><b><a id="calibre_link-88"><b><span><b><u>第１章　まずは入門</u></b></span></b></a></b></h1><p>
<div id="calibre_link-234"></div>
</p>
 
   


</div>
</div>
<div id="calibre_link-77">
<div>
<p>
<br id="calibre_link-235" /></p>
 
   


<h3><b><a id="calibre_link-89"><b><span><b>1-01　Scalaとは？</b></span></b></a></b></h3><p><span>プログラミング言語Scalaは、スイス連邦工科大学のMartin　Odersky教授らによって開発されました。</span></p>
<p><span>現在主流のオブジェクト指向プログラミング言語に、関数型プログラミング言語をミックスした、新しいタイプのプログラミング言語（マルチパラダイム言語）です。</span></p>
<p><span>主な特徴としては、</span></p>
<p>&nbsp;</p>
<p><span>主にJVM（Java　Virtual　Machine）上で動作する</span></p>
<p><span>静的型付け言語である</span></p>
<p><span>型推論の機能がある</span></p>
<p><span>拡張性が高い</span></p>
<p><span>Javaや　.Netのリソースを利用できる</span></p>
<p>&nbsp;</p>
<p><span>などが挙げられます。</span></p>
<p>
<div id="calibre_link-236"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-201">
<div>
<h2 id="calibre_link-237"><b><a id="calibre_link-90"><b><span><b>1-02　予約語</b></span></b></a></b></h2><p><span>「予約語」とは、プログラミング言語の仕様で定められた、特別な意味を持つ単語や記号のことです。RPGでたとえるなら、不思議な力を持つ呪文のようなものといえば分かりやすいかもしれません。</span></p>
<p><span>Scalaには以下のようなたくさんの予約語が存在します。もちろん、現段階ですべてを暗記する必要は全くありません。このような予約語があるということを参考程度に知っておいてください。</span></p>
<p><span>以降の章で、それぞれの予約語の意味を丁寧に解説していきます。</span></p>
<p>&nbsp;</p>
<p><span><b>[予約語一覧]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>abstract</span></p>
</td> 
<td>
<p><span>case</span></p>
</td> 
<td>
<p><span>catch</span></p>
</td> 
<td>
<p><span>class</span></p>
</td> 
<td>
<p><span>def</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>do</span></p>
</td> 
<td>
<p><span>else</span></p>
</td> 
<td>
<p><span>extends</span></p>
</td> 
<td>
<p><span>false</span></p>
</td> 
<td>
<p><span>final</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>finally</span></p>
</td> 
<td>
<p><span>for</span></p>
</td> 
<td>
<p><span>forSome</span></p>
</td> 
<td>
<p><span>if</span></p>
</td> 
<td>
<p><span>implicit</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>import</span></p>
</td> 
<td>
<p><span>lazy</span></p>
</td> 
<td>
<p><span>match</span></p>
</td> 
<td>
<p><span>new</span></p>
</td> 
<td>
<p><span>null</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>object</span></p>
</td> 
<td>
<p><span>override</span></p>
</td> 
<td>
<p><span>package</span></p>
</td> 
<td>
<p><span>private</span></p>
</td> 
<td>
<p><span>protected</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>return</span></p>
</td> 
<td>
<p><span>sealed</span></p>
</td> 
<td>
<p><span>super</span></p>
</td> 
<td>
<p><span>this</span></p>
</td> 
<td>
<p><span>throw</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>trait</span></p>
</td> 
<td>
<p><span>try</span></p>
</td> 
<td>
<p><span>true</span></p>
</td> 
<td>
<p><span>type</span></p>
</td> 
<td>
<p><span>val</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>var</span></p>
</td> 
<td>
<p><span>while</span></p>
</td> 
<td>
<p><span>with</span></p>
</td> 
<td>
<p><span>yield</span></p>
</td> 
<td>
<p><span>_</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>:</p>
</td> 
<td>
<p>=</p>
</td> 
<td>
<p><span>=&gt;</span></p>
</td> 
<td>
<p><span>&lt;-</span></p>
</td> 
<td>
<p><span>&lt;:</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>&lt;%</span></p>
</td> 
<td>
<p><span>&gt;:</span></p>
</td> 
<td>
<p>#</p>
</td> 
<td>
<p>@</p>
</td> 
<td>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p>
<div id="calibre_link-238"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-219">
<div>
<h2 id="calibre_link-239"><b><a id="calibre_link-91"><b><span><b>1-03　識別子</b></span></b></a></b></h2><p><span>「識別子」とは、プログラムの中で変数・関数・クラス（いずれも後述）などに付ける名前のことです。</span></p>
<p><span>たとえば、目の前にかわいい子犬がいて、その子犬に「pochi」という名前をつけたとしましょう。この「pochi」という名前は、目の前のかわいい子犬を表現するための識別子というわけです。</span></p>
<p><span>プログラマはたくさんの識別子を命名しなければいけません。そしてその識別子と、先ほど学習した予約語を組み合わせて、プログラムを作り上げていくわけです。</span></p>
<p><span>Scalaには主に「英数字識別子」と「演算子識別子」の２種類の識別子が存在します。</span></p>
<p><span>どちらもプログラマが自由に命名することができますが、以下のような命名ルールが存在します。このルールを守らないと、プログラムが動作しませんので注意が必要です。</span></p>
<p>&nbsp;</p>
<p><span>[英数字識別子の命名ルール]</span></p>
<p><span>・使用できるのは半角英数字、アンダースコア、ドル記号のみです。</span></p>
<p><span>・先頭に半角数字を使用することはできません。（２文字目以降は可能です）</span></p>
<p><span>・アンダースコアおよびドル記号の使用は推奨されません。</span></p>
<p><span>（アンダースコアやドル記号はScalaにおいて特別な意味があるからです）</span></p>
<p><span>・予約語をそのまま識別子として使用できません。</span></p>
<p>&nbsp;</p>
<p><span>[演算子識別子の命名ルール]</span></p>
<p><span>・使用できるのは　+、-、*、/、%、&lt;、&gt;、|、&amp;、^　などの演算子文字です。</span></p>
<p><span>・演算子文字から始まる場合、他の文字も演算子文字でなければいけません。</span></p>
<p><span>・予約語をそのまま識別子として使用できません。</span></p>
<p>
<div id="calibre_link-240"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-35">
<div>
<h2 id="calibre_link-241"><b><a id="calibre_link-92"><b><span><b>1-04　シングルトンオブジェクトとmainメソッド</b></span></b></a></b></h2><p><span>Scalaプログラムを実行するには、mainメソッドを持つシングルトンオブジェクトというものを記述しなければいけません。（シングルトンオブジェクトの詳細は後述）</span></p>
<p><span>Scalaには３種類のプログラムの実行方法がありますが、本テキストでは最も実践向きであるコンパイル言語としての実行方法を説明します。</span></p>
<p>&nbsp;</p>
<p><span>下記[Sample01]はコマンドプロンプト上に文字列を表示するサンプルプログラムです。まずはお好きなテキストエディタを起動して、次の点に注意して正しく入力してみてください。</span></p>
<p>&nbsp;</p>
<p><span>○プログラムコードは基本的に半角文字を使います。全角文字で入力しないように注意しましょう。</span></p>
<p><span>○Scalaでは、アルファベットの大文字と小文字は全く別の文字なので注意しましょう。</span></p>
<p><span>○大かっこ[]、中かっこ{}、丸かっこ()は必ず始まりと終わりのペアで使用します。</span></p>
<p><span>片一方がないようなかっこの記述をしないように注意しましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample01]初めてのScalaプログラム</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample01{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("First　Scala!")</span></p>
<p><span>　print("Second　")</span></p>
<p><span>　print("Scala!")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>それでは、[Sample01]のプログラムを順に解説していきます。</span></p>
<p>&nbsp;</p>
<p><span>「object」はシングルトンオブジェクトを定義するための予約語であり、そのあとに任意のオブジェクト名（識別子）を付けます。今回はオブジェクト名に「Sample01」という名前をつけました。</span></p>
<p><span>その後に中かっこを記述してシングルトンオブジェクトの中身を記述しています。中かっこの始まりと終わりのセットを「ブロック」といい、プログラムのひとかたまりを表現します。ブロックの中は、半角スペース２つ（または４つ）を空けてから中身となるプログラムを記述します。そのことを「インデント（字下げ）」と言います。</span></p>
<p><span>インデントを入れることでプログラムが読みやすくなり、理解しやすくなります。インデントを入れなくてもプログラムは実行できますが、必ず入れるように心がけましょう。</span></p>
<p>&nbsp;</p>
<p><span>シングルトンオブジェクトの中に記述されている「mainメソッド」は、プログラムのスタート地点を表現するもので、「エントリポイント」と呼ばれます。</span></p>
<p><span>mainメソッドの記述方法は、メソッドの宣言をするための予約語「def」のあとにメソッド名「main」を記述し、丸かっこの中に引数「args:Array[String]」を記述します。その右後ろに中かっこのブロックを記述して、その中に実行したい処理を記述していきます。</span></p>
<p><span>メソッドや引数の詳細は後述しますので、今は引数の「args:Array[String]」の意味は分からなくても大丈夫です。単に「mainメソッドはこの通りに書かなければいけないんだ」という認識で問題ありません。</span></p>
<p>&nbsp;</p>
<p><span>今回のmainメソッド内で使用した「println」と「print」は、コマンドプロンプト上に丸かっこ内のデータを表示する機能を持つ「メソッド」と呼ばれるものです。「println」メソッドは画面出力後に自動的に改行を行いますが、「print」メソッドは自動的に改行を行わないという違いがあります。（ですから「Second　」のあとに改行されずに「Scala!」が表示されます）</span></p>
<p>&nbsp;</p>
<p><span>丸かっこ内に記述されている「"First　Scala!"」「"Second　"」「"Scala!"」は、文字列リテラルと呼ばれる連続した複数の文字を表現するデータです。文字列リテラルはダブルクォーテーションで囲います。（リテラルについては後述します）</span></p>
<p>&nbsp;</p>
<p><span>プログラムの入力が完了したら、ファイル名「Sample01.scala」で保存します。</span></p>
<p><span>Scalaのプログラムソースファイルの拡張子は「.scala」としてください。ファイル名は任意で構わないのですが、一般的にメインとなるシングルトンオブジェクトやクラス、トレイト（いずれも後述）と同じ名前にするのが一般的です。</span></p>
<p><span>さて、次にいよいよプログラムを実行します！</span></p>
<p>
<div id="calibre_link-242"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-26">
<div>
<h2 id="calibre_link-243"><b><a id="calibre_link-93"><b><span><b>1-05　コンパイルと実行</b></span></b></a></b></h2><p><span>注：Scalaの開発環境の構築は非常に簡単ですので、インターネットで調べて最新の環境を構築しておいてください。</span></p>
<p>&nbsp;</p>
<p><span>前節「1-04　シングルトンオブジェクトとmainメソッド」で作成したプログラムを実行してみましょう。しかし、プログラムソースファイルのままでは実行することはできません。実行するには「コンパイル」という下準備が必要なのです。</span></p>
<p><span>まずはコマンドプロンプトを起動します。「コマンドプロンプト」とは、Windows環境で用いるコマンドを利用するためのアプリケーションのことです。「スタート」→「すべてのプログラム」→「アクセサリ」の中にあります。</span></p>
<p><span>アプリケーションを起動すると、以下のような真っ黒い画面が表示されます。</span></p>
<p>&nbsp;</p>
<p><img src="images/00001.jpeg" alt="" /></p>
<p>&nbsp;</p>
<p><span>点滅しているカーソルの左には、現在操作の対象としているディレクトリが表示されており、「カレントディレクトリ」と呼ばれます。</span></p>
<p><span>次に、「cd」コマンドを用いてプログラムソースファイルのあるディレクトリまで移動します。たとえば、「C:¥scala」ディレクトリの中に「Sample01.scala」ファイルを作成したのであれば、次のようにコマンドを実行します。</span></p>
<p>&nbsp;</p>
<p><span> 　&gt;cd　C:¥scala</span></p>
<p>&nbsp;</p>
<p><span>そして「scalac」コマンドを用いて以下のように「コンパイル」を行います。</span></p>
<p>&nbsp;</p>
<p><span> 　&gt;scalac　Sample01.scala</span></p>
<p>&nbsp;</p>
<p><span>「コンパイル」とは、プログラミング言語で書かれたソースコードを解析し、コンピュータが実行可能な形式のバイナリコードに変換することです。また、コンパイルに必要なソフトウェアを「コンパイラ」といいます。</span></p>
<p><span>もしもコンパイルに失敗した場合は、エラー行番号とエラー内容が表示されますので、プログラムの誤りを修正した後にファイルを保存し、再度コンパイルを行います。</span></p>
<p><span>エラーメッセージが表示されなければ、コンパイル成功です。プログラムソースファイルが置いてあるディレクトリに、「Sample01.class」「Sample01$.class」という２つのファイルが生成されていることが確認できると思います。これが、実行可能な形式のファイルとなります。次の「scala」コマンドで実行することができます。実行時は、シングルトンオブジェクト名だけを指定します。拡張子「.class」は不要です。</span></p>
<p>&nbsp;</p>
<p><span>　　&gt;scala　Sample01</span></p>
<p>&nbsp;</p>
<p><span>コマンドプロンプトに「First　Scala!」「Second　Scala!」と表示されれば成功です。</span></p>
<p><span>さて、初めてのScalaはいかがでしたか？</span></p>
<p>
<div id="calibre_link-244"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-82">
<div>
<h2 id="calibre_link-245"><b><a id="calibre_link-94"><b><span><b>1-06　コメント</b></span></b></a></b></h2><p><span>「コメント」とは、プログラマが必要に応じて記述するメモ書きのことであり、コンパイラはコメントをプログラムとして扱わないで無視してくれます。</span></p>
<p><span>Scalaのコメントには「//」を用いた単一行コメントと、「/*　*/」を用いた複数行コメントの２種類があります。</span></p>
<p><span>たとえば、次のようなプログラムをコンパイル・実行することができます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample02]コメントの記述(Sample02.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>//　2016年4月1日作成</span></p>
<p><span>object　Sample02{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("こんにちは")</span></p>
<p>/*</p>
<p><span>　println("こんばんは")</span></p>
<p><span>　println("さようなら")</span></p>
<p>*/</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>実行すると、「こんにちは」だけが出力されます。「こんばんは」と「さようなら」は、プログラム全体がコメントになっているため実行されません。</span></p>
<p><span>この例のように、プログラムの実行を一時的に無効にしたい場合にもコメントが有効です。（コメントアウトといいます）</span></p>
<p><span>ただし、プログラムやコメントに日本語を含める場合は注意が必要です。</span></p>
<p><span>そのままコンパイルを行うと、次のような文字コードに関するコンパイルエラーが発生する場合があります。</span></p>
<p>&nbsp;</p>
<p><span>error:　IO　error　while　decoding　Sample02.scala　with　UTF-8</span></p>
<p><span>Please　try　specifying　another　one　using　the　-encoding　option</span></p>
<p><span>one　error　found</span></p>
<p>&nbsp;</p>
<p><span>これは、ScalaがUTF-8という文字コードを使うことが前提のために起こる現象です。もしこのコンパイルエラーが出たときは、テキストエディタの「名前を付けて保存」を選択し、ファイル名はそのままで文字コード指定を「UTF-8」に変更して上書きすれば解消できます。</span></p>
<p><span>もしソースファイルの文字コードをUTF-8にしたくない場合は、以下のように文字コードのオプションを使用してコンパイルします。</span></p>
<p>&nbsp;</p>
<p><span>　　&gt;scalac　-encoding　Windows-31J　Sample02.scala</span></p>
<p>&nbsp;</p>
<p><span>「Windows-31J」はウィンドウズ環境では一般的な日本語対応文字コードです。</span></p>
<p><span>今後のプログラムも全角文字を使用しているものがありますので、その場合はソースファイルの文字コードをUTF-8に変更して保存し直すか、文字コードのオプション付きコンパイルを行ってください。</span></p>
<p>
<div id="calibre_link-246"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-81">
<div>
<h1 id="calibre_link-247"><b><a id="calibre_link-95"><b><span><b><u>第２章　次に基本</u></b></span></b></a></b></h1><p>
<div id="calibre_link-248"></div>
</p>
 
   


</div>
</div>
<div id="calibre_link-18">
<div>
<p>
<br id="calibre_link-249" /></p>
 
   


<h3><b><a id="calibre_link-96"><b><span><b>2-01　型とリテラル</b></span></b></a></b></h3><p><span>「型」とは、プログラミング言語が扱うデータをいくつかの種類に分類したものです。そして「リテラル」とは、コードに直接記述するデータそのもののことです。</span></p>
<p><span>Scalaには８種類の「値型」が存在し、それにString型を加えたものを「基本型」と呼びます。「基本型」というくらいですから、これらのデータ型はScalaプログラムの基本になるわけです。</span></p>
<p>&nbsp;</p>
<p><span><b>[基本型の一覧]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>Byte</span></p>
</td> 
<td>
<p><span>１バイト符号付き整数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Short</span></p>
</td> 
<td>
<p><span>２バイト符号付き整数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Int</span></p>
</td> 
<td>
<p><span>４バイト符号付き整数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Long</span></p>
</td> 
<td>
<p><span>８バイト符号付き整数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Char</span></p>
</td> 
<td>
<p><span>２バイト符号なしUnicode文字</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>String</span></p>
</td> 
<td>
<p><span>Charの連続した値</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Float</span></p>
</td> 
<td>
<p><span>４バイト単精度浮動小数点数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Double</span></p>
</td> 
<td>
<p><span>８バイト倍精度浮動小数点数</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>Boolean</span></p>
</td> 
<td>
<p><span>true　または　false</span></p>
</td> 
</tr> 
</tbody> 
</table>


<h3><b><a id="calibre_link-97"><b><span><b>2-01-01　整数型と整数リテラル</b></span></b></a></b></h3><p><span>整数型にはByte型、Short型、Int型、Long型の４種類があります。また、整数リテラルは１０進数表現だけではなく、１６進数表現（先頭が0xまたは0X）があります。</span></p>
<p><span>（ちなみに、先頭が0の８進数表現はScala2.11で非推奨になりました）</span></p>
<p><span>整数リテラルはデフォルトでInt型として扱われます。整数リテラルの末尾にアルファベットのL（大文字でも小文字でも良い）が付いている場合は、Long型として扱われます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample03]整数値と整数リテラル(Sample03.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample03{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println(123)</span></p>
<p><span>　println(0x7B)</span></p>
<p><span>　//println(3000000000)コンパイルエラー</span></p>
<p><span>　println(3000000000L)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample03]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>123</span></p>
<p><span>123</span></p>
<p><span>3000000000</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>１６進数表現の整数リテラルをprintlnメソッドで表示した場合、１０進数表現で表示される点に注意してください。</span></p>
<p><span>また、「3000000000（３０億）」はInt型の最大値である約２１億を超えているため、そのまま表示しようとするとコンパイルエラーとなります。末尾にLを付加するとLong型の３０億となり、問題なく扱えるようになります。（Int型よりLong型の方がより大きな数値を扱うことができます）</span></p>
<p><span>表示される数値の末尾にはLが付かない点に注意してください。</span></p>
<p>
<div id="calibre_link-250"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-68">
<div>
<p>
<br id="calibre_link-251" /></p>
 
   

<h3><b><a id="calibre_link-98"><b><span><b>2-01-02　浮動小数点数型と浮動小数点数リテラル</b></span></b></a></b></h3><p><span>浮動小数点数型にはFloat型、Double型の２種類があります。浮動小数点数リテラルはピリオドを使用して小数点を表現することができます。</span></p>
<p><span>また、アルファベットのE（大文字でも小文字でも良い）を用いて指数部を表現することができます。たとえば、「1.2E2」は「1.2×10の2乗」、つまり「120.0」と同じになります。あるいは「1.2E-2」は「1.2×10の-2乗」、つまり「0.012」と同じになります。</span></p>
<p><span>浮動小数点数リテラルはデフォルトでDouble型として扱われます。</span></p>
<p><span>浮動小数点数リテラルの末尾にアルファベットのF（大文字でも小文字でも良い）が付いている場合はFloat型として扱われます。また、浮動小数点数リテラルの末尾にアルファベットのD（大文字でも小文字でも良い）を付けることで、明示的にDouble型として扱うこともできます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample04]浮動小数点数型と浮動小数点数リテラル(Sample04.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample04{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println(3.14)</span></p>
<p><span>　println(1.2E2)</span></p>
<p><span>　println(1.2E-2)</span></p>
<p><span>　println(4.5F)</span></p>
<p><span>　println(5.6D)</span></p>
<p><span>　println(7.8E3F)</span></p>
<p><span>　println(8.9E-3D)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample04]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>3.14</span></p>
<p><span>120.0</span></p>
<p><span>0.012</span></p>
<p><span>4.5</span></p>
<p><span>5.6</span></p>
<p><span>7800.0</span></p>
<p><span>0.0089</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>アルファベットのEを用いて指数表現しても、実際には本当の値（演算後の値）が表示される点に注意してください。</span></p>
<p><span>また、アルファベットのEを用いる指数表現と、明示的に型を指定するFやDを混在させることも可能です。</span></p>
<p><span>表示される数値の末尾にはアルファベットのFやDが付かない点に注意しましょう。</span></p>
<p>
<div id="calibre_link-252"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-213">
<div>
<p>
<br id="calibre_link-253" /></p>
 
   

<h3><b><a id="calibre_link-99"><b><span><b>2-01-03　Boolean型とBooleanリテラル</b></span></b></a></b></h3><p><span>Boolean型は真偽値を表現し、条件分岐や繰り返し構文などで使用します。Booleanリテラルは予約語である「true」と「false」のいずれかのみです。</span></p>
<p><span>真偽値とは、簡単に言うと「○（満たす）」と「×（満たさない）」を表現する値のことです。たとえば、「太郎君は男である」は「true」となり、「日本の通貨はドルである」は「false」となります。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample05]Boolean型とBooleanリテラル(Sample05.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample05{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println(true)</span></p>
<p><span>　println(false)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample05]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>true</span></p>
<p><span>false</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-254"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-5">
<div>
<p>
<br id="calibre_link-255" /></p>
 
   

<h3><b><a id="calibre_link-100"><b><span><b>2-01-04　文字型と文字リテラル</b></span></b></a></b></h3><p><span>文字型にはChar型があります。文字リテラルはUnicode文字をシングルクォートで囲んで表現します。文字リテラルはUnicode文字１文字を表現するものであり、複数の連続したUnicode文字には文字列型（後述）を使用します。</span></p>
<p><span>Unicode文字は実際には２バイト符号なし整数（0～65535）のため、「¥u」の後に１６進数４桁の値をシングルクォートで囲って文字を表現することも可能です。</span></p>
<p><span>また、特殊文字を文字リテラルとして表現したい場合は、「エスケープシーケンス」</span></p>
<p><span>を使用します。「エスケープシーケンス」とは、¥マークの記号（環境によってはバックスラッシュになります）に不思議な力があり、「¥マーク＋ある１文字」で特殊文字を表現できるようになることです。</span></p>
<p>&nbsp;</p>
<p><span><b>[エスケープシーケンス一覧]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>¥n</span></p>
</td> 
<td>
<p><span>改行</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥b</span></p>
</td> 
<td>
<p><span>バックスペース</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥t</span></p>
</td> 
<td>
<p><span>タブ</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥f</span></p>
</td> 
<td>
<p><span>改ページ</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥r</span></p>
</td> 
<td>
<p><span>復帰</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥'</span></p>
</td> 
<td>
<p><span>シングルクォート</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>¥"</span></p>
</td> 
<td>
<p><span>ダブルクォート</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>¥¥</p>
</td> 
<td>
<p><span>円記号</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample06]文字型と文字リテラル(Sample06.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample06{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println('A')</span></p>
<p><span>　println('あ')</span></p>
<p><span>　println('亜')</span></p>
<p><span>　println('¥'')</span></p>
<p><span>　println('¥¥')</span></p>
<p><span>　println('¥u0041')</span></p>
<p><span>　//println('ABC')</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample06]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>A</span></p>
<p><span>あ</span></p>
<p><span>亜</span></p>
<p><span>'</span></p>
<p>¥</p>
<p><span>A</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>「¥u0041」を表示する行の出力が「A」であることに注意してください。文字の「A」は数値としては「65」として扱われるため、１６進数表現で「0041」となるためです。</span></p>
<p><span>エスケープシーケンスは¥マークとそれに続く１文字のセットで特殊文字１文字を表現することができます。</span></p>
<p><span>最後の行のコメントを取ると、コンパイルエラーになります。文字型は１文字しか表現できないためです。</span></p>
<p>
<div id="calibre_link-256"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-3">
<div>
<p>
<br id="calibre_link-257" /></p>
 
   

<h3><b><a id="calibre_link-101"><b><span><b>2-01-05　文字列型と文字列リテラル（生文字列リテラル）</b></span></b></a></b></h3><p><span>文字列型にはString型があります。文字列リテラルは連続したUnicode文字をダブルクォートで囲んで表現します。また、文字リテラルと同様、特殊文字を文字列リテラルとして表現したい場合は、エスケープシーケンスを使用します。</span></p>
<p><span>生文字列リテラルは、ダブルクォート３つ連続で囲まれた、連続したUnicode文字   　であり、エスケープシーケンスはそのままの文字として解釈されます。</span></p>
<p><span>また、改行、シングルクォーテーションやダブルクォーテーション、特殊文字などをそのまま含めることができます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample07]文字列型と文字列リテラル(Sample07.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample07{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("おはよう")</span></p>
<p><span>　println("こんにちは¥nこんばんは")</span></p>
<p><span>　println("""'さようなら'</span></p>
<p><span>"おやすみ"</span></p>
<p><span>""")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample07]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>おはよう</span></p>
<p><span>こんにちは</span></p>
<p><span>こんばんは</span></p>
<p><span>'さようなら'</span></p>
<p><span>"おやすみ"</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>「こんにちは」と「こんばんは」の間に記述している「¥n」は改行コードを表すエスケープシーケンスなので、表示時にはきちんと改行されています。</span></p>
<p><span>生文字列リテラルは少し不思議ですが、改行そのものを含めることができます。また、シングルクォートやダブルクォートなどの特殊記号もそのまま表示されます。</span></p>
<p>
<div id="calibre_link-258"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-42">
<div>
<h2 id="calibre_link-259"><b><a id="calibre_link-102"><b><span><b>2-02　変数</b></span></b></a></b></h2><p><span>「変数」とは、さまざまなデータを格納するための入れ物のことです。プログラムとはデータをあっちからこっちへ、こっちからあっちへと受け渡すためのものなので、そのためにはデータの入れ物「変数」が欠かせないわけです。</span></p>
<p><span>変数というデータの入れ物を用意することを「変数の宣言」といいます。特に、メソッドの中で宣言された変数を「ローカル変数」と呼びます。</span></p>
<p><span>Scalaには「var」と「val」の２種類の変数宣言用の予約語が存在します。「var」は可変の変数（再代入可能）、「val」は不変の変数（再代入不可）を意味します。</span></p>
<p>&nbsp;</p>
<p><span><b>[変数の宣言方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>var　変数名:変数の型=初期値</span></p>
<p><span>val　変数名:変数の型=初期値</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>「=」は代入演算子と呼ばれるもので、右辺の値を左辺の変数に格納します。Scalaでは「=」に「等しい」の意味はありませんので注意が必要です。（「等しい」を意味する比較演算子は「==」を使用します）</span></p>
<p><span>また、Scalaでは、できるだけvalを使用することが推奨されています。「var」、「val」のいずれを用いた変数宣言の場合も、変数には初期値を代入する必要があります。（特殊なケースを除く）</span></p>
<p><span>変数にも型があり、原則的に同じ型の値しか代入することができません。</span></p>
<p><span>変数に格納した値を使用したい場合は、単に変数名を記述すれば値が取り出せます。値を取り出すといっても、変数という箱のデータが空っぽになるわけではありません。データのコピーが取り出されるというイメージです。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample08]変数(Sample08.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample08{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x1:Int=10</span></p>
<p><span>　//x1=20</span></p>
<p><span>　var　x2:Int=30</span></p>
<p><span>　x2=40</span></p>
<p><span>　val　x3:Double=x2</span></p>
<p><span>　//val　x4:Int="Hello"</span></p>
<p><span>　println(x1)</span></p>
<p><span>　println(x2)</span></p>
<p><span>　println(x3)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample08]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>10</span></p>
<p><span>40</span></p>
<p><span>40.0</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>変数x1はvalを用いてInt型として宣言し、初期値に10を代入しています。その次の行はコメントになっていますが、コメントを取るとコンパイルエラーになります。何故なら、val変数は値の再代入ができないからです。（つまり初期値から変更することができないわけです）</span></p>
<p><span>変数x2はvarを用いてInt型として宣言し、初期値に30を代入しています。その次の行で40を再代入していますが、varの場合は再代入可能なので問題ありません。</span></p>
<p><span>変数x3はvalを用いてDouble型として宣言し、初期値に変数x2の値を格納しています。変数x3と変数x2は型が異なりますが、Double型はInt型より大きな数値を扱えるために互換性があります。値型（Boolean・Char以外）には次のような大小関係があります。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>Byte&lt;Short&lt;Int&lt;Long&lt;Float&lt;Double</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>つまり、Byte型の値はShort型の変数に代入可能、Float型の値はDouble型の変数に代入可能なわけです。</span></p>
<p><span>変数x4はvalを用いてInt型として宣言し、初期値に"Hello"、つまり文字列リテラルを代入しようとしています。Int型とString型には互換性がありませんので、コメントを取るとコンパイルエラーになります。</span></p>
<p><span>画面にデータを出力するprintlnメソッドの丸かっこの中に、変数をそのまま記述しています。そうすると、画面上にはきちんと変数の持つ値が出力されていることが確認できます。</span></p>
<p>
<div id="calibre_link-260"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-199">
<div>
<h2 id="calibre_link-261"><b><a id="calibre_link-103"><b><span><b>2-03　型推論</b></span></b></a></b></h2><p><span>「型推論」とは、プログラムで省略した型情報を文脈から自動的に判断する機能の</span></p>
<p><span>ことです。Scalaでは、この型推論をサポートしています。</span></p>
<p><span>よって、先ほどの変数の宣言では、変数の型の指定は記述しなくても初期値から自動的に型を判断してくれます。</span></p>
<p><span>ただし、Scalaは「静的型付け言語」といって、変数には必ず型が存在し、後から型を変更することはできません。変数に型が存在しない「動的型付け言語」との違いに注意しましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample09]型推論(Sample09.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample09{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　var　x1=10</span></p>
<p><span>　//x1="こんにちは"</span></p>
<p><span>　x1=20</span></p>
<p><span>　var　x2="こんばんは"</span></p>
<p><span>　//x2=100</span></p>
<p><span>　x2="さようなら"</span></p>
<p><span>　println(x1)</span></p>
<p><span>　println(x2)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample09]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>20</span></p>
<p><span>さようなら</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>変数x1はvarを用いて宣言し、初期値に「10」を代入しています。変数の型は指定していませんが、初期値の「10」は整数リテラルであり、整数リテラルのデフォルトはInt型なので自動的に判断し、変数x1をInt型に設定します。これが「型推論」です。</span></p>
<p><span>よって、次の行で変数x1に文字列リテラル「こんにちは」を代入しようとすると型が異なるためにコンパイルエラーとなります。</span></p>
<p><span>さらにその次の行では変数x1に「20」を代入していますが、整数リテラル「20」はデフォルトでInt型とみなされるので問題なく再代入できます。</span></p>
<p><span>変数x2も同様にvarを用いて宣言していますが、型の指定は行っていません。しかし、初期値が文字列リテラルの「こんばんは」なので、自動的に判断されて変数x2はString型に設定されます。よって、次の行で変数x2に整数リテラル「100」を代入しようとすると、型が異なるためコンパイルエラーになります。ただし、その次の行では文字列リテラルの「さようなら」を再代入することは可能です。</span></p>
<p>
<div id="calibre_link-262"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-27">
<div>
<h2 id="calibre_link-263"><b><a id="calibre_link-104"><b><span><b>2-04　演算子</b></span></b></a></b></h2><p><span>「演算子」とは、演算（計算のこと）の内容を指示する記号のことです。Scalaには基本型の値を変換・操作する演算子が豊富に提供されています。</span></p>
<p><span>（実際には、Scalaではすべての演算子はメソッドとして実装されています）</span></p>


<h3><b><a id="calibre_link-105"><b><span><b>2-04-01　算術演算子と文字列連結演算子</b></span></b></a></b></h3><p><span>「算術演算子」とは、いわゆる算数の「加減乗除」などを行うための演算子です。加算は「+」、減算は「-」で算数と同じなのですが、乗算は「×」ではなく「*」、除算は「÷」ではなく「/」を用いるので注意しましょう。また、プログラムの世界では除算の余りを求める剰余演算子「%」もよく使われます。</span></p>
<p><span>演算子「+」には２つの意味があり、ひとつは算術演算としての加算です。「+」演算子の左右の値が数値の場合は、加算が行われます。もうひとつは文字列連結演算です。「+」演算子の左右のどちらかが文字列型の場合、左右の値は文字列として連結されます。</span></p>
<p><span>さらに、演算子「-」にも２つの意味があり、ひとつは算術演算としての減算です。もうひとつは数値のプラスマイナスを反転するための単項演算子としての「-」です。符号を反転したい値の左前に「-」を付加します。</span></p>
<p>&nbsp;</p>
<p><span><b>[算術演算子（文字列連結演算子）一覧]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p>+</p>
</td> 
<td>
<p><span>加算または文字列の連結</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>-</p>
</td> 
<td>
<p><span>減算または符号反転</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>*</p>
</td> 
<td>
<p><span>乗算</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>/</p>
</td> 
<td>
<p><span>除算</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>%</p>
</td> 
<td>
<p><span>剰余</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample10]算術演算子と文字列連結演算子(Sample10.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample10{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=7</span></p>
<p><span>　val　y=3</span></p>
<p><span>　println(x+y)</span></p>
<p><span>　println(x-y)</span></p>
<p><span>　println(x*y)</span></p>
<p><span>　println(x/y)</span></p>
<p><span>　println(x%y)</span></p>
<p><span>　println(-x)</span></p>
<p><span>　val　a="Hello　"</span></p>
<p><span>　val　b="Scala!"</span></p>
<p><span>　println(a+b)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample10]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>10</span></p>
<p><span>4</span></p>
<p><span>21</span></p>
<p><span>2</span></p>
<p><span>1</span></p>
<p><span>-7</span></p>
<p><span>Hello　Scala!</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-264"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-75">
<div>
<p>
<br id="calibre_link-265" /></p>
 
   

<h3><b><a id="calibre_link-106"><b><span><b>2-04-02　関係演算子</b></span></b></a></b></h3><p><span>「関係演算子」とは２つのデータの大小関係などを調査し、その演算結果をBoolean型で返すものです。その関係が成り立つ場合は「true」、成り立たない場合は「false」を返します。</span></p>
<p><span>Scalaでは「等しい」を意味する関係演算子は「==」を使用します。「=」は代入演算子なので、間違えないように注意しましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[関係演算子一覧]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;</span></p>
</td> 
<td>
<p><span>より大きい</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>&gt;=</span></p>
</td> 
<td>
<p><span>以上</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>&lt;</span></p>
</td> 
<td>
<p><span>より小さい</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>&lt;=</span></p>
</td> 
<td>
<p><span>以下</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>==</p>
</td> 
<td>
<p><span>等しい</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>!=</p>
</td> 
<td>
<p><span>等しくない</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample11]関係演算子(Sample11.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample11{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=7</span></p>
<p><span>　val　y=3</span></p>
<p><span>　println(x+"=="+y+":"+(x==y))</span></p>
<p><span>　println(x+"!="+y+":"+(x!=y))</span></p>
<p><span>　println(x+"&gt;"+y+":"+(x&gt;y))</span><span>println(x+"&lt;"+y+":"+(x&lt;y))</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample11]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>7==3:false</span></p>
<p><span>7!=3:true</span></p>
<p><span>7&gt;3:true</span></p>
<p><span>7&lt;3:false</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>演算子には優先順位があり、「+」と「==」では「+」の方が優先順位は高くなります。そのため、文字列連結より先に関係演算を行うために丸かっこで囲っています。丸かっこで囲われた演算は、どの演算よりも優先されます。</span></p>
<p>
<div id="calibre_link-266"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-12">
<div>
<p>
<br id="calibre_link-267" /></p>
 
   

<h3><b><a id="calibre_link-107"><b><span><b>2-04-03　論理演算子</b></span></b></a></b></h3><p><span>「論理演算子」とは、Boolean型の値を演算するもので、その演算結果もBoolean型になります。単項演算子の「!」はBoolean型の値の左前に付加します。</span></p>
<p>&nbsp;</p>
<p><span><b>[論理演算子一覧]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&amp;&amp;</span></p>
</td> 
<td>
<p><span>論理積（AND）</span></p>
<p><span>左右の値がどちらもtrueの場合はtrue、</span></p>
<p><span>それ以外の場合はfalse</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>||</p>
</td> 
<td>
<p><span>論理和（OR）</span></p>
<p><span>左右の値のいずれかがtrueの場合はtrue、</span></p>
<p><span>それ以外の場合はfalse</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>!</span></p>
</td> 
<td>
<p><span>否定（NOT）</span></p>
<p><span>trueをfalseに、falseをtrueに反転する</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample12]論理演算子(Sample12.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample12{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=7</span></p>
<p><span>　val　y=3</span></p>
<p><span>　print(x+"&gt;5&amp;&amp;"+y+"&gt;5:")</span><span>println(x&gt;5&amp;&amp;y&gt;5)</span></p>
<p><span>　print(x+"&gt;5||"+y+"&gt;5:")</span></p>
<p><span>　println(x&gt;5||y&gt;5)</span></p>
<p><span>　print("!("+x+"&gt;5):")</span></p>
<p><span>　println((!(x&gt;5)))</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample12]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>7&gt;5&amp;&amp;3&gt;5:false</span></p>
<p><span>7&gt;5||3&gt;5:true</span></p>
<p><span>!(7&gt;5):false</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-268"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-60">
<div>
<p>
<br id="calibre_link-269" /></p>
 
   

<h3><b><a id="calibre_link-108"><b><span><b>2-04-04　算術代入演算子</b></span></b></a></b></h3><p><span>「算術代入演算子」とは、変数の値を演算した結果を同じ変数に再代入するときに便利な演算子です。たとえば、変数xの値を1増やしたい場合、「x=x+1」と記述することも可能ですが、通常は算術代入演算子を用いて「x+=1」と記述します。</span></p>
<p><span>もちろん、変数に演算結果を再代入するわけですから「var変数」のみ可能であり、「val変数」に算術代入演算子を用いるとコンパイルエラーになります。</span></p>
<p>&nbsp;</p>
<p><span><b>[算術代入演算子一覧]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p>+=</p>
</td> 
<td>
<p><span>左辺の変数に右辺の値の加算結果を再代入する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>-=</p>
</td> 
<td>
<p><span>左辺の変数に右辺の値の減算結果を再代入する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>*=</p>
</td> 
<td>
<p><span>左辺の変数に右辺の値の乗算結果を再代入する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>/=</p>
</td> 
<td>
<p><span>左辺の変数に右辺の値の除算結果を再代入する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p>%=</p>
</td> 
<td>
<p><span>左辺の変数に右辺の値の剰余結果を再代入する</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample13]算術代入演算子(Sample13.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample13{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　var　x=7</span></p>
<p><span>　x+=3</span></p>
<p><span>　println("x="+x)</span></p>
<p><span>　x-=2</span></p>
<p><span>　println("x="+x)</span></p>
<p><span>　x*=3</span></p>
<p><span>　println("x="+x)</span></p>
<p><span>　x/=2</span></p>
<p><span>　println("x="+x)</span></p>
<p><span>　x%=5</span></p>
<p><span>　println("x="+x)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample13]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>x=10</span></p>
<p><span>x=8</span></p>
<p><span>x=24</span></p>
<p><span>x=12</span></p>
<p><span>x=2</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>算術代入演算子は算数には存在しないので、慣れないと難しく感じられるかもしれません。しかし、Scalaでは（あるいは多くのプログラミング言語では）よく用いられる表現ですので、早く慣れるように心がけましょう。</span></p>
<p>
<div id="calibre_link-270"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-224">
<div>
<h2 id="calibre_link-271"><b><a id="calibre_link-109"><b><span><b>2-04　演算子の演習問題</b></span></b></a></b></h2><p><span>コメント１～４の指示に従って、Practice01シングルトンオブジェクトを完成させてください。実行結果は、下記のような出力になるようにしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice01]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>変数yの値：6</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice01]演算子の演習問題(Practice01.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice01{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p>&nbsp;</p>
<p><span>　//1.Int型のvar変数xを宣言し、</span></p>
<p><span>　// 　初期値として10を代入してください</span></p>
<p>&nbsp;</p>
<p><span>　//2.変数xの値を2倍して、変数xに</span></p>
<p><span>　// 　再格納してください</span></p>
<p>&nbsp;</p>
<p><span>　//3.Int型のval変数yを宣言し、</span></p>
<p><span>　// 　初期値として変数xの値を7で割った</span></p>
<p><span>　// 　余りを代入してください</span></p>
<p>&nbsp;</p>
<p><span>　//4.変数yの値を文字列の説明付きで</span></p>
<p><span>　// 　出力してください</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-272"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-46">
<div>
<h2 id="calibre_link-273"><b><a id="calibre_link-110"><b><span><b>2-05　if式</b></span></b></a></b></h2><p><span>「if式」とは、条件分岐を行うための言語構文です。</span></p>
<p><span>たとえば、あるときはAパターンの処理を行い、またあるときはBパターンの処理を行うといったような、状況に応じて処理を分岐するようなときに使用します。</span></p>
<p>&nbsp;</p>
<p><span><b>[if式の文法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>if(条件式１){</span></p>
<p><span>条件式１がtrueの場合に実行</span></p>
<p>}</p>
<p><span>else　if(条件式２){</span></p>
<p><span>　　条件１がfalseで、条件式２が</span></p>
<p><span> 　trueの場合に実行</span></p>
<p>}</p>
<p><span>else{</span></p>
<p><span>条件式１、条件式２が共にfalse</span></p>
<p><span> 　の場合に実行</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まず、予約語「if」で始まり、丸かっこに条件式（trueかfalseで表現できる値）を記述します。trueであればその後のブロックの中を実行し、if式は終了します。falseであれば、今度はその次の「else　if」の丸かっこの条件式を評価します。trueであればその後のブロックの中を実行し、if式は終了します。</span></p>
<p><span>「else　if」は「if」の後であれば、いくつでも記述することができますし、なくても構いません。</span></p>
<p><span>「else」は最後に一度だけ記述できます。記述しなくても構いません。「else」には丸かっこがなく、上記の「if」や「else　if」のすべての条件式がfalseの場合にのみ実行されます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample14]if式の基本(Sample14.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample14{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　age=18</span></p>
<p><span>　print(age+"歳は")</span></p>
<p><span>　if(age&gt;=20){</span></p>
<p><span>　println("成人です")</span></p>
<p>}</p>
<p><span>　else　if(age&lt;20&amp;&amp;age&gt;=0){</span></p>
<p><span>　println("未成年です")</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　println("不明です")</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample14]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>18歳は未成年です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は「println」メソッドの他に「print」メソッドを使用しました。「println」メソッドが文字列を出力した最後に改行を入れるのに対し、「print」メソッドは最後に改行を入れません。よって出力が「18歳は未成年です」と、改行を含んでいません。</span></p>
<p><span>未成年の出力の条件は「0歳以上20歳未満」ですが、「age&lt;20&amp;&amp;age&gt;=0」のように関係演算子と論理演算子を組み合わせて記述する必要があります。プログラミングの初級者はつい「0&lt;=age&lt;20」と記述してしまいがちなので注意しましょう。</span></p>
<p>&nbsp;</p>
<p><span>Scalaのif式は「値を返すことができる」のが重要なポイントです。その場合は、ブロックの中の処理の最後に値だけを記述します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample15]値を返すif式(Sample15.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample15{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　month=7</span></p>
<p><span>　val　season=</span></p>
<p><span>　if(month&gt;=3&amp;&amp;month&lt;=5){</span></p>
<p><span>　"春"</span></p>
<p>}</p>
<p><span>　else　if(month&gt;=6&amp;&amp;month&lt;=8){</span></p>
<p><span>　"夏"</span></p>
<p>}</p>
<p><span>　else　if(month&gt;=9&amp;&amp;month&lt;=11){</span></p>
<p><span>　"秋"</span></p>
<p>}</p>
<p><span>　else　if(month==12||month==1||month==2){</span></p>
<p><span>　"冬"</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　"不明"</span></p>
<p>}</p>
<p><span>　println(month+"月は"+season+"です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample15]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>7月は夏です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このサンプルのように、if式は値を返すことができます。なので、val変数monthの値に応じてval変数seasonに季節を表す文字列を格納しています。各「if」、「else　if」、「else」のブロックの中に季節を表現する値（文字列リテラル）だけを書いているところがポイントです。</span></p>
<p><span>また、一般的に「else」は想定外の値を処理する際によく使われます。今回の２つのサンプルでも、どちらのif式ともに「else」は「不明です」を出力、または「不明」という値を返しています。</span></p>
<p><span>今回のif式のような条件分岐はプログラムの要となりますので、しっかりと理解してください。</span></p>
<p>
<div id="calibre_link-274"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-205">
<div>
<h2 id="calibre_link-275"><b><a id="calibre_link-111"><b><span><b>2-05　if式の演習問題</b></span></b></a></b></h2><p><span>次の指示に従って、Practice02シングルトンオブジェクトを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>１．肥満度（BMI）測定を行うプログラムを作成しましょう。Double型の２つのval変数（身長heightと体重weight）があります。その２つの値はキーボードから受け付けます。（その部分は完成しています）</span></p>
<p><span>２．Double型のval変数bmiを宣言し、初期値にBMI値を格納します。BMI値の算出方法は以下の通りです。尚、身長はメートル換算した値を使用してください。</span></p>
<p><span>　BMI　=　(体重kg)　÷（身長mの二乗）</span></p>
<p><span>３．String型のval変数resultを宣言し、変数bmiの値に応じて次の文字列を格納します。</span></p>
<p>&nbsp;</p>
<p><span>　26.5以上       　...「肥満」</span></p>
<p><span>　26.5未満24以上 　...「太り気味」</span></p>
<p><span>　24未満20以上   　...「普通」</span></p>
<p><span>　それ以外       　...「スリム」</span></p>
<p>&nbsp;</p>
<p><span>４．最後に、下記実行結果を参考にして出力を行ってください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice02]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>身長（cm）を入力してください</span></p>
<p><span>180</span></p>
<p><span>体重（kg）を入力してください</span></p>
<p><span>76</span></p>
<p><span>あなたのBMI値は23.456790123456788です</span></p>
<p><span>あなたは普通です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice02]if式の演習問題(Practice02.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice02{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("身長（cm）を入力してください")</span></p>
<p><span>　val　height=scala.io.StdIn.readDouble</span></p>
<p><span>　println("体重（kg）を入力してください")</span><span>val　weight=scala.io.StdIn.readDouble</span></p>
<p>&nbsp;</p>
<p><span>　//ここからプログラミングしてください</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-276"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-34">
<div>
<h2 id="calibre_link-277"><b><a id="calibre_link-112"><b><span><b>2-06　whileループとdo-whileループ</b></span></b></a></b></h2><p><span>Scalaでは基本的な繰り返し構文として、「whileループ」と「do-whileループ」が存在します。（もうひとつの「for式」については後述します）</span></p>


<h3><b><a id="calibre_link-113"><b><span><b>2-06-01　whileループ</b></span></b></a></b></h3><p><span>whileループは、予約語「while」の後の丸かっこの中に条件式（trueかfalseで表現できる値）を記述します。</span></p>
<p>&nbsp;</p>
<p><span><b>[whileループの構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>while(条件式){</span></p>
<p><span>繰り返したい処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>条件式がtrueの場合はその後のブロックの中に入り、繰り返したい処理を実行します。その後、再び条件式を評価します。つまり、条件式がfalseになるまで繰り返し処理を実行します。</span></p>


<h3><b><a id="calibre_link-114"><b><span><b>2-06-02　do-whileループ</b></span></b></a></b></h3><p><span>do-whileループも発想的にはwhileループと同様です。</span></p>
<p>&nbsp;</p>
<p><span><b>[do-whileループの構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>do{</span></p>
<p><span> 　繰り返したい処理</span></p>
<p><span>}while(条件式)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>唯一の違いは、do-whileループの場合は条件式の評価がブロックの下にある点です。よって、まず予約語「do」の後のブロックの中に入り、繰り返したい処理を実行し、その後に条件式を評価します。条件式がtrueの場合、ブロックの上に戻ってもう一度繰り返したい処理を行います。</span></p>
<p><span>よって、条件式が最初からfalseの場合、whileループは処理を行わないことになりますが、do-whileループは最低１回だけでも処理を行うということになります。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample16]whileループとdo-whileループ(Sample16.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample16{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("whileループ")</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;5){</span></p>
<p><span>　println(i)</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p><span>　println("do-whileループ")</span></p>
<p><span>　var　j=10</span></p>
<p><span>　do{</span></p>
<p><span>　println(j)</span></p>
<p><span>　j+=1</span></p>
<p><span>　}while(j&lt;5)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample16]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>whileループ</span></p>
<p><span>0</span></p>
<p><span>1</span></p>
<p><span>2</span></p>
<p><span>3</span></p>
<p><span>4</span></p>
<p><span>do-whileループ</span></p>
<p><span>10</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のようなループ処理において、「i+=1」を記述し忘れるようなミスをしないように注意しましょう。もし記述し忘れると、条件式が永遠にtrueのため、処理が終わらない「無限ループ」というバグが発生します。</span></p>
<p><span>また、今回のdo-whileループは、最初から条件式がfalseになるように設定しています。それでも最低１回はブロック内の処理を実行する点を押さえてください。</span></p>
<p>
<div id="calibre_link-278"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-83">
<div>
<h2 id="calibre_link-279"><b><a id="calibre_link-115"><b><span><b>2-06　whileループの演習問題</b></span></b></a></b></h2><p><span>次の指示に従って、Practice03シングルトンオブジェクトを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>１．while文を使って簡単な数当てゲームを作りましょう。Int型のval変数answerには、1から10までの値がランダムに設定されます。(この部分は完成しています)</span></p>
<p>&nbsp;</p>
<p><span>２．ユーザから整数の入力を受け付け、その値をInt型のval変数inputに格納します。（この部分も完成しています）</span></p>
<p>&nbsp;</p>
<p><span>３．回答できる回数を保持するInt型のvar変数countを宣言し、初期値に3を代入します。（つまり、３回だけ回答することができるようにします）</span></p>
<p>&nbsp;</p>
<p><span>４．入力値と正解の値が等しい場合は「正解です♪答えは[正解の値]でした！」と表示してゲームを終了します。</span></p>
<p>&nbsp;</p>
<p><span>５．入力値と正解の値が異なる場合は、変数countの値を1減らします。変数countの値が0になったら、「残念...正解は[正解の値]でした！」と表示してゲームを終了します。変数countの値が0でない場合は、次の回答のためのヒントを表示します。入力値が正解の値より大きい場合は「答えは[入力値]より小さい値です」と表示し、入力値が正解の値より小さい場合は「答えは[入力値]より大きい値です」と表示します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice03]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;scala　Practice03</span></p>
<p><span>数値を入力してください（残り3回）</span></p>
<p><span>1</span></p>
<p><span>答えは1より大きい値です</span></p>
<p><span>数値を入力してください（残り2回）</span></p>
<p><span>4</span></p>
<p><span>正解です♪答えは4でした！</span></p>
<p>&nbsp;</p>
<p><span>&gt;scala　Practice03</span></p>
<p><span>数値を入力してください（残り3回）</span></p>
<p><span>1</span></p>
<p><span>答えは1より大きい値です</span></p>
<p><span>数値を入力してください（残り2回）</span></p>
<p><span>4</span></p>
<p><span>答えは4より大きい値です</span></p>
<p><span>数値を入力してください（残り1回）</span></p>
<p><span>6</span></p>
<p><span>残念...正解は5でした！</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice03]whileループの演習問題(Practice03.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice03{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　//答え変数（1から10までの値をランダムに設定）</span></p>
<p><span>　val　answer=scala.util.Random.nextInt(10)+1</span></p>
<p>&nbsp;</p>
<p><span>//ここからプログラミングしてください</span></p>
<p>&nbsp;</p>
<p><span>　//入力値の受付</span></p>
<p><span>　val　input=scala.io.StdIn.readInt</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-280"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-8">
<div>
<h2 id="calibre_link-281"><b><a id="calibre_link-116"><b><span><b>2-07　メソッド</b></span></b></a></b></h2><p><span>「メソッド」とは、シングルトンオブジェクトやクラス（後述）、トレイト（後述）が持つ「処理のひとまとまり」のことです。今まで記述してきたmainメソッド以外に、プログラマがメソッドを自由に定義（つまり作成）することができます。</span></p>
<p>&nbsp;</p>
<p><span><b>[メソッドの定義方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>def　メソッド名(引数リスト):結果型={</span></p>
<p><span> 　メソッド本体</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>たとえば、「1」と「2」という２つの整数を受け取って処理（足し算）を行い、「3」を仕事の成果として返す「sum」という名前のメソッドを定義してみましょう。</span></p>
<p>&nbsp;</p>
<p><img src="images/00000.jpeg" alt="" /></p>
<p>&nbsp;</p>
<p><span>予約語「def」の後にプログラマが好きなメソッド名（識別子)をつけることができます。今回のメソッド名は「sum」になります。</span></p>
<p><span>「引数」とは、仕事をするのに必要となるデータ（つまりインプットデータ）のことです。今回の場合「1」と「2」という２つの整数を、メソッド利用者側から受け取る必要があります。簡単にいうと、「引数」とは初期値を設定しない「valローカル変数」のことです。初期値はメソッドを利用する（メソッド呼び出しと言います）際に、利用者から渡されます。</span></p>
<p><span>ここでポイントですが、メソッドの中で宣言する「ローカル変数」の場合は、「型推論」の機能を用いることができました。よって、ローカル変数宣言時に型の指定は不要だったわけです。しかし、メソッドの引数は型推論が行われないため、型の指定が必須になります。</span></p>
<p><span>引数は、カンマで区切って複数記述することができます。これを「引数リスト」といいます。今回の場合は２つの整数を受け取るので、「def　sum(x:Int,y:Int)」のようになります。（引数名xとyは任意なので、好きな名前で構いません）</span></p>
<p><span>また、引数を受け取らないメソッドの場合、メソッド名の後ろの丸かっこの中身は空にします。あるいは、丸かっこそのものを省略することも可能です。</span></p>
<p><span>「結果型」とは、仕事の成果のデータが何型であるかを表現するものです。（つまりアウトプットデータの型）</span></p>
<p><span>今回は「1」と「2」を足した結果は「3」なので、結果型はInt型になります。そして、結果型の値を「結果値」といいます。メソッドには仕事の成果が特にないものもあり、その場合はUnit型という特殊な扱いになります。また、引数と違って結果型は型推論が可能なため、型の指定を省略することも可能です。結果型の右後ろには等号（=）を記述しますが、結果型がUnit型の場合はなくても構いません。</span></p>
<p><span>「メソッド本体」は、具体的な処理内容を記述します。今回の場合ですと、「1+2」という加算演算がメソッドの本体になります。</span></p>
<p><span>メソッドが結果値を返す場合は、メソッド呼び出し元に渡す値（つまり仕事の成果）をメソッド本体の最終行に記述するだけでOKです。（あるいは、予約語「return」を用いて明示的に結果値を指定することも可能です）</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample17]メソッド(Sample17.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample17{</span></p>
<p><span> 　def　main(args:Array[String]):Unit={</span></p>
<p><span>　val　a=5</span></p>
<p><span>　val　b=8</span></p>
<p><span>　println(a+"+"+b+"="+Sample17.sum(a,b))</span><span>Sample17.greet()</span></p>
<p>}</p>
<p><span> 　def　sum(x:Int,y:Int):Int={</span></p>
<p><span>　x+y</span></p>
<p>}</p>
<p><span> 　def　greet()=println("Good　morning!")</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample17]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>5+8=13</span></p>
<p><span>Good　morning!</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はmainメソッド以外に、２つのメソッドを定義して呼び出しています。メソッドを定義することで処理の使い回しができ、同じプログラムを何度も記述しなくて済むようになります。（つまり再利用性を向上させることができます）</span></p>
<p><span>greetメソッドには引数がないため、メソッド定義時に空っぽの丸かっこを記述しています。（greetメソッドの引数の丸かっこは省略可能ですが、通常副作用のあるメソッドに関しては丸かっこを省略しないという約束事があります）</span></p>
<p><span>また、メソッドの中身が１行で記述できる場合は、ブロックも省略可能です。（ただし、ブロックを省略する際は、等号が必須になります）</span></p>
<p><span>mainメソッドの中で、「Sample17.sum(a,b)」や「Sample17.greet()」の形でメソッドを呼び出しています。メソッドは、「誰かが持つ機能」なので、誰が持つかを記述してあげないといけません。今回の例では、Sample17シングルトンオブジェクトが持つsumメソッドとgreetメソッドなので、「Sample17.」の後にメソッドの呼び出しを記述しています。ただし、同じシングルトンオブジェクトで定義されているメソッドの呼び出しの場合は「Sample17.」の記述は省略可能です。</span></p>
<p><span>また、今回のmainメソッドは、結果型にUnit型を明示し、そのあとに等号（=）を記述しています。このように正式な記述をしても、もちろん正常に動作します。</span></p>
<p>
<div id="calibre_link-282"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-78">
<div>
<h2 id="calibre_link-283"><b><a id="calibre_link-117"><b><span><b>2-07　メソッドの演習問題</b></span></b></a></b></h2><p><span>次の指示に従って、Practice04シングルトンオブジェクトを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>Practice04シングルトンオブジェクトのmainメソッドはすでに完成しています。（変更しないでください）</span></p>
<p><span>３つの引数（Int型）の中で、一番小さいものの値を結果値として返すminメソッドを定義してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice04]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>整数88,79,96の中で最小の値は79です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice04]メソッドの演習問題(Practice04.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice04{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=88</span></p>
<p><span>　val　y=79</span></p>
<p><span>　val　z=96</span></p>
<p><span>　print("整数"+x+","+y+","+z+"の中で最小の値は")</span><span>println(min(x,y,z)+"です")</span></p>
<p>}</p>
<p><span> 　//ここにminメソッドを定義してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-284"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-6">
<div>
<h2 id="calibre_link-285"><b><a id="calibre_link-118"><b><span><b>2-08　オーバーロード</b></span></b></a></b></h2><p><span>「オーバーロード」とは、同じシングルトンオブジェクトやクラス（後述）、トレイト（後述）に、同じ名前のメソッドを複数定義することができることをいいます。</span></p>
<p><span>少し不思議な話に思えますが、その代わりにある条件が必要になります。メソッド名は同じで構わないのですが、メソッドのシグネチャ、つまり「引数の数と型の組み合わせ」が異なるものでないといけないのです。</span></p>
<p><span>オーバーロードされたメソッドが呼び出される際は、呼び出し側の引数のパターンに応じて、実行されるメソッドがただひとつに決定されるわけです。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample18]オーバーロード(Sample18.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample18{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　a=3</span></p>
<p><span>　val　b=5</span></p>
<p><span>　val　c=1.2</span></p>
<p><span>　sum(a,b)</span></p>
<p><span>　sum(b,c)</span></p>
<p><span>　sum(c,a)</span></p>
<p>}</p>
<p><span> 　def　sum(x:Int,y:Int){</span></p>
<p><span>　println("Int+Int=&gt;"+(x+y))</span></p>
<p>}</p>
<p><span> 　def　sum(x:Int,y:Double){</span></p>
<p><span>　println("Int+Double=&gt;"+(x+y))</span></p>
<p>}</p>
<p><span> 　def　sum(x:Double,y:Int){</span></p>
<p><span>　println("Double+Int=&gt;"+(x+y))</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample18]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>Int+Int=&gt;8</span></p>
<p><span>Int+Double=&gt;6.2</span></p>
<p><span>Double+Int=&gt;4.2</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>sumメソッドは３パターンにオーバーロードされています。メソッド呼び出し側の引数のパターンに応じて、オーバーロードされた異なるメソッドが呼び出されているのが一目瞭然です。</span></p>
<p>
<div id="calibre_link-286"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-216">
<div>
<h2 id="calibre_link-287"><b><a id="calibre_link-119"><b><span><b>2-08　オーバーロードの演習問題</b></span></b></a></b></h2><p><span>次の指示に従って、Practice05シングルトンオブジェクトを完成させてください。</span></p>
<p><span>Practice05シングルトンオブジェクトのmainメソッドはすでに完成しています。（変更しないでください）</span></p>
<p><span>さまざまな図形の面積を算出するgetAreaメソッドを作成しましょう。</span></p>
<p>&nbsp;</p>
<p><span>１．引数に半径（double型）を受け取り、円の面積を算出するgetAreaメソッド（戻り値double型）を作成してください。なお、円周率は3.14とします。</span></p>
<p>&nbsp;</p>
<p><span>２．第一引数に底辺（double型）、第二引数に高さ（double型）の２つの引数を受け取り、三角形の面積を算出するgetAreaメソッド（戻り値double型）を作成してください。</span></p>
<p>&nbsp;</p>
<p><span>３．第一引数に上底（double型）、第二引数に下底（double型）、第三引数に高さ（double型）の３つの引数を受け取り、台形の面積を算出するgetAreaメソッド（戻り値double型）を作成してください。尚、台形の面積は「(上底＋下底)×高さ÷２」で算出できます。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice05]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>半径5.0の円の面積は78.5</span></p>
<p><span>底辺9.0、高さ5.0の三角形の面積は22.5</span></p>
<p><span>上底8.0、下底10.0、高さ5.0の台形の面積は45.0</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice05]オーバーロードの演習問題(Practice05.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice05{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　//円の半径変数の宣言</span></p>
<p><span>　val　r=5.0</span></p>
<p><span>　//円の面積を出力</span></p>
<p><span>　println("半径"+r+"の円の面積は"+getArea(r))</span><span>//底辺と高さ変数の宣言</span></p>
<p><span>　val　base=9.0</span></p>
<p><span>　val　height=5.0</span></p>
<p><span>　//三角形の面積を出力</span></p>
<p><span>　println("底辺"+base+"、高さ"+height+</span></p>
<p><span>　"の三角形の面積は"+getArea(base,height))</span></p>
<p><span>　//上底と下底変数の宣言</span></p>
<p><span>　val　upperBase=8.0</span></p>
<p><span>　val　lowerBase=10.0</span></p>
<p><span>　//台形の面積を出力</span></p>
<p><span>　println("上底"+upperBase+"、下底"+lowerBase+</span></p>
<p><span>　"、高さ"+height+"の台形の面積は"+</span></p>
<p><span>　getArea(upperBase,lowerBase,height))</span></p>
<p>}</p><p><span> 　//ここに３つのgetAreaメソッドを定義してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-288"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-64">
<div>
<h1 id="calibre_link-289"><b><a id="calibre_link-120"><b><span><b><u>第３章　いよいよオブジェクト指向</u></b></span></b></a></b></h1><p>
<div id="calibre_link-290"></div>
</p>
 
   


</div>
</div>
<div id="calibre_link-20">
<div>
<p>
<br id="calibre_link-291" /></p>
 
   


<h3><b><a id="calibre_link-121"><b><span><b>3-01　クラス</b></span></b></a></b></h3><p><span>「クラス」とはインスタンスを生成するための設計図のことです。「インスタンス」とは、クラスを元にして作られた、データ（フィールド）と機能（メソッド）を併せ持った実体のことです。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>注：クラスを元に作られた実体のことを「オブジェクト」と表現することもありますが、本書では「オブジェクト」は予約語「object」を用いて生成されたシングルトンオブジェクトを表すことにして、クラスを元に作られた実体は「インスタンス」という言葉で統一したいと思います。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>たとえば、スマートフォンを考えてみましょう。スマートフォンインスタンスは「電話番号」や「画像」、「音楽」「動画」といったさまざまなデータを持ち、また「通話する」「写真を撮る」「ゲームをする」といったさまざまな機能を併せ持っています。</span></p>
<p><span>この「１つの実体がデータと機能を併せ持つ感じ」のことをオブジェクト指向の世界では「カプセル化」と呼んでいます。</span></p>
<p><span>「クラス」という設計図がひとつあれば、それを用いてインスタンスをいくつでも（実際にはメモリの許す限り）生成することができます。</span></p>
<p>&nbsp;</p>
<p><span>では、基本的なクラスの定義方法を見てみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[基本的なクラスの定義方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　クラス名{</span></p>
<p><span> 　var　フィールド名=初期値(値が可変なフィールドの場合)</span></p>
<p><span> 　val　フィールド名=初期値(値が不変なフィールドの場合)</span></p>
<p><span> 　def　メソッド名(引数):結果型={</span></p>
<p><span> 　 　メソッドの処理内容</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>基本的なクラスの定義では、データを表現する「フィールド」と、機能を表現する「メソッド」を定義します。これらをまとめて「メンバ」と呼びます。</span></p>
<p>&nbsp;</p>
<p><span>クラスは概念を一般化したもので、それだけでは意味を持ちません。基本的には他のインスタンスやオブジェクトなどから「インスタンス化」されることで初めて意味を持ちます。</span></p>
<p><span>「インスタンス化」とは、クラスという設計図を元に、予約語「new」を用いてインスタンス（実体）を生成することです。</span></p>
<p>&nbsp;</p>
<p><span><b>[クラスのインスタンス化]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>val　参照変数名=new　クラス名</span></p>
<p><span>または</span></p>
<p><span>var　参照変数名=new　クラス名</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>インスタンスはメモリ上の居場所を表す値〒（いわゆるメモリアドレス）を持っており、代入演算子の「=」を通して右辺から左辺の参照変数に〒が代入されます。</span></p>
<p><span>よって、参照変数が持つ値は、インスタンスそのものではなく、インスタンスのいる居場所を表す値〒です。</span></p>
<p>&nbsp;</p>
<p><span>よって、参照変数にドットをつけることで、そのインスタンスの居場所である〒をたどってインスタンスそのものにアクセスでき、フィールドやメソッドを使用することができます。</span></p>
<p>&nbsp;</p>
<p><span><b>[フィールドやメソッドへのアクセス]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>参照変数.フィールド</span></p>
<p><span>参照変数.メソッド(引数)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample19]クラスの基本(Sample19.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample19{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person</span></p>
<p><span>　val　p2=new　Person</span></p>
<p><span>　p1.name="山田"</span></p>
<p><span>　p1.age=24</span></p>
<p><span>　p2.name="田中"</span></p>
<p><span>　p2.age=38</span></p>
<p><span>　p1.introduce()</span></p>
<p><span>　p2.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person{</span></p>
<p><span> 　var　name=""</span></p>
<p><span> 　var　age=0</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("私は"+name+"、年齢は"+age+"歳です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample19]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>私は山田、年齢は24歳です</span></p>
<p><span>私は田中、年齢は38歳です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>Personクラスは人を表現するクラスで、「人は名前と年齢を持つ」という前提をvarフィールドを用いて定義しています。</span></p>
<p><span>クラスのフィールドにはローカル変数と同じくvalやvarを付加する必要があります。また、必ず初期値を設定する必要があります。（後述する抽象フィールド以外）</span></p>
<p><span>そして、「人は自分の名前と年齢の値を用いて自己紹介することができる」という前提を、introduceメソッドを定義することで表現しています。</span></p>
<p><span>introduceメソッドは引数なし・結果値なしのため、メソッドの後ろに記述する結果型の指定や等号は省略することができます。</span></p>
<p><span>今回は予約語「new」を用いて、「山田さん」「田中さん」という２人のPersonインスタンスを生成しています。</span></p>
<p><span>Personクラスには名前を表現するnameインスタンスフィールドと、年齢を表現するageインスタンスフィールドが定義されています。</span></p>
<p><span>そして、クラスがインスタンス化されると、インスタンスごとにnameとageの情報を持つことになります。「山田さん」と「田中さん」の名前と年齢が異なっているのは、それぞれが別のインスタンスだからです。</span></p>
<p><span>mainメソッドの最後の「p1.introduce()」と「p2.introduce()」の出力内容が異なる点も重要です。introduceメソッドはインスタンスごとに存在するメソッドですから、２人の人の自己紹介の内容が違っているのは当然のことと言えます。</span></p>
<p><span>今回のPersonクラスの参照変数とインスタンスの関係性を図にすると、次のように表現できます。</span></p>
<p>&nbsp;</p>
<p><img src="images/00002.jpeg" alt="" /></p>
<p>&nbsp;</p>
<p><span>Person型変数のp1とp2が値として持っている「〒123」や「〒456」はあくまでイメージです。Scalaは100%オブジェクト指向言語のため、すべての値はクラスのインスタンスであり、すべての変数はインスタンスの場所を指すための〒しか持っていない点に注意してください。</span></p>
<p>
<div id="calibre_link-292"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-69">
<div>
<h2 id="calibre_link-293"><b><a id="calibre_link-122"><b><span><b>3-01　クラスの基本の演習問題</b></span></b></a></b></h2><p><span>Practice06シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、本を表現するBookクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Bookクラス]</span></p>
<p><span>１．次の３つのvarフィールドを定義してください。</span></p>
<p>&nbsp;</p>
<p><span>本のタイトルを表現するtitleフィールド（String型、初期値　""）</span></p>
<p><span>本の著者を表現するauthorフィールド（String型、初期値　""）</span></p>
<p><span>本の価格を表現するpriceフィールド（Int型、初期値　0）</span></p>
<p>&nbsp;</p>
<p><span>２．本の情報をString型で返すgetInfoメソッドを定義してください。出力内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice06]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>タイトル：楽しいScala</span></p>
<p><span>著者：山田太郎</span></p>
<p><span>価格：2980円</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice06]クラスの基本の演習問題(Practice06.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice06{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　book=new　Book</span></p>
<p><span>　book.title="楽しいScala"</span></p>
<p><span>　book.author="山田太郎"</span></p>
<p><span>　book.price=2980</span></p>
<p><span>　println(book.getInfo)</span></p>
<p>}</p>
<p>}</p>
<p><span>//ここにBookクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-294"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-202">
<div>
<h2 id="calibre_link-295"><b><a id="calibre_link-123"><b><span><b>3-02　基本コンストラクタ</b></span></b></a></b></h2><p><span>先ほどの「Sample19」のPersonクラスに関して、次のような疑問を持たれた方もいらっしゃると思います。</span></p>
<p><span>「ある人を表現するPersonクラスのインスタンスを生成した瞬間は、名前はからっぽで、年齢は0歳。その後に実際の名前と年齢を設定しているけど、これって同時にできないのかな？」</span></p>
<p><span>結論からいいますと「可能」です。実は、インスタンスを生成するときに「new　クラス名」と記述しますが、そのクラス名の後ろに丸かっこを書いて、メソッドのように値を渡すことが可能です。</span></p>
<p><span>それを行うためには、クラス定義でクラス名の後ろに丸かっこを書いて、引数リストを記述します。これを「基本コンストラクタ」と呼び、その引数のことを「クラスパラメーター」と呼びます。</span></p>
<p><span>基本コンストラクタの中身も記述可能です。クラスのブロックの中、つまりフィールドやメソッドと同じレベルでプログラムを記述すれば、インスタンス化されたときにそのプログラムを実行することができます。</span></p>
<p><span>さきほどのサンプルを、基本コンストラクタを用いて書き直してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample20]基本コンストラクタ(Sample20.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample20{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person("山田",24)</span></p>
<p><span>　val　p2=new　Person("田中",38)</span></p>
<p><span>　p1.introduce()</span></p>
<p><span>　p2.introduce()</span></p>
<p><span>　//println("フィールドにアクセス："+p1.name)</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(name:String,age:Int){</span></p>
<p><span> 　println("インスタンス化　名前:"+name+"　年齢:"+age)</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("私は"+name+"、年齢は"+age+"歳です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample20]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>インスタンス化　名前:山田　年齢:24</span></p>
<p><span>インスタンス化　名前:田中　年齢:38</span></p>
<p><span>私は山田、年齢は24歳です</span></p>
<p><span>私は田中、年齢は38歳です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>クラスパラメーターはフィールドとは異なるので注意が必要です。クラスパラメーターのスコープ（有効範囲）は、クラスのブロック全体に及びます。なので、introduceメソッドの中でもクラスパラメーターの値を使用できます。</span></p>
<p><span>しかし、mainメソッドの最終行のコメントをはずすとコンパイルエラーになります。何故なら、クラスパラメーターのnameはインスタンスフィールドではないため、「参照変数.フィールド」の形でアクセスできないからです。</span></p>
<p><span>そこで、基本コンストラクタとフィールドの両方を定義することが可能です。しかも、クラスパラメーターの値をフィールドに設定することも可能なので、valフィールドを定義することができます。</span></p>
<p><span>さらに、先ほどの「Sample20」を書き直してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample21]基本コンストラクタとフィールド(Sample21.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample21{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person("山田",24)</span></p>
<p><span>　val　p2=new　Person("田中",38)</span></p>
<p><span>　p1.introduce()</span></p>
<p><span>　p2.introduce()</span></p>
<p><span>　println("フィールドにアクセス："+p1.name)</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(n:String,a:Int){</span></p>
<p><span> 　val　name=n</span></p>
<p><span> 　var　age=a</span></p>
<p><span> 　println("インスタンス化　名前:"+name+"　年齢:"+age)</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("私は"+name+"、年齢は"+age+"歳です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample21]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>インスタンス化　名前:山田　年齢:24</span></p>
<p><span>インスタンス化　名前:田中　年齢:38</span></p>
<p><span>私は山田、年齢は24歳です</span></p>
<p><span>私は田中、年齢は38歳です</span></p>
<p><span>フィールドにアクセス：山田</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はクラスパラメーターの値をインスタンスフィールドに渡しています。クラスパラメーターとインスタンスフィールドの名前は重複してはいけないので、クラスパラメーター名をnとaに変更しています。</span></p>
<p><span>ここでは、人の名前は変わらないという前提でnameをvalインスタンスフィールドにし、年齢は変化していくものなのでageをvarインスタンスフィールドにしました。つまり、名前は不変、年齢は可変というわけです。</span></p>
<p><span>Personクラスの２つのインスタンスフィールド宣言の下に記述されている「println("インスタンス化　名前:"+name+"　年齢:"+age)」は、基本コンストラクタの中身になります。よって、インスタンス化されるたびに呼び出されているのが実行結果から確認できます。</span></p>
<p>
<div id="calibre_link-296"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-38">
<div>
<h2 id="calibre_link-297"><b><a id="calibre_link-124"><b><span><b>3-02　基本コンストラクタの演習問題</b></span></b></a></b></h2><p><span>Practice07シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、Tシャツを表現するTShirtクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[TShirtクラス]</span></p>
<p><span>１．次の３つのインスタンスフィールドを定義してください。初期値には基本コンストラクタで受け取った値（クラスパラメーター）をそのままセットしてください。</span></p>
<p>&nbsp;</p>
<p><span>Tシャツの色を表現するvalフィールドcolor（String型）</span></p>
<p><span>Tシャツのサイズを表現するvalフィールドsize（String型）</span></p>
<p><span>Tシャツの価格を表現するvarフィールドprice（Int型）</span></p>
<p>&nbsp;</p>
<p><span>２．Tシャツの価格を変更するchangePriceメソッドを定義してください。結果値はなしで、引数に変更後の価格（Int型）の値を受け取ってください。</span></p>
<p>&nbsp;</p>
<p><span>３．Tシャツの情報を表示するinformationメソッドを定義してください。引数および結果値はなしで、表示内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice07]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>本日セールのTシャツ</span></p>
<p><span>色：黒　サイズ：L　価格：2980円</span></p>
<p><span>プライズダウン後のTシャツ</span></p>
<p><span>色：黒　サイズ：L　価格：1480円</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice07]基本コンストラクタの演習問題(Practice07.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice07{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　tshirt=new　TShirt("黒","L",2980)</span><span>println("本日セールのTシャツ")</span></p>
<p><span>　tshirt.information()</span></p>
<p><span>　tshirt.changePrice(1480)</span></p>
<p><span>　println("プライズダウン後のTシャツ")</span></p>
<p><span>　tshirt.information()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにTShirtクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-298"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-30">
<div>
<h2 id="calibre_link-299"><b><a id="calibre_link-125"><b><span><b>3-03　アクセス修飾子　private</b></span></b></a></b></h2><p><span>先ほどの「Sample21」のPersonクラスには大きな欠点があります。</span></p>
<p><span>まずひとつ覚えていていただきたいことに、通常のフィールドやメソッドは「公開」されているということが挙げられます。つまり、あるインスタンスのフィールドやメソッドは、他のオブジェクトやインスタンスなど、どこからでもアクセス可能であるということです。</span></p>
<p><span>先ほどの「Sample21」を次のように書き換えてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample22]欠点のあるクラス(Sample22.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample22{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p=new　Person("山田",24)</span></p>
<p><span>　p.introduce()</span></p>
<p><span>　//年齢を強引に変更</span></p>
<p><span>　p.age　=　300</span></p>
<p><span>　p.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(n:String,a:Int){</span></p>
<p><span> 　val　name=n</span></p>
<p><span> 　var　age=a</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("私は"+name+"、年齢は"+age+"歳です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample22]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>私は山田、年齢は24歳です</span></p>
<p><span>私は山田、年齢は300歳です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>Personクラスが持つ名前nameフィールドや年齢ageフィールドには、他のオブジェクトやクラスから簡単にアクセスできます。nameフィールドはvalで定義していますから、外部から値を変更することはできません。しかし、ageフィールドはvarで定義しているため、外部から値を簡単に変更できてしまいます。今回は、年齢に有り得ない「300」を設定してしまっています。</span></p>
<p><span>クラスのメンバであるフィールドやメソッドは、外部からアクセスできないように設定することが可能です。そのためには、フィールドやメソッドに「アクセス修飾子」を付加します。</span></p>
<p><span>予約語「private」をフィールドやメソッドの先頭に付加すると、そのメンバは同じクラス内からしかアクセスできなくなり、外部からは一切アクセスできなくなります。</span></p>
<p><span>「プライベート」という言葉は日常でも良く使われますね。プライベートな情報は他人に知られることがないのと同様なわけです。</span></p>
<p><span>先ほどの良くないプログラム[Sample22]を改良してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample23]アクセス修飾子private(Sample23.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample23{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p=new　Person("山田",24)</span></p>
<p><span>　p.introduce()</span></p>
<p><span>　//p.age=300</span></p>
<p><span>　p.birthday()</span></p>
<p><span>　p.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(n:String,a:Int){</span></p>
<p><span> 　val　name=n</span></p>
<p><span> 　private　var　age=a</span></p>
<p><span> 　def　birthday(){</span></p>
<p><span>　println(name+"さんが誕生日を迎えました")</span></p>
<p><span>　age+=1</span></p>
<p>}</p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("私は"+name+"、年齢は"+age+"歳です")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample23]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>私は山田、年齢は24歳です</span></p>
<p><span>山田さんが誕生日を迎えました</span></p>
<p><span>私は山田、年齢は25歳です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はPersonクラスの年齢ageフィールドにアクセス修飾子privateを付加しました。なので、mainメソッドで記述している「p.age=300」というプログラムは、コメントをはずすとコンパイルできなくなります。年齢ageフィールドは「非公開」に設定されたわけです。</span></p>
<p><span>人の年齢は自由に値を変更できるものではありませんが、誕生日を迎えればインクリメントされます。それを表現するために、今回は誕生日birthdayメソッドを定義してみました。誕生日birthdayメソッドの中からは、年齢ageフィールドにアクセスできる点に注意しましょう。privateなメンバであっても、同じクラス内からは自由にアクセスできます。birthdayメソッド呼び出し後は、年齢が１加算されていることが実行結果から確認できます。</span></p>
<p>
<div id="calibre_link-300"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-54">
<div>
<h2 id="calibre_link-301"><b><a id="calibre_link-126"><b><span><b>3-03　アクセス修飾子　privateの演習問題</b></span></b></a></b></h2><p><span>Practice08シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、日本人を表現するJapaneseクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Japaneseクラス]</span></p>
<p><span>１．次の４つのprivateなvalインスタンスフィールドを定義してください。初期値には基本コンストラクタで受け取った値（クラスパラメーター）をそのままセットしてください。</span></p>
<p>&nbsp;</p>
<p><span>氏名を表現するフィールドname（String型）</span></p>
<p><span>生年月日を表現するフィールドbirthday（String型）</span></p>
<p><span>性別を表現するフィールドgender（Boolean型　true:女性　false:男性）</span></p>
<p><span>マイナンバーを表現するフィールドmynumber（Long型）</span></p>
<p>&nbsp;</p>
<p><span>２．個人情報を出力するshowPrivateDataメソッドを定義してください。引数および結果値はなしで、表示内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice08]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>--　山田一郎の個人情報　--</span></p>
<p><span>生年月日：2001-04-01</span></p>
<p><span>性別：男性</span></p>
<p><span>マイナンバー：123456789012</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice08]アクセス修飾子の演習問題(Practice08.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice08{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　jp=new　Japanese("山田一郎","2001-04-01",</span><span>false,123456789012L)</span></p>
<p><span>　//外部からはアクセスできない</span></p>
<p><span>　//println(jp.mynumber)　</span></p>
<p><span>　jp.showPrivateData()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにJapaneseクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-302"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-29">
<div>
<h2 id="calibre_link-303"><b><a id="calibre_link-127"><b><span><b>3-04　補助コンストラクタ</b></span></b></a></b></h2><p><span>「コンストラクタ」とは、インスタンスが生成されるときに１度だけ呼び出される特殊なメソッドのことです。よって、メソッドと同じくオーバーロードすることが可能です。</span></p>
<p><span>基本コンストラクタ以外のコンストラクタは「補助コンストラクタ」と呼ばれます。</span></p>
<p><span>補助コンストラクタの定義方法は以下の通りです。</span></p>
<p>&nbsp;</p>
<p><span><b>[補助コンストラクタの定義]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　クラス名(クラスパラメーター){</span></p>
<p><span>　//補助コンストラクタ</span></p>
<p><span> 　def　this(引数リスト){</span></p>
<p><span> 　 　//同じクラスの別コンストラクタ呼び出し</span></p>
<p><span> 　 　this(引数リスト)　</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>補助コンストラクタは、処理の最初に必ず同じクラスの他のコンストラクタを呼び出さないといけません。他のコンストラクタの呼び出しは「this(引数リスト)」と記述します。つまり、最終的には必ず基本コンストラクタの呼び出しにたどり着くように設計されています。この規則を守らないとコンパイルエラーとなります。</span></p>
<p><span>それでは、次のプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample24]補助コンストラクタ(Sample24.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample24{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person("山田",24,"東京","公務員")</span><span>val　p2=new　Person("田中",38,"千葉")</span><span>val　p3=new　Person("中西",27)</span></p>
<p><span>　p1.introduce()</span></p>
<p><span>　p2.introduce()</span></p>
<p><span>　p3.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(n:String,a:Int,g:String,j:String){</span></p>
<p><span> 　val　name=n</span></p>
<p><span> 　var　age=a</span></p>
<p><span> 　val　graduate=g</span></p>
<p><span> 　var　job=j</span></p>
<p><span> 　//補助コンストラクタ（引数３つ）</span></p>
<p><span> 　def　this(n:String,a:Int,g:String){</span></p>
<p><span>　this(n,a,g,"無職")</span></p>
<p>}</p>
<p><span> 　//補助コンストラクタ（引数２つ）</span></p>
<p><span> 　def　this(n:　String,a:Int){</span></p>
<p><span>　this(n,a,"不明")</span></p>
<p>}</p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("名前："+name+"　年齢："+age+"歳　"+</span></p>
<p><span>　"出身："+graduate+"　職業："+job)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample24]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>名前：山田　年齢：24歳　出身：東京　職業：公務員</span></p>
<p><span>名前：田中　年齢：38歳　出身：千葉　職業：無職</span></p>
<p><span>名前：中西　年齢：27歳　出身：不明　職業：無職</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のPersonクラスは、出身を表すgraduateインスタンスフィールドと、職業を表すjobインスタンスフィールドを追加しています。（出身は不変フィールド、職業は可変フィールドにしました）</span></p>
<p><span>４つのインスタンスフィールドを持つクラスなので、基本コンストラクタの引数を４つにしました。</span></p>
<p><span>その他に、引数が３つまたは２つの補助コンストラクタを定義しました。</span></p>
<p><span>コンストラクタに職業のデータを与えない場合は「無職」に、出身のデータを与えない場合は「不明」に設定されるように定義しています。名前と年齢は、インスタンス化する際に必ず分かっているものとしています。</span></p>
<p><span>補助コンストラクタの１行目は、必ず同じクラスの他のコンストラクタを呼び出さないといけません。引数２つの補助コンストラクタの先頭では、出身を「不明」として引数３つの補助コンストラクタを呼び出しています。引数３つの補助コンストラクタの先頭では、職業を「無職」として引数４つの基本コンストラクタを呼び出しています。このように、最終的には基本コンストラクタにたどりつくように記述します。</span></p>
<p>
<div id="calibre_link-304"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-212">
<div>
<h2 id="calibre_link-305"><b><a id="calibre_link-128"><b><span><b>3-04　補助コンストラクタの演習問題</b></span></b></a></b></h2><p><span>Practice09シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、タレントを表現するTalentクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Talentクラス]</span></p>
<p><span>１．次の３つのprivateなインスタンスフィールドを定義してください。初期値には基本コンストラクタで受け取った値（クラスパラメーター）をそのままセットしてください。</span></p>
<p>&nbsp;</p>
<p><span> 　・芸名を表現するvalフィールドstageName(String型)</span></p>
<p><span> 　・本名を表現するvalフィールドrealName(String型)</span></p>
<p><span> 　・年齢を表現するvarフィールドage(Int型)</span></p>
<p>&nbsp;</p>
<p><span>２．次の２つの補助コンストラクタをオーバーロードして定義します。</span></p>
<p>&nbsp;</p>
<p><span> 　・引数に芸名と本名を受け取る補助コンストラクタ。年齢を「-1」として基本コンストラクタを呼び出します。</span></p>
<p><span> 　・引数に芸名と年齢を受け取る補助コンストラクタ。本名を「非公開」として基本コンストラクタを呼び出します。</span></p>
<p>&nbsp;</p>
<p><span>３．プロフィールを出力するprifileメソッドを定義してください。引数および結果値はなしで、表示内容は下記実行結果を参考にしてください。ポイントは、年齢の値がマイナスの場合は「非公開」と表示するところです。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice09]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>芸名：石原真希　本名：非公開　年齢：22歳</span></p>
<p><span>芸名：本上ゆきえ　本名：本田良子　年齢：非公開</span></p>
<p><span>芸名：市川瑠璃子　本名：山田美紀　年齢：24歳</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice09]補助コンストラクタの演習問題(Practice09.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice09{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　t1=new　Talent("石原真希",22)</span></p>
<p><span>　val　t2=new　Talent("本上ゆきえ","本田良子")</span><span>val　t3=new　Talent("市川瑠璃子","山田美紀",24)</span><span>t1.profile()</span></p>
<p><span>　t2.profile()</span></p>
<p><span>　t3.profile()</span></p>
<p>}</p>
<p>}</p>
<p><span>//ここにTalentクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-306"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-13">
<div>
<h2 id="calibre_link-307"><b><a id="calibre_link-129"><b><span><b>3-05　パラメーターフィールド</b></span></b></a></b></h2><p><span>先ほどの[Sample24]のPersonクラスをもう一度よく見てください。名前を表現するクラスパラメーターnの値を、名前を表現するインスタンスフィールドnameに代入しています。年齢、出身、職業も同様のことを行っています。この部分、少し無駄に感じられませんか？</span></p>
<p><span>その解決策として、Scalaではクラスパラメーターとフィールドの定義を結合することができます。それを「パラメーターフィールド」と言います。</span></p>
<p><span>パラメーターフィールドの定義方法はとっても簡単で、クラスパラメーターにvarまたはvalを付加するだけです。</span></p>
<p><span>では、先ほどのサンプルプログラム「Sample24」を、パラメーターフィールドを用いて書き直してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample25]パラメーターフィールド(Sample25.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample25{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person("山田",24,"東京","公務員")</span><span>val　p2=new　Person("田中",38,"千葉")</span><span>val　p3=new　Person("中西",27)</span></p>
<p><span>　p1.introduce()</span></p>
<p><span>　p2.introduce()</span></p>
<p><span>　p3.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Person(val　name:String,var　age:Int,</span></p>
<p><span>　val　graduate:String,var　job:String){</span></p>
<p><span> 　//補助コンストラクタ（引数３つ）</span></p>
<p><span> 　def　this(name:String,age:Int,graduate:String){</span></p>
<p><span>　this(name,age,graduate,"無職")</span></p>
<p>}</p>
<p><span> 　//補助コンストラクタ（引数２つ）</span></p>
<p><span> 　def　this(name:String,age:Int){</span></p>
<p><span>　this(name,age,"不明")</span></p>
<p>}</p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("名前："+name+"　年齢："+age+"歳　"+</span></p>
<p><span>　"出身："+graduate+"　職業："+job)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample25]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>名前：山田　年齢：24歳　出身：東京　職業：公務員</span></p>
<p><span>名前：田中　年齢：38歳　出身：千葉　職業：無職</span></p>
<p><span>名前：中西　年齢：27歳　出身：不明　職業：無職</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>先ほどのサンプルプログラム[Sample24]と同じ結果が得られました。</span></p>
<p><span>このように、パラメーターフィールドを用いることで、プログラムが簡潔になりすっきり見やすくなります。</span></p>
<p><span>パラメーターフィールドには、通常のフィールドと同様にアクセス修飾子「private」や予約語「override」（後述）などを付加することができます。</span></p>
<p>
<div id="calibre_link-308"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-71">
<div>
<h2 id="calibre_link-309"><b><a id="calibre_link-130"><b><span><b>3-05　パラメーターフィールドの演習問題</b></span></b></a></b></h2><p><span>Practice10シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、車を表現するCarクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Carクラス]</span></p>
<p><span>１．基本コンストラクタで、次のprivateなパラメーターフィールドを定義します。</span></p>
<p>&nbsp;</p>
<p><span>車種を表現するvalフィールドmodel(String型)</span></p>
<p><span>ナンバーを表現するvalフィールドnumber(Int型)</span></p>
<p><span>ガソリン量を表現するvarフィールドgasoline(Double型)</span></p>
<p>&nbsp;</p>
<p><span>２．第一引数に車種、第二引数にナンバーを受け取る補助コンストラクタを定義します。ガソリン量の初期値を「5.0」として基本コンストラクタを呼び出します。</span></p>
<p>&nbsp;</p>
<p><span>３．走行を表現するrunインスタンスメソッドを定義します。結果値はなし、引数には走行に必要なガソリン量（Double型）を設定します。もし残ガソリン量が、走行に必要なガソリン量よりも多い場合は「ナンバー○○の△△はガソリン□リットル分走行しました」と出力し、残ガソリン量を走行ガソリン量分減らします。もし残ガソリン量が、走行ガソリン量に満たない場合は、「ナンバー○○の△△はガソリン不足のため走行できません」と出力します。</span></p>
<p>&nbsp;</p>
<p><span>４．車の情報を表示するshowInfoインスタンスメソッドを定義します。引数と結果値はなしで、表示内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice10]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>ナンバー1234のファットはガソリン7.0リットル分走行しました</span></p>
<p><span>ナンバー6789のトントはガソリン不足のため走行できません</span></p>
<p><span>車種：ファット　ナンバー：1234　ガソリン：3.0リットル</span></p>
<p><span>車種：トント　ナンバー：6789　ガソリン：5.0リットル</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice10]パラメーターフィールドの演習問題(Practice10.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice10{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　car1=new　Car("ファット",1234,10.0);</span></p>
<p><span>　val　car2=new　Car("トント",6789);</span></p>
<p><span>　car1.run(7.0);</span></p>
<p><span>　car2.run(7.0);</span></p>
<p><span>　car1.showInfo();</span></p>
<p><span>　car2.showInfo();</span></p>
<p>}</p>
<p>}</p>
<p><span>//ここにCarクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-310"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-79">
<div>
<h2 id="calibre_link-311"><b><a id="calibre_link-131"><b><span><b>3-06　自己参照のthis</b></span></b></a></b></h2><p><span>先ほどの[Sample25]のPersonクラスをもう一度よく見てください。</span></p>
<p><span>パラメーターフィールドに「name」や「age」がありますが、補助コンストラクタの引数にも「name」と「age」があります。</span></p>
<p><span>クラスパラメーターとインスタンスフィールドの名前は重複してはいけないのですが、インスタンスフィールド（またはパラメーターフィールド）とメソッド（または補助コンストラクタ）の引数名は重複しても構わないのです。</span></p>
<p><span>では、あるメソッドで同じ名前のフィールドと引数を両方用いたい場合はどうすればよいのでしょうか？</span></p>
<p><span>その場合は、フィールドの先頭に「this.」を付加します。今までintroduceメソッド内で「name」や「age」など、インスタンスフィールド名をそのまま記述してきましたが、実は正式な記述は「this.name」や「this.age」なのです。つまり、インスタンスメソッド内でただ「name」と記述しても、自動的に「this.name」とコンパイラが解釈してくれていたわけです。</span></p>
<p><span>「this」は日本語で「この」という意味ですが、たとえば「this.name」と記述すると「このインスタンスが持つnameフィールド」という意味になるわけです。よって、ローカル変数やメソッドの引数にはthisをつけることはできません。</span></p>
<p><span>また、インスタンス内で自分自身のインスタンスそのものを表現したい場合は、参照変数の代わりに「this」とそのまま記述します。</span></p>
<p><span>次のサンプルプログラムで確認してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample26]自己参照のthis(Sample26.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample26{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p1=new　Person("山田",24)</span></p>
<p><span>　val　p2=new　Person("田中",38)</span></p>
<p><span>　val　p3=new　Person("中西",27)</span></p>
<p><span>　println("年上は"+(p1.senior(p2)).name+"さん")</span><span>println("年上は"+(p2.senior(p3)).name+"さん")</span><span>println()</span></p>
<p><span>　println("変数p1は山田さんですか？")</span></p>
<p><span>　if(p1.same("山田")){</span></p>
<p><span>　println("はい、そうです")</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　println("いいえ、違います")</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><span>class　Person(val　name:String,var　age:Int){</span></p>
<p><span> 　def　senior(other:Person):Person={</span></p>
<p><span>　if(this.age&gt;=other.age){</span></p>
<p><span>　this</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　other</span></p>
<p>}　</p>
<p>}</p>
<p><span> 　def　same(name:String):Boolean={</span></p>
<p><span>　this.name==name</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample26]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>年上は田中さん</span></p>
<p><span>年上は田中さん</span></p>
<p>&nbsp;</p>
<p><span>変数p1は山田さんですか？</span></p>
<p><span>はい、そうです</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のPersonクラスは、名前と年齢だけを持つ初期バージョンに戻しました。</span></p>
<p><span>そして、引数に別のPersonインスタンスを受け取り、年上の方のインスタンスを結果値としてかえすseniorメソッドを作成しました（同じ年齢の場合は、自分の方が年上という扱いにしました）。if式で自分の年齢、つまり「this.age」と、引数で渡ってきた他人の年齢、つまり「other.age」を比較し、大きい方のインスタンスそのものを結果値として返しています。自分自身のインスタンスを結果値として返すときに「this」を使用しています。</span></p>
<p><span>また、引数で渡ってきた名前と自分の名前が同じかどうかを調べるsameメソッドも定義しました。この場合、インスタンスフィールドのnameと、引数で渡ってきたnameが同じであるかを調べるので、「this.name==name」となります。</span></p>
<p><span>もし「name==name」と記述してしまうと、同じ引数の値を比較しているので必ずtrueになります。このようなバグには十分気をつけてください。</span></p>
<p>
<div id="calibre_link-312"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-16">
<div>
<h2 id="calibre_link-313"><b><a id="calibre_link-132"><b><span><b>3-06　自己参照のthisの演習問題</b></span></b></a></b></h2><p><span>Practice11シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、四角形を表現するSquareクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Squareクラス]</span></p>
<p><span>１．基本コンストラクタで、次のprivateなvarパラメーターフィールドを定義します。</span></p>
<p>&nbsp;</p>
<p><span>幅を表現するフィールドwidth(Double型)</span></p>
<p><span>高さを表現するフィールドheight(Double型)</span></p>
<p>&nbsp;</p>
<p><span>２．面積を算出するareaインスタンスメソッド（引数なし、結果型Double）を定義します。</span></p>
<p>&nbsp;</p>
<p><span>３．自分自身の面積と引数で渡ってきた別の四角形の面積を比較し、面積の広い方の参照を返すwiderインスタンスメソッド（引数Square型、結果型Square型）を定義します。尚、面積が全く同じ場合は自分自身の参照を返すものとします。</span></p>
<p>&nbsp;</p>
<p><span>４．幅と高さを増加させるaddインスタンスメソッド（第一引数は幅、第二引数は高さ、どちらもDouble型、結果値なし）を定義します。引数で受け取った幅と高さを現在の幅と高さに加算してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice11]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>２つの四角形で広い方の面積は14.0です</span></p>
<p><span>２つの四角形で広い方の面積は15.0です</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice11]自己参照のthisの演習問題(Practice11.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice11{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　square1=new　Square(2.5,4.5)</span></p>
<p><span>　val　square2=new　Square(3.5,4.0)</span></p>
<p><span>　print("２つの四角形で広い方の面積は")</span></p>
<p><span>　print((square1.wider(square2)).area)</span></p>
<p><span>　println("です")</span></p>
<p><span>　square1.add(0.5,0.5)</span></p>
<p><span>　print("２つの四角形で広い方の面積は")</span></p>
<p><span>　print((square1.wider(square2)).area)</span></p>
<p><span>　println("です")</span></p>
<p>}</p>
<p>}</p>
<p><span>//ここにSquareクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-314"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-65">
<div>
<h2 id="calibre_link-315"><b><a id="calibre_link-133"><b><span><b>3-07　コンパニオンクラス・オブジェクト</b></span></b></a></b></h2><p><span>これまで、シングルトンオブジェクトの定義には予約語「object」を使い、クラスの定義には予約語「class」を用いてきました。</span></p>
<p><span>ここで、シングルトンオブジェクトとクラスの違いについて触れてみます。クラスはインスタンスを生成するための設計図です。クラスがあれば、複数のインスタンスを生成できます。それに対して、シングルトンオブジェクトはそれ自体がオブジェクトであり、たった１つしか存在しえないのです（だからこそ「シングルトン」といいます）。なので、シングルトンオブジェクトの名前は、変数の型にすることもできません。つまり、シングルトンオブジェクト名は、シングルトンオブジェクトの居場所〒を指す参照変数のようなものなのです。</span></p>
<p><span>そしてここからが重要なのですが、同一のソースファイルであれば、同じ名前のシングルトンオブジェクトとクラスを定義できます。この状態のシングルトンオブジェクトを「コンパニオンオブジェクト」といい、この状態のクラスを「コンパニオンクラス」といいます。</span></p>
<p><span>コンパニオンオブジェクトとコンパニオンクラスには関連があり、いわば仲間です。なので、それぞれのprivateなフィールド・メソッドにもお互いアクセスできます。</span></p>
<p><span>使い分けとしては、インスタンスごとに必要なフィールド・メソッドはコンパニオンクラスに記述し、すべてのインスタンスで共通なフィールド・メソッドはコンパニオンオブジェクトに記述すると良いでしょう。</span></p>
<p><span>次のサンプルプログラムをコーディングしてみてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample27]コンパニオンクラス・オブジェクト(Sample27.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample27{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　j1=new　Japanese("山田")</span></p>
<p><span>　val　j2=new　Japanese("田中")</span></p>
<p><span>　Japanese.situation()</span></p>
<p><span>　val　j3=new　Japanese("中西")</span></p>
<p><span>　val　j4=new　Japanese("西田")</span></p>
<p><span>　Japanese.situation()</span></p>
<p><span>　j4.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>object　Japanese{</span></p>
<p><span> 　private　var　total=0</span></p>
<p><span> 　val　currency="円"</span></p>
<p><span> 　val　capital="東京"</span></p>
<p><span> 　def　situation(){</span></p>
<p><span>　println("現在の日本人の総人口は"+total+"人です。")</span><span>}</span></p>
<p>}</p>
<p><span>class　Japanese(private　val　name:String){</span></p>
<p><span> 　Japanese.total+=1</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　print("私の名前は"+name+"、")</span></p>
<p><span>　print("日本人なので通貨は"+Japanese.currency)</span></p>
<p><span>　print("、首都は"+Japanese.capital+"です。")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample27]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>現在の日本人の総人口は2人です。</span></p>
<p><span>現在の日本人の総人口は4人です。</span></p>
<p><span>私の名前は西田、日本人なので通貨は円、首都は東京です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は今までのPersonクラスを少しアレンジして、日本人を表現するJapaneseコンパニオンクラスとJapaneseコンパニオンオブジェクトを定義してみました。それぞれの日本人には個別の名前があるので、Japaneseコンパニオンクラスにはnameパラメーターフィールド（private　val）のみを定義しました。</span></p>
<p><span>そしてすべての日本人に共通する通貨と首都の情報は、コンパニオンクラスではなくコンパニオンオブジェクトの方にvalフィールドとして宣言・初期化しました。こうすれば、日本人の共通情報をコンパニオンオブジェクトで一元管理できるわけです。</span></p>
<p><span>あと、現在の日本人が何人存在するかを表現するtotalというprivate　varフィールドを宣言し、とりあえず0で初期化しました。</span></p>
<p><span>ポイントは、Japaneseコンパニオンクラスの中の１行目です。これは、基本コンストラクタの処理を記述しているのですが、インスタンス化されるたびにJapaneseコンパニオンオブジェクトのprivateなvarフィールドをインクリメントしています。このように、たとえコンパニオンオブジェクトのprivateなフィールドでもコンパニオンクラスからアクセスすることが可能です。ただし、「Japanese.」を必ず付加しましょう。そうしないとコンパイルエラーになります。</span></p>
<p>
<div id="calibre_link-316"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-2">
<div>
<h2 id="calibre_link-317"><b><a id="calibre_link-134"><b><span><b>3-07　コンパニオンクラス・オブジェクトの演習問題</b></span></b></a></b></h2><p><span>Practice12シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、ロボットを表現するRobotコンパニオンクラスと、ロボットを一元管理するためのRobotコンパニオンオブジェクトを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Robotコンパニオンオブジェクト]</span></p>
<p><span>１．ロボットの総生産数を管理するためのprivateなvarフィールドtotal(Int型)を定義し、0で初期化します。</span></p>
<p><span>２．現在のロボットの総生産数を取得するためのgetTotalメソッド（引数なし、結果型Int）を定義します。</span></p>
<p>&nbsp;</p>
<p><span>[Robotコンパニオンクラス]</span></p>
<p><span>１．基本コンストラクタで、ロボットの名前を保持するためのprivateなvalパラメーターフィールドnameを定義します。</span></p>
<p><span>２．基本コンストラクタ内で、Robotコンパニオンオブジェクトのtotalフィールドをインクリメントします。</span></p>
<p><span>３．ロボットを一意に管理するためのprivateなvalフィールドid(Int型)を定義し、現在のロボット総生産数で初期化します。</span></p>
<p><span>４．ロボットの情報を表示するintroduceインスタンスメソッドを定義します。引数と結果値はなしで、表示内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice12]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>ロボット総生産数：0</span></p>
<p><span>ロボット総生産数：3</span></p>
<p><span>ID：1　NAME：RX</span></p>
<p><span>ID：2　NAME：SS</span></p>
<p><span>ID：3　NAME：ZK</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice12]コンパニオンクラス・オブジェクトの演習問題(Practice12.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice12{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("ロボット総生産数："+Robot.getTotal)</span></p>
<p><span>　val　r1=new　Robot("RX")</span></p>
<p><span>　val　r2=new　Robot("SS")</span></p>
<p><span>　val　r3=new　Robot("ZK")</span></p>
<p><span>　println("ロボット総生産数："+Robot.getTotal)</span></p>
<p><span>　r1.introduce()</span></p>
<p><span>　r2.introduce()</span></p>
<p><span>　r3.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>//ここにRobotコンパニオンクラス・オブジェクトを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p>
<div id="calibre_link-318"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-49">
<div>
<h1 id="calibre_link-319"><b><a id="calibre_link-135"><b><span><b><u>第４章　もっとオブジェクト指向</u></b></span></b></a></b></h1><p>
<div id="calibre_link-320"></div>
</p>
 
   


</div>
</div>
<div id="calibre_link-209">
<div>
<p>
<br id="calibre_link-321" /></p>
 
   


<h3><b><a id="calibre_link-136"><b><span><b>4-01　継承</b></span></b></a></b></h3><p><span>オブジェクト指向プログラミング言語にとって、最も重要なのが今からお話する「継承」といっても過言ではないでしょう。「継承」とは、簡単にいうとあるクラスを再利用して、新たなクラスを作ることです。このとき、新たに作るクラスは、既存のクラスを継承するわけです。こうすると、既存のクラスの（private以外の）メンバが新しく作成したクラスに引き継がれるのです。もちろん引き継がれたメンバは、新しいクラスで利用できます。</span></p>
<p><span>継承される側のクラスを「スーパークラス」、継承する側のクラスを「サブクラス」と言います。ひとつのクラスに対する直接の「スーパークラス」は、必ず１つだけなので注意しましょう。このことを「単一継承」と言います。ただし「単一継承」さえ守れば、継承関係を階層化できます。つまり、あるクラスのスーパークラスに、さらにスーパークラスがあっても問題ありません。（継承関係を階層化するのは、オブジェクト指向言語では普通のことです）</span></p>
<p><span>ただし、単にスーパークラスのメンバを引き継ぎたいがための継承はご法度とされています。継承にはあるルールが存在します。それはスーパークラスをA、サブクラスをBとした場合、正しい継承関係にある場合は以下の文面が成り立たないといけないのです。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>B　is　a　kind　of　A（BはAの一種である）</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>クラスを継承するときは、必ずこの文面が成り立つかを検証してみてください。では、少し極端なたとえ話をしてみましょう。ここに、鳥を表現するBirdクラスがあります。その中には飛ぶことを表現するflyメソッドが実装されています。次に、今から飛行機を表現するAirPlaneクラスを作ることになりました。とりあえず、飛ぶことができたらそれでいいと言われたので、Birdクラスを継承してAirPlaneクラスを作成しました。</span></p>
<p><span>もちろん、AirPlaneクラスはflyメソッドを受け継いだわけですから、きちんと飛ぶことができます。でも、待ってください。「AirPlane　is　a　kind　of　Bird」、「飛行機は鳥の一種である」は正しい文面でしょうか？そんなわけありませんね。というわけで、この継承はNGとなります。</span></p>
<p><span>基本的な継承の記述方法は次のようになります。</span></p>
<p>&nbsp;</p>
<p><span><b>[基本的な継承の記述方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　サブクラス　extends　スーパークラス</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>サブクラスの定義の右後ろに、予約語「extends」を記述します。そのあとにスーパークラスを１つ指定します。これでサブクラスはスーパークラスの（private以外の）メンバを引き継ぐことができます。</span></p>
<p><span>それでは、まずは継承を利用していないプログラムを見てみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample28]継承する前のサンプル(Sample28.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample28{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog=new　Dog("ジョン",5,false)</span></p>
<p><span>　val　cat=new　Cat("ミー",3,true)</span></p>
<p><span>　dog.introduce()</span></p>
<p><span>　cat.introduce()</span></p>
<p><span>　dog.move()</span></p>
<p><span>　cat.move()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Dog(private　val　name:String,</span></p>
<p><span>　private　var　age:Int,</span></p>
<p><span>　private　val　gender:Boolean){</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("犬の"+name+"は"+</span></p>
<p><span>　(if(gender)"メス"else"オス")+</span></p>
<p><span>　"で"+age+"歳です。")</span></p>
<p>}</p>
<p><span> 　def　move(){</span></p>
<p><span>　println("犬の"+name+"は移動しました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Cat(private　val　name:String,</span></p>
<p><span>　private　var　age:Int,</span></p>
<p><span>　private　val　gender:Boolean){</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("猫の"+name+"は"+</span></p>
<p><span>　(if(gender)"メス"else"オス")+</span></p>
<p><span>　"で"+age+"歳です。")</span></p>
<p>}</p>
<p><span> 　def　move(){</span></p>
<p><span>　println("猫の"+name+"は移動しました。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample28]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬のジョンはオスで5歳です。</span></p>
<p><span>猫のミーはメスで3歳です。</span></p>
<p><span>犬のジョンは移動しました。</span></p>
<p><span>猫のミーは移動しました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は犬を表現するDogクラスと、猫を表現するCatクラスを定義しました。特に問題ないように見えますが、冗長（無駄が多い）なプログラムです。何故なら、DogクラスとCatクラスの中身は、「犬」「猫」という文字列を使っている部分以外全く同じだからです。</span></p>
<p><span>ここで、DogクラスとCatクラスの共通点をスーパークラスにまとめて見ましょう。ちなみに、この作業を「汎化」と呼びます。スーパークラスとして動物を表現するAnimalクラスを定義してみます。「犬は動物の一種である」「猫は動物の一種である」という文面は正しいので、継承関係としては問題ありません。</span></p>
<p><span>DogクラスとCatクラスが個別に持っているname、age、genderフィールドはAnimalクラスにまとめて定義し、サブクラスで引き継いで使います。また、自己紹介introduceメソッドや、移動moveメソッドもAnimalクラスにまとめられます。ただし、動物の種類を表現するフィールドがAnimalクラスには必要となりますので、kindインスタンスフィールドを追加します。</span></p>
<p><span>次が継承関係を使用した、先ほどのサンプルプログラム「Sample28」の改良版です。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample29]継承後のサンプル(Sample29.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample29{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog:Animal=new　Dog("ジョン",5,false)</span></p>
<p><span>　val　cat:Animal=new　Cat("ミー",3,true)</span></p>
<p><span>　dog.introduce()</span></p>
<p><span>　cat.introduce()</span></p>
<p><span>　dog.move()</span></p>
<p><span>　cat.move()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Animal(　private　val　kind:String,</span></p>
<p><span>　private　val　name:String,　</span></p>
<p><span>　private　var　age:Int,</span></p>
<p><span>　private　val　gender:Boolean){</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println(kind+"の"+name+"は"+</span></p>
<p><span>　  　(if(gender)"メス"else"オス")+</span></p>
<p><span>　  　"で"+age+"歳です。")</span></p>
<p>}</p>
<p><span> 　def　move(){</span></p>
<p><span>　println(kind+"の"+name+"は移動しました。")</span><span>}</span></p>
<p>}</p>
<p><span>class　Dog(name:String,age:Int,gender:Boolean)</span></p>
<p><span>　extends　Animal("犬",name,age,gender)</span></p>
<p><span>class　Cat(name:String,age:Int,gender:Boolean)</span></p>
<p><span>　extends　Animal("猫",name,age,gender)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample29]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬のジョンはオスで5歳です。</span></p>
<p><span>猫のミーはメスで3歳です。</span></p>
<p><span>犬のジョンは移動しました。</span></p>
<p><span>猫のミーは移動しました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>実行結果は先ほどの「Sample28」と同じですが、プログラムは大きく異なります。</span></p>
<p><span>まず、DogクラスとCatクラスのスーパークラスとなるAnimalクラスを定義しました。Animalクラスの基本コンストラクタにprivateなパラメーターフィールドとして動物の種類kind、名前name、年齢age、性別genderを設けました。</span></p>
<p><span>そして自己紹介introduceメソッドと移動moveメソッドをAnimalクラスに移行しました。</span></p>
<p><span>DogクラスとCatクラスはAnimalクラスを継承しています。２つのクラスは基本コンストラクタとして、name、age、genderのクラスパラメーターを定義しています。その値をスーパークラスの基本コンストラクタに受け渡すために、「extends　Animal」の右後ろに丸かっこを記述して、必要な値を受け渡しています。スーパークラスの基本コンストラクタに値を受け渡すには、この方法しかありません。</span></p>
<p><span>今回のDogクラスとCatクラスがそうですが、クラスの中身が特にない場合はクラス定義の右後ろの中かっこのブロックは必要ありません。</span></p>
<p><span>最後にもうひとつ、ポイントがあります。mainメソッドのvalローカル変数dogとcatの型が明示的にAnimalとなっています。このように、サブクラスのインスタンスは、スーパークラス型の変数で参照することが可能です。これによって、サブクラスをスーパークラス型でグルーピングすることが可能となります。</span></p>
<p>
<div id="calibre_link-322"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-39">
<div>
<h2 id="calibre_link-323"><b><a id="calibre_link-137"><b><span><b>4-01　継承の演習問題</b></span></b></a></b></h2><p><span>Practice13シングルトンオブジェクトは完成しています。また、野球選手を表現するBaseballPlayerクラスも完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、投手を表現するPitcherクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Pitcherクラス]</span></p>
<p><span>１．PitcherクラスはBaseballPlayerクラスを継承します。</span></p>
<p><span>２．Pitcherクラスの基本コンストラクタは、選手名、背番号、打率、防御率を受け取ります。そのうち選手名、背番号、打率の３つはスーパークラスBaseballPlayerの基本コンストラクタでパラメーターフィールドとして宣言してありますので、ここではクラスパラメーターにします。唯一Pitcherクラスにだけ必要な防御率eraフィールドのみvarパラメーターフィールドに設定します。選手名、背番号、打率の値はスーパークラスBaseballPlayerの基本コンストラクタにうまく受け渡してください。</span></p>
<p><span>３．投手の情報を表示するintroduceインスタンスメソッドを定義します。引数と結果値はなしで、表示内容は下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span>mainメソッドでは、打率を増減させるchangeBattingAverageメソッドを呼んでいますので、出力結果の打率が初期値と異なる点に注意してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice13]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>選手名：山田</span></p>
<p><span>背番号：99</span></p>
<p><span>打率　：0.11</span></p>
<p><span>防御率：2.13</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice13]継承の演習問題(Practice13.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice13{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p=new　Pitcher("山田",99,0.09,2.13)</span></p>
<p><span>　p.changeBattingAverage(0.02)</span></p>
<p><span>　p.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>//BaseballPlayerクラス</span></p>
<p><span>class　BaseballPlayer(val　name:String,</span></p>
<p><span>　val　uniformNumber:Int,</span></p>
<p><span>　var　battingAverage:Double){</span></p>
<p><span> 　def　changeBattingAverage(change:Double){</span></p>
<p><span>　battingAverage+=change</span></p>
<p>}</p>
<p>}</p><p><span>//ここにPitcherクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-324"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-85">
<div>
<h2 id="calibre_link-325"><b><a id="calibre_link-138"><b><span><b>4-02　オーバーライド</b></span></b></a></b></h2><p><span>クラスを継承すると、サブクラスはスーパークラスの（privateでない）メンバを引き継ぐことができるので、サブクラスのコーディング量を減らすことができます。この考え方を「差分コーディング」といい、サブクラスはスーパークラスの足りないメンバだけを実装すればいいことになります。</span></p>
<p><span>しかし、このメンバを引き継げるメリットがかえって問題になることもあります。たとえば、次のプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample30]おかしなサンプル(Sample30.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample30{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog=new　Dog</span></p>
<p><span>　val　cat=new　Cat</span></p>
<p><span>　val　pla=new　Platypus</span></p>
<p><span>　dog.birth()</span></p>
<p><span>　cat.birth()</span></p>
<p><span>　pla.birth()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Mammal(val　kind:String){</span></p>
<p><span> 　def　birth(){</span></p>
<p><span>　println(kind+"が赤ちゃんを産みました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Dog　extends　Mammal("犬")</span></p>
<p><span>class　Cat　extends　Mammal("猫")</span></p>
<p><span>class　Platypus　extends　Mammal("カモノハシ")</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample30]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬が赤ちゃんを産みました。</span></p>
<p><span>猫が赤ちゃんを産みました。</span></p>
<p><span>カモノハシが赤ちゃんを産みました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はまず哺乳類を表現するMammalクラスを定義し、そのサブクラスとして犬Dogクラス、猫Catクラス、カモノハシPlatypusを定義しました。そしてMammalクラスが持っているパラメーターフィールドは動物の種類を表現するkindだけで、あとは赤ちゃんを産むbirthメソッドを持っています。</span></p>
<p><span>実行結果を見て、「あれ？」と思った方はいらっしゃいますか？</span></p>
<p><span>実は、カモノハシは哺乳類ですが卵を産むという珍しい習性があります。よって、このプログラムではカモノハシが赤ちゃんを産んでいるため、間違ったプログラムということになります。では、どのように解決しましょう？Mammalクラスで定義されているbirthメソッドを、各サブクラスに移行するのはどうでしょうか。そうすれば、カモノハシのbirthメソッドだけ「卵を産みました」に変更できます。</span></p>
<p><span>しかし、世の中のほとんどすべての哺乳類は赤ちゃんを産みます。このあと、Mammalクラスのサブクラスに馬、猿、羊、熊...とたくさんのクラスを作成した場合、それぞれに同じbirthメソッドを実装しなくてはいけなくなります。</span></p>
<p><span>つまり、カモノハシだけが特別なので、カモノハシだけ別のbirthメソッドを定義すればいいわけです。スーパークラスから受け継いだメソッドやフィールドをそのまま利用せず、サブクラスでカスタマイズして再定義することを「オーバーライド」といいます。メソッドやフィールドをオーバーライドする際は、メソッドやフィールドの定義の左前に「override」という予約語をつけてあげればOKです。</span></p>
<p><span>では、さきほどのサンプルプログラムをカモノハシクラスだけ変更してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample31]オーバーライドのサンプル(Sample31.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample31{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog=new　Dog</span></p>
<p><span>　val　cat=new　Cat</span></p>
<p><span>　val　pla=new　Platypus</span></p>
<p><span>　dog.birth()</span></p>
<p><span>　cat.birth()</span></p>
<p><span>　pla.birth()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Mammal(val　kind:String){</span></p>
<p><span> 　def　birth(){</span></p>
<p><span>　println(kind+"が赤ちゃんを産みました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Dog　extends　Mammal("犬")</span></p>
<p><span>class　Cat　extends　Mammal("猫")</span></p>
<p><span>class　Platypus　extends　Mammal("カモノハシ"){</span></p>
<p><span> 　override　def　birth(){</span></p>
<p><span>　println(kind+"が卵を産みました。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample31]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬が赤ちゃんを産みました。</span></p>
<p><span>猫が赤ちゃんを産みました。</span></p>
<p><span>カモノハシが卵を産みました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回、カモノハシクラスはスーパークラスMammalから受け継いだbirthメソッドを使いたくないので、カモノハシクラスでbirthメソッドをオーバーライド（再定義）しました。実行すると、きちんと「カモノハシが卵を産みました。」と出力されます。</span></p>
<p><span>「継承」と「オーバーライド」はオブジェクト指向プログラミングの要となる重要な考え方なので、しっかりとマスターしましょう。</span></p>
<p>
<div id="calibre_link-326"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-22">
<div>
<h2 id="calibre_link-327"><b><a id="calibre_link-139"><b><span><b>4-02　オーバーライドの演習問題</b></span></b></a></b></h2><p><span>Practice14シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、自転車BicycleクラスとバイクMotorBicycleクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Bicycleクラス]</span></p>
<p><span>１．このクラスにはフィールドは不要です。</span></p>
<p><span>２．ハンドルを切ることを表現するturnメソッドを定義します。「ハンドルを切ります。」と出力してください。</span></p>
<p><span>３．移動することを表現するmoveメソッドを定義します。「ペダルを漕いで進みます。」と出力してください。</span></p>
<p>&nbsp;</p>
<p><span>[MotorBicycleクラス]</span></p>
<p><span>１．このクラスにはフィールドは不要です。</span></p>
<p><span>２．このクラスはBicycleクラスを継承します。</span></p>
<p><span>３．ハンドルを切ることを表現するturnメソッドはスーパークラスBicycleから継承したものをそのまま使いますが、移動することを表現するmoveメソッドはオーバーライドして再定義します。「エンジンを動力に進みます。」と出力してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice14]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>ハンドルを切ります。</span></p>
<p><span>ペダルを漕いで進みます。</span></p>
<p><span>ハンドルを切ります。</span></p>
<p><span>エンジンを動力に進みます。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice14]オーバーライドの演習問題(Practice14.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice14{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　b=new　Bicycle</span></p>
<p><span>　val　mb=new　MotorBicycle</span></p>
<p><span>　b.turn()</span></p>
<p><span>　b.move()</span></p>
<p><span>　mb.turn()</span></p>
<p><span>　mb.move()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにBicycleクラスとMotorBicycleクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-328"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-72">
<div>
<h2 id="calibre_link-329"><b><a id="calibre_link-140"><b><span><b>4-03　予約語　super</b></span></b></a></b></h2><p><span>オーバーライドには大切なポイントがあります。スーパークラスのあるメソッドをサブクラスでオーバーライドした場合、そのサブクラスのインスタンスはスーパークラスから受け継いだメソッドと、サブクラスでオーバーライドしたメソッドの両方を持っており、その場合はオーバーライドしたメソッドの方が優先的に呼び出されるという決まりになっているということです。</span></p>
<p><span>つまり、メソッドをオーバーライドしたものの、やっぱりスーパークラスから受け継いだメソッドを使いたい場合でもそれは可能なわけです。その際は、予約語「super」を使って「super.メソッド名」と記述すればOKです。つまり、「スーパークラスの方のメソッド」と明示的に記述するわけです。次のプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample32]予約語superのサンプル(Sample32.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample32{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　ant=new　Ant</span></p>
<p><span>　val　bee=new　Bee</span></p>
<p><span>　ant.move()</span></p>
<p><span>　bee.move()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Insect(val　kind:String){</span></p>
<p><span> 　def　move(){</span></p>
<p><span>　println(kind+"が歩きました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Ant　extends　Insect("アリ")</span></p>
<p><span>class　Bee　extends　Insect("ハチ"){</span></p>
<p><span> 　override　def　move(){</span></p>
<p><span>　super.move()</span></p>
<p><span>　println(kind+"が飛びました。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample32]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>アリが歩きました。</span></p>
<p><span>ハチが歩きました。</span></p>
<p><span>ハチが飛びました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は虫を表現するInsectクラスをスーパークラスとし、サブクラスにアリを表現するAntクラスとハチを表現するBeeクラスを定義しました。そして、Insectクラスにはその虫が移動することを表現するmoveメソッドを定義しました。</span></p>
<p><span>今回、虫は基本的に歩いて移動すると考えています。アリは歩くことしかできませんから、そのままスーパークラスから引き継いだmoveメソッドを使用すれば良いわけです。しかし、ハチは歩くこともできますが、飛ぶこともできます。なので、Beeクラスではmoveメソッドをオーバーライドして飛ぶことを表現しました。でも、ハチは常に飛んでいるわけでもありません。よって、スーパークラスから引き継いだ、歩くことを表現するmoveメソッドも使いたいわけです。なので、ハチのmoveメソッドの中で「super.move()」と記述することでスーパークラスから引き継いだ歩く方のmoveメソッドも呼び出し、さらにオーバーライドした飛ぶ方のmoveメソッドの中身も実行しているわけです。</span></p>
<p>
<div id="calibre_link-330"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-9">
<div>
<h2 id="calibre_link-331"><b><a id="calibre_link-141"><b><span><b>4-03　予約語superの演習問題</b></span></b></a></b></h2><p><span>Practice15シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、時計Clockクラスと目覚まし時計AlarmClockクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Clockクラス]</span></p>
<p><span>１．このクラスは現在の時刻を表現するための時hourフィールド、分minuteフィールド、秒secondフィールドを持ちます。基本コンストラクタで時・分・秒を受け取り、privateなvarパラメーターフィールド（Int型）として値を設定します。</span></p>
<p><span>２．現在の時刻を表示するためのshowDataメソッドを定義します。引数および結果値はなしで、「ただいまの時刻：○時○分○秒」というフォーマットで情報を出力します。</span></p>
<p>&nbsp;</p>
<p><span>[AlarmClockクラス]</span></p>
<p><span>１．Clockクラスを継承します。</span></p>
<p><span>２．基本コンストラクタとして、時・分・秒に加え、アラームの鳴る時・分を受け取ります。時・分・秒はスーパークラスClockの基本コンストラクタに受け渡し、アラームの鳴る時・分はprivateなvarパラメーターフィールドalarmHour、alarmMinute（いずれもInt型）として定義します。</span></p>
<p><span>３．スーパークラスClockのshowDataメソッドをオーバーライドします。その内部処理としては、スーパークラスのshowDataメソッドを呼び出して現在時刻を出力し、その後に「アラーム設定時刻：○時○分」というフォーマットで情報を出力します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice15]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>ただいまの時刻：10時15分30秒</span></p>
<p>&nbsp;</p>
<p><span>ただいまの時刻：15時45分20秒</span></p>
<p><span>アラーム設定時刻：6時30分</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice15]予約語superの演習問題(Practice15.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice15{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　c1=new　Clock(10,15,30)</span></p>
<p><span>　c1.showData()</span></p>
<p><span>　println()</span></p>
<p><span>　val　c2=new　AlarmClock(15,45,20,6,30)</span></p>
<p><span>　c2.showData()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにClockクラスとAlarmClockクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-332"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-56">
<div>
<h2 id="calibre_link-333"><b><a id="calibre_link-142"><b><span><b>4-04　アクセス修飾子　protected</b></span></b></a></b></h2><p><span>今までのところ、クラスのメンバのアクセスレベルは２種類しか紹介していません。どこからでもアクセスできる「アクセス修飾子をつけない」状態と、同じクラス内からのみアクセスできる「アクセス修飾子privateを付加した」状態です。</span></p>
<p><span>しかし、アクセスレベルが２種類だけだと不便なことが起こります。次のプログラムで確認してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample33]よくないサンプル(Sample33.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample33{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　h=new　Human("山本",26,true)</span></p>
<p><span>　h.speak()</span></p>
<p><span>　h.birthday()</span></p>
<p><span>　h.speak()</span></p>
<p><span>　h.age　=　300　//！</span></p>
<p><span>　h.speak()</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Animal(var　age:Int,val　gender:Boolean){</span></p>
<p><span> 　def　birthday(){</span></p>
<p><span>　println("1歳年を取りました。")</span></p>
<p><span>　age+=1</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Human(val　name:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(a,g){</span></p>
<p><span> 　def　speak(){</span></p>
<p><span>　println("私の名前は"+name+"、性別は"+</span></p>
<p><span>　(if(gender)"女性"else"男性")+</span></p>
<p><span>　"で年齢は"+age+"歳です。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample33]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>私の名前は山本、性別は女性で年齢は26歳です。</span></p>
<p><span>1歳年を取りました。</span></p>
<p><span>私の名前は山本、性別は女性で年齢は27歳です。</span></p>
<p><span>私の名前は山本、性別は女性で年齢は300歳です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は動物を表現するAnimalクラスを定義し、動物は年齢と性別を持っているという前提にしています。パラメーターフィールドを用いて、年齢はvar、性別はvalで定義しました。あと、動物も誕生日がくれば１歳年を取るので、birthdayというメソッドを用意しました。</span></p>
<p><span>そのサブクラスに人間を表現するHumanクラスを定義しました。人間は動物と違って名前を持つという前提にするために、valパラメーターフィールドnameを持っています。年齢と性別はクラスパラメーターにして、スーパークラスの基本コンストラクタに受け渡しています。あと、人間は自分のことを話すことができるので、speakというメソッドを定義しました。</span></p>
<p><span>さて、実行結果を見ると、ひどいことになっています。Animalスーパークラスのvarフィールドageにprivateが付加されていないので、外部から簡単に値を変更できてしまうのです。実際、mainメソッドで３００歳に設定されてしまいました。</span></p>
<p><span>解決策はprivateを付加すればいいと思われるかもしれませんが、それは間違いです。何故なら、もし年齢ageや性別genderにprivateを付加すれば、サブクラスHumanに受け継がれないため、speakメソッドでageやgenderを使えないのです。</span></p>
<p><span>もちろん、解決策はあります。それが「アクセス修飾子protected」です。「protected」はほとんどprivateと同様なのですが、サブクラスには引き継がれるという違いがあります。</span></p>
<p><span>さきほどのプログラム、パラメーターフィールドageとgenderにprotectedを付加してみてください。mainメソッドの「h.age=300」の部分がコンパイルエラーになり、そこをコメントアウトするとすべてうまく動作します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample34]アクセス修飾子protectedのサンプル(Sample34.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample34{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　h=new　Human("山本",26,true)</span></p>
<p><span>　h.speak()</span></p>
<p><span>　h.birthday()</span></p>
<p><span>　h.speak()</span></p>
<p><span>　//h.age=300　コンパイルエラー</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Animal(protected　var　age:Int,</span></p>
<p><span>　protected　val　gender:Boolean){</span></p>
<p><span> 　def　birthday(){</span></p>
<p><span>　println("1歳年を取りました。")</span></p>
<p><span>　age+=1</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Human(val　name:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(a,g){</span></p>
<p><span> 　def　speak(){</span></p>
<p><span>　println("私の名前は"+name+"、性別は"+</span></p>
<p><span>　(if(gender)"女性"else"男性")+</span></p>
<p><span>　"で年齢は"+age+"歳です。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample34]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>私の名前は山本、性別は女性で年齢は26歳です。</span></p>
<p><span>1歳年を取りました</span></p>
<p><span>私の名前は山本、性別は女性で年齢は27歳です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-334"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-218">
<div>
<h2 id="calibre_link-335"><b><a id="calibre_link-143"><b><span><b>4-04　アクセス修飾子protectedの演習問題</b></span></b></a></b></h2><p><span>Practice16シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、乗り物Vehicleクラスと飛行機Airplaneクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Vehicleクラス]</span></p>
<p><span>１．パラメーターフィールドとして、現在の速度を表すvarフィールドspeed（Int型）と、残燃料を表すvarフィールドfuel（Double型）を持ちます。この２つのフィールドは、外部から簡単に値を変更できてはいけないので、protectedアクセスに設定してください。</span></p>
<p><span>２．クラスの中身は特にありません。</span></p>
<p>&nbsp;</p>
<p><span>[Airplaneクラス]</span></p>
<p><span>１．Vehicleクラスを継承します。</span></p>
<p><span>２．基本コンストラクタとして、高度、速度、残燃料の順に値を受け取ります。高度はこのクラスだけに定義するものなので、privateなvarパラメーターフィールド（Int型）にし、速度と残燃料はスーパークラスVehicleの基本コンストラクタに受け渡します。</span></p>
<p><span>３．離陸を表現するtakeoffメソッド（引数なし、結果値なし）を定義します。「離陸しました。」と出力し、速度を500加算、高度を10000加算、残燃料を100.0減算します。</span></p>
<p><span>４．現在の状況を表示するinformationメソッド（引数なし、結果値なし）を定義します。出力内容は、下記実行結果を参考にしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice16]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>離陸しました。</span></p>
<p><span>--　現在の状況　--</span></p>
<p><span>高度：10000フィート</span></p>
<p><span>速度：時速500km</span></p>
<p><span>残燃料99900.0リットル</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice16]アクセス修飾子protectedの演習問題(Practice16.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice16{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　ap=new　Airplane(0,0,100000)</span></p>
<p><span>　ap.takeoff()</span></p>
<p><span>　ap.information()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにVehicleクラスとAirplaneクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-336"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-66">
<div>
<h2 id="calibre_link-337"><b><a id="calibre_link-144"><b><span><b>4-05　抽象クラスと抽象メンバ</b></span></b></a></b></h2><p><span>サンプルプログラム[Sample29]で記述したAnimalスーパークラスとDog、Catサブクラスのプログラムをもう一度取り上げてみましょう。[Sample29]では、どんな動物も移動することができるという前提で、スーパークラスAnimalにmoveメソッドを定義しました。そしてサブクラスDogとCatのインスタンスでmoveメソッドを実行しました。</span></p>
<p><span>では、次に動物が食べることを表現するeatメソッドを定義してみましょう。このメソッドはスーパークラス、サブクラス、どちらに定義したほうがいいでしょうか？ものを食べない動物は絶対にいません。なので、当然スーパークラスだと考えます。しかし、それだとある問題が発生します。何故なら、サブクラスの動物の種類によって食べるものが異なるため、スーパークラスAnimalで共通化できないのです。</span></p>
<p><span>動物Animalクラスは必ず食べるeatメソッドを持っている、でもeatメソッドの中身はサブクラスごとに異なるので記述できないということになります。</span></p>
<p><span>ここで少しお話を変えてみましょう。</span></p>
<p><span>そもそも、よくよく考えてみるとこのクラス構成はおかしいことが分かります。「Cat　is　a　kind　of　Animal」、「猫は動物の一種である」という文面は正しいです。でも、もし次のようなプログラムを実行したらどうなるでしょう。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>val　animal=new　Animal("？","？",1,true)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このプログラムはコンパイル・実行とも可能です。猫クラスのインスタンスは猫そのものです。猫は頭の中でイメージできますね。犬クラスのインスタンスは犬そのものです。犬も頭の中でイメージできますよね。では、動物クラスのインスタンスとは、いったいどのようなものでしょうか？みなさんは「動物」という動物を見たことがありますか？</span></p>
<p><span>「動物」とは、犬や猫を表すための抽象的表現に過ぎません。つまり、スーパークラスAnimalは抽象的な存在であって、newを使ってインスタンス化できてはいけないということになります。</span></p>
<p><span>ここで答えなのですが、Scalaをはじめ多くのオブジェクト指向プログラミング言語では、抽象的なクラス、ずばり「抽象クラス」というのですが、インスタンス化できないクラスを定義可能なのです。</span></p>
<p><span>抽象クラスの定義方法は以下の通りです。</span></p>
<p>&nbsp;</p>
<p><span><b>[抽象クラスの定義方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>abstract　class　クラス名</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>予約語「abstract」をクラス定義の左前に付加するだけでOKです。抽象クラスはいわば「不完全なクラス」ともいえるでしょう。基本的に抽象クラスは継承される前提のクラス、つまりスーパークラスになるべくして生まれてきたクラスです。抽象クラスのサブクラスは普通にインスタンス化できるクラスとして定義するのが一般的です。もちろん、抽象クラスのサブクラスの定義には予約語「abstract」を付加しません。抽象クラスではない、普通にインスタンス化できるクラスのことを「具象クラス」とも言います。</span></p>
<p><span>そして、ここが重要なのですが、抽象クラスは抽象メンバを持つことができます。抽象メンバには抽象メソッドと抽象フィールド（その他に抽象型）があります。</span></p>
<p><span>抽象メソッドとは、メソッドの宣言（メソッド名や引数リストを記述すること）は可能ですが、メソッドの定義（具体的な処理を記述すること）は記述できないメソッドを言います。さきほどのeatメソッドはまさに抽象メソッドです。</span></p>
<p><span>抽象フィールドとは、初期値を持たないフィールドのことです。フィールドはvalとvarを問わず初期値の代入が必須です。しかし、フィールドが必要なのはわかっているけど、初期値がまだ分からない場合は抽象フィールドにすると便利です。その初期値はサブクラスで設定してあげるのです。</span></p>
<p><span>今までの例でいうと、動物の種類を現すkindフィールドがそれにあたります。動物Animalクラスには、具体的な動物の種類を表すkindフィールドが必要です。ただ、初期値が設定できないため、パラメーターフィールドにして基本コンストラクタから値を受け取っていました。しかし、この処理は無駄が多いので、抽象フィールドにすると良くなります。ちなみに、抽象メンバには普通、予約語「abstract」をつけません。ただし、明示的に付加することも可能です。</span></p>
<p><span>では、抽象クラスと抽象メンバを用いたサンプルをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample35]抽象クラスと抽象メンバのサンプル(Sample35.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample35{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog:Animal=new　Dog("ジョン",5,false)</span></p>
<p><span>　val　cat:Animal=new　Cat("ミー",3,true)</span></p>
<p><span>　dog.introduce()</span></p>
<p><span>　cat.introduce()</span></p>
<p><span>　dog.eat()</span></p>
<p><span>　cat.eat()</span></p>
<p>}</p>
<p>}</p>
<p><span>abstract　class　Animal(protected　val　name:String,</span></p>
<p><span>　protected　var　age:Int,</span></p>
<p><span>　protected　val　gender:Boolean){</span></p>
<p><span> 　val　kind:String//抽象フィールドの宣言</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println(kind+"の"+name+"は"+</span></p>
<p><span>　(if(gender)"メス"else"オス")+</span></p>
<p><span>　"で"+age+"歳です。")</span></p>
<p>}</p>
<p><span> 　def　eat()　//　抽象メソッドの宣言</span></p>
<p>}</p>
<p><span>class　Dog(n:String,a:Int,g:Boolean)　</span></p>
<p><span>　extends　Animal(n,a,g){</span></p>
<p><span> 　//抽象フィールドの実装</span></p>
<p><span> 　val　kind="犬"</span></p>
<p><span> 　//抽象メソッドの実装</span></p>
<p><span> 　def　eat(){</span></p>
<p><span>　println(kind+"の"+name+"は肉を食べました。")</span><span>}</span></p>
<p>}</p>
<p><span>class　Cat(n:String,a:Int,g:Boolean)　</span></p>
<p><span>　extends　Animal(n,a,g){</span></p>
<p><span> 　//抽象フィールドの実装</span></p>
<p><span> 　override　val　kind="猫"</span></p>
<p><span> 　//抽象メソッドの実装</span></p>
<p><span> 　override　def　eat(){</span></p>
<p><span>　println(kind+"の"+name+"は魚を食べました。")</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample35]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬のジョンはオスで5歳です。</span></p>
<p><span>猫のミーはメスで3歳です。</span></p>
<p><span>犬のジョンは肉を食べました。</span></p>
<p><span>猫のミーは魚を食べました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まずAnimalクラスを抽象クラスにし、インスタンス化できないようにしました。抽象クラスは抽象メンバを宣言できるのですが、動物の種類を表現するkindを抽象フィールドにしました。抽象フィールドは値による初期化をしませんが、その代わりに型の定義を記述する必要があります。型の定義がないとコンパイルエラーになります。</span></p>
<p><span>あと、食べることを表現するeatメソッドを抽象メソッドにしています。抽象メソッドは定義を書かないので、等号も中かっこも必要ありません。</span></p>
<p><span>そしてサブクラスDogとCatで抽象メンバの具体的な定義を記述します。そのことを「実装」といいます。Dogのほうの抽象メンバはそのまま実装していますが、Catのほうの抽象メンバは予約語「override」を付加して実装しました。つまり、どちらでもOKなのですが、普通はつけません。</span></p>
<p><span>抽象メソッドのeatは必要ないと思われる方もいるかもしれませんが、ないとコンパイルエラーになります。何故なら、mainメソッドのval変数dogとcatの型を明示的にAnimalに指定しているからです。コンパイラは変数の型を頼りにメソッドの存在を探しますので、もしAnimalクラスにeat抽象メソッドがないと「dog.eat()」の部分で「Animal型の変数dogはeatメソッドを持っていない」という理由でコンパイルエラーとなります。</span></p>
<p><span>また、Animalクラスのintroduceメソッドで、普通に抽象フィールドkindを使用しているのもポイントです。サブクラスでの抽象フィールドの実装も一種のオーバーライドなので、サブクラスの具象フィールドkindの値が優先的に使われるという仕組みになっています。</span></p>
<p>
<div id="calibre_link-338"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-51">
<div>
<h2 id="calibre_link-339"><b><a id="calibre_link-145"><b><span><b>4-05　抽象クラスと抽象メンバの演習問題</b></span></b></a></b></h2><p><span>Practice17シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、労働者WorkerクラスとコックCookクラス、デザイナーDesignerクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Workerクラス]</span></p>
<p><span>１．抽象クラスに設定します。</span></p>
<p><span>２．名前を保持するためのvalパラメーターフィールドname(String型)を持ちます。</span></p>
<p><span>３．職種を表現するvalフィールドjobType（String型）を定義します。ただし、サブクラスが決まらないとこのフィールドの値は分からないので抽象フィールドにします。</span></p>
<p><span>４．働くworkメソッド（引数なし、結果値なし）を定義します。ただし、サブクラスが決まらないとメソッドの中身を実装できないので、抽象メソッドにします。</span></p>
<p><span>５．自己紹介introduceメソッド（引数なし、結果値なし）を定義します。「わたくし○○は△△です。」と出力します。</span></p>
<p>&nbsp;</p>
<p><span>[Cookクラス・Designerクラス]</span></p>
<p><span>１．Workerクラスを継承します。</span></p>
<p><span>２．基本コンストラクタとして、名前をクラスパラメーターとして受け取ります。スーパークラスWorkerの基本コンストラクタにうまく受け渡してください。</span></p>
<p><span>３．職種jobType抽象フィールドを実装します。値は「コック」「デザイナー」にします。</span></p>
<p><span>４．働くwork抽象メソッドを実装します。「○○さんはおいしいパスタを作りました。」「○○さんは斬新なイラストを描きました。」と出力します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice17]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>わたくし酒井はコックです。</span></p>
<p><span>酒井さんはおいしいパスタを作りました。</span></p>
<p><span>わたくし片桐はデザイナーです。</span></p>
<p><span>片桐さんは斬新なイラストを描きました。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice17]抽象クラスと抽象メンバの演習問題(Practice17.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice17{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　cook:Worker=new　Cook("酒井")</span></p>
<p><span>　val　designer:Worker=new　Designer("片桐")</span></p>
<p><span>　cook.introduce()</span></p>
<p><span>　cook.work()</span></p>
<p><span>　designer.introduce()</span></p>
<p><span>　designer.work()</span></p>
<p>}</p>
<p>}</p><p><span>//ここにWorkerクラスとCook・Designerクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-340"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-204">
<div>
<h2 id="calibre_link-341"><b><a id="calibre_link-146"><b><span><b>4-06　finalクラスとfinalメンバ</b></span></b></a></b></h2><p><span>予約語「abstract」のついていない通常のクラスは「具象クラス」と呼ばれます。具象クラスは継承することもできますし、継承しないでそのまま使うこともできます。</span></p>
<p><span>しかし、場合によっては継承されたくないことも有り得ます。たとえば、クラスとしてもう完成しており、サブクラスを作って欲しくない場合などです。</span></p>
<p><span>その場合、予約語「final」をクラスの定義の左前に記述することで、継承されるのを未然に防ぐことができます。下記プログラムはコンパイルエラーになります。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample36]finalクラスのサンプル(Sample36.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>final　class　Super</span></p>
<p><span>class　Sub　extends　Super</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>privateではない通常の（abstractではない）フィールドやメソッドは、サブクラスで自由にオーバーライドすることが可能です。予約語「final」をつけたメンバは、サブクラスでオーバーライドできなくなります。下記プログラムはコンパイルエラーになります。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample37]finalメンバのサンプル(Sample37.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　Super{</span></p>
<p><span> 　final　val　field=10</span></p>
<p><span> 　final　def　method()=1+2</span></p>
<p>}</p>
<p><span>class　Sub　extends　Super{</span></p>
<p><span> 　override　val　field=20</span></p>
<p><span> 　override　def　method()=3+4</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-342"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-52">
<div>
<h2 id="calibre_link-343"><b><a id="calibre_link-147"><b><span><b>4-07　toStringメソッドのオーバーライド</b></span></b></a></b></h2><p><span>ScalaのすべてのクラスはAnyクラスを継承しています。Anyクラスはすべてのクラス階層の頂点に位置します。そして、AnyクラスにはサブクラスAnyRefがあり、プログラマが作成したクラスは必ずAnyRefクラスのサブクラスになります。</span></p>
<p><span>そのAnyRefクラスには有益なメソッドが多数あるのですが、その中でも重要なのがtoStringメソッドです。「to　String」つまり日本語にすると「文字列として」という意味になります。つまり、toStringメソッドは、そのインスタンスの情報を文字列として返すメソッドです。デフォルトのtoStringメソッドは、「クラス名@ハッシュコードの１６進数表現」というあまり意味のない情報を結果値として返します。</span></p>
<p><span>このメソッドは、サブクラスでオーバーライドして有益な文字列情報を返すように作り変えてもらう前提で定義されているメソッドです。</span></p>
<p><span>まず、次のコードをコーディングして実行してみてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample38]toStringメソッドオーバーライド前のサンプル(Sample38.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample38{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog:Animal=new　Dog("ジョン",5,false)</span></p>
<p><span>　val　cat:Animal=new　Cat("ミー",3,true)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat.toString)</span></p>
<p>}</p>
<p>}</p>
<p><span>abstract　class　Animal(protected　val　name:String,</span></p>
<p><span>　protected　var　age:Int,</span></p>
<p><span>　protected　val　gender:Boolean){</span></p>
<p><span> 　val　kind:String</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println(kind+"の"+name+"は"+</span></p>
<p><span>　(if(gender)"メス"else"オス")+</span></p>
<p><span>　"で"+age+"歳です。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Dog(n:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(n,a,g){</span></p>
<p><span> 　val　kind="犬"</span></p>
<p>}</p>
<p><span>class　Cat(n:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(n,　a,　g){</span></p>
<p><span> 　val　kind="猫"</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample38]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>Dog@b25e1a</span></p>
<p><span>Cat@17b4cdf</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このサンプルプログラムは[Sample35]を少し改変したものです。mainメソッドで宣言した参照変数dogをそのままprintlnメソッドの引数に渡しています。printlnメソッドは引数に参照変数が渡されると、自動的に「toString」メソッドを付加して文字列に変換し、その値を出力します。参照変数dogはそのままprintlnメソッドに渡していますが、参照変数catの方は明示的にtoStringメソッドを呼び出してみました。</span></p>
<p><span>結果的にこの２つは同じ意味になり、出力値として「クラス名@ハッシュコードの１６進数表現」が出力されます。（@以降の値は環境によって異なることがあります）</span></p>
<p><span>では、もっと有益な情報を出力するようにtoStringメソッドをオーバーライドしましょう。ちょうどいいメソッドがすでに用意されています。それはintroduceメソッドです。introduceメソッドはそのインスタンスの詳細情報を、printlnメソッドを用いて出力しています。このメソッドを結果値として文字列を返すように作り変えてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample39]toStringメソッドオーバーライド後のサンプル(Sample39.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample39{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　dog:Animal=new　Dog("ジョン",5,false)</span></p>
<p><span>　val　cat:Animal=new　Cat("ミー",3,true)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat.toString)</span></p>
<p>}</p>
<p>}</p>
<p><span>abstract　class　Animal(protected　val　name:String,</span></p>
<p><span>　protected　var　age:Int,</span></p>
<p><span>　protected　val　gender:Boolean){</span></p>
<p><span> 　val　kind:String</span></p>
<p><span> 　override　def　toString()={</span></p>
<p><span>　kind+"の"+name+"は"+</span></p>
<p><span>　(if(gender)"メス"else"オス")+</span></p>
<p><span>　"で"+age+"歳です。"</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Dog(n:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(n,a,g){</span></p>
<p><span> 　val　kind="犬"</span></p>
<p>}</p>
<p><span>class　Cat(n:String,a:Int,g:Boolean)</span></p>
<p><span>　extends　Animal(n,a,g){</span></p>
<p><span> 　val　kind="猫"</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample39]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>犬のジョンはオスで5歳です。</span></p>
<p><span>猫のミーはメスで3歳です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今度はtoStringメソッドの結果値として、そのインスタンスに関する有益な情報が返ってきました。toStringメソッドの結果型はString型なので、メソッド定義に等号を付け忘れないようにしましょう。また、toStringメソッドはスーパークラスAnyRefのオーバーライドなので、予約語「override」も忘れずに付加しましょう。</span></p>
<p>
<div id="calibre_link-344"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-11">
<div>
<h2 id="calibre_link-345"><b><a id="calibre_link-148"><b><span><b>4-07　toStringメソッドのオーバーライドの演習問題</b></span></b></a></b></h2><p><span>Practice18シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、本Bookクラスと雑誌Magazineクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Bookクラス]</span></p>
<p><span>１．本クラスは具象クラスです。（予約語abstractを付加しません）</span></p>
<p><span>２．基本コンストラクタで、次のprotectedなvalパラメーターフィールドを定義します。</span></p>
<p><span>タイトルを表現するフィールドtitle(String型)</span></p>
<p><span>価格を表現するフィールドprice(Int型)</span></p>
<p><span>著者を表現するフィールドauthor(String型)</span></p>
<p><span>３．toStringメソッドをオーバーライドします。結果値として返す文字列は「タイトル：○○　価格：△△円　著者：□□」というフォーマットにします。</span></p>
<p>&nbsp;</p>
<p><span>[Magazineクラス]</span></p>
<p><span>１．Bookクラスを継承します。</span></p>
<p><span>２．基本コンストラクタで、クラスパラメーターとしてタイトル・価格・著者の情報を受け取ります。スーパークラスの基本コンストラクタにうまく受け渡してください。それに加えて、雑誌の表紙のタレント名を表すcoverPersonNameというvalパラメーターフィールド（String型）を第四引数に定義します。</span></p>
<p><span>３．toStringメソッドをオーバーライドします。結果値として返す文字列は「タイトル：○○　価格：△△円　著者：□□　表紙：☆☆さん」というフォーマットにします。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice18]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>タイトル：人間失格　価格：500円　著者：太宰治</span></p>
<p><span>タイトル：東京グルメ　価格：980円　著者：ABC出版編集部　表紙：上田彩さん</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice18]toStringメソッドのオーバーライドの演習問題(Practice18.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice18{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　book=new　Book("人間失格",500,"太宰治")</span><span>val　magazine=</span></p>
<p><span>　　　new　Magazine("東京グルメ",980,"ABC出版編集部","上田彩")</span><span>println(book)</span></p>
<p><span>　println(magazine)</span></p>
<p>}</p>
<p>}</p><p><span>//ここにBookクラスとMagazineクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-346"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-221">
<div>
<h2 id="calibre_link-347"><b><a id="calibre_link-149"><b><span><b>4-08　トレイト</b></span></b></a></b></h2><p><span>今まで「object」や「class」という予約語を用いてオブジェクトやクラスを定義してきました。実はもうひとつ大切なものがあります。それを「トレイト」といいます。「トレイト」とは、簡単に言うと特殊なクラスのようなものです。</span></p>
<p><span>トレイトの定義には予約語「trait」を使用します。あとは「object」や「class」と同様にトレイト名（識別子）を記述し、必要に応じてブロックに中身を記述します。</span></p>
<p>&nbsp;</p>
<p><span><b>[トレイトの定義方法]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>trait　トレイト名{</span></p>
<p><span> 　メンバの定義</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>トレイトは抽象クラスにとてもよく似ており、具象メンバや抽象メンバを持つことができます。また、直接インスタンス化することもできません。ただし、抽象クラスとは異なる点がいくつかあります。</span></p>
<p><span>１つ目は、トレイトはシングルトンオブジェクトと同様、クラスパラメーターを持つことができない、つまりコンストラクタを持つことができない点です。</span></p>
<p><span>２つ目は、トレイトはクラスで「継承」するのではなく、「ミックスイン」する点です。「ミックスイン」とは継承のような強いつながりではなく、機能をプラスするような感覚を表現しています。</span></p>
<p><span>クラスにトレイトをミックスインするには次の２つの構文があります。</span></p>
<p>&nbsp;</p>
<p><span><b>[クラスにトレイトをミックスインする構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　クラス名　extends　トレイト名</span></p>
<p><span>または</span></p>
<p><span>class　クラス名　extends　スーパークラス名　with　トレイト名</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>あるクラスにスーパークラスを指定せず、トレイトだけをミックスインしたい場合はクラスの継承と同様に予約語「extends」を使用します。</span></p>
<p><span>あるクラスがスーパークラスを継承し、かつトレイトをミックスインしたい場合は予約語「with」を記述しトレイトを指定します。クラスの継承とは異なり、クラスは複数のトレイトをミックスインできます。その際は「with　トレイト１　with　トレイト２　...」という風に記述します。</span></p>
<p><span>では、まずはトレイトのサンプルを実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample40]トレイトのサンプル(Sample40.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample40{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　swallow=new　Swallow</span></p>
<p><span>　swallow.fly</span></p>
<p><span>　val　penguin=new　Penguin</span></p>
<p><span>　penguin.swim</span></p>
<p><span>　val　atthis=new　Atthis</span></p>
<p><span>　atthis.fly</span></p>
<p><span>　atthis.swim</span></p>
<p>}</p>
<p>}</p>
<p><span>abstract　class　Bird</span></p>
<p><span>trait　Flyable{</span></p>
<p><span> 　def　fly(){</span></p>
<p><span>　println(toString+"がスイスイ飛んでいます。")</span></p>
<p>}</p>
<p>}</p>
<p><span>trait　Swimable{</span></p>
<p><span> 　def　swim(){</span></p>
<p><span>　println(toString+"がスイスイ泳いでいます。")</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Swallow　extends　Bird　with　Flyable{</span></p>
<p><span> 　override　def　toString="つばめ"</span></p>
<p>}</p>
<p><span>class　Penguin　extends　Bird　with　Swimable{</span></p>
<p><span> 　override　def　toString="ペンギン"</span></p>
<p>}</p>
<p><span>class　Atthis　extends　Bird　</span></p>
<p><span>　with　Flyable　with　Swimable{</span></p>
<p><span> 　override　def　toString="カワセミ"</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample40]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>つばめがスイスイ飛んでいます。</span></p>
<p><span>ペンギンがスイスイ泳いでいます。</span></p>
<p><span>カワセミがスイスイ飛んでいます。</span></p>
<p><span>カワセミがスイスイ泳いでいます。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は鳥についてクラス設計してみました。まず「鳥」とは抽象的な存在という意味で抽象クラスにし、そのサブクラスでつばめ、ペンギン、カワセミという３つの具象クラスを定義しました。</span></p>
<p><span>次に、飛行可能を表現するFlyableトレイトと、水泳可能を表現するSwimableトレイトを定義しました。それぞれのトレイトには飛ぶことを表現するメソッドflyと、泳ぐことを表現するメソッドswimが定義されており、そのトレイトをミックスインしたクラスはそれらのメソッドを実行することが可能となるわけです。</span></p>
<p>
<div id="calibre_link-348"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-23">
<div>
<h2 id="calibre_link-349"><b><a id="calibre_link-150"><b><span><b>4-08　トレイトの演習問題</b></span></b></a></b></h2><p><span>Practice19シングルトンオブジェクトは完成しています。(変更しないでください)</span></p>
<p><span>次の指示に従って、ボタンButtonクラスとカウンターCounterトレイト、カウントするボタンCountButtonクラスを完成させてください。</span></p>
<p>&nbsp;</p>
<p><span>[Buttonクラス]</span></p>
<p><span>１．このクラスはただ押すだけのシンプルなボタンを表現します。</span></p>
<p><span>２．押すことを表現するpushメソッド（引数・結果値なし）を定義します。「ボタンを押しました。」と出力するだけです。</span></p>
<p>&nbsp;</p>
<p><span>[Counterトレイト]</span></p>
<p><span>１．このトレイトは回数をカウントするだけのシンプルな機能を提供します。</span></p>
<p><span>２．privateなvarフィールドcount(Int型)を定義します。0で初期化します。</span></p>
<p><span>３．カウントを１増加するincrementCountメソッド（引数・結果値なし）を定義します。フィールドcountの値をインクリメントします。</span></p>
<p><span>４．カウントの値を取得するgetCountメソッド（引数なし・結果型Int型）を定義します。結果値としてフィールドcountの値を返します。</span></p>
<p>&nbsp;</p>
<p><span>[CountButtonクラス]</span></p>
<p><span>１．このクラスは押した回数をカウントするボタンを表現します。Buttonクラスを継承し、Counterトレイトをミックスインします。</span></p>
<p><span>２．pushメソッドをオーバーライドします。処理としては、まずスーパークラスのpushメソッドを呼び出し、次にincrementCountメソッドを呼び出します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice19]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>ボタンを押しました。</span></p>
<p><span>ボタンを押しました。</span></p>
<p><span>ボタンを押しました。</span></p>
<p><span>ボタンを押した回数：3</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice19]トレイトの演習問題(Practice19.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice19{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　button=new　CountButton</span></p>
<p><span>　button.push()</span></p>
<p><span>　button.push()</span></p>
<p><span>　button.push()</span></p>
<p><span>　println("ボタンを押した回数："+button.getCount)</span></p>
<p>}</p>
<p>}</p><p><span>//　ここにButtonクラスとCounterトレイト、</span></p>
<p><span>//　CountButtonクラスを定義してください</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-350"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-74">
<div>
<h1 id="calibre_link-351"><b><a id="calibre_link-151"><b><span><b><u>第５章　高度なテクニック</u></b></span></b></a></b></h1><p>
<div id="calibre_link-352"></div>
</p>
 
   


</div>
</div>
<div id="calibre_link-10">
<div>
<p>
<br id="calibre_link-353" /></p>
 
   


<h3><b><a id="calibre_link-152"><b><span><b>5-01　さまざまなメソッド</b></span></b></a></b></h3><p><span>「2-01型とリテラル」でお話しましたが、Scalaには９種類の「基本型」が存在します。Byte、Short、Int、Long、Char、Float、Double、Boolean、Stringの９つです。そして、これら９つの基本型には「リテラル」が存在します。「リテラル」とは、コードに直接記述するデータそのもののことです。</span></p>
<p><span>ここで知っておいて頂きたいことは、リテラルもクラスのインスタンスだということです。たとえば整数の「1」というリテラルは、「1」という値を持つIntクラスのインスタンスだということです。「3.14」「true」「"Hello"」も同様に、それぞれDoubleクラス、Booleanクラス、Stringクラスのインスタンスです。</span></p>
<p><span>よって、最初から有益なメソッドがそれらのクラスに多数定義されています。</span></p>
<p><span>たとえば、「4-07　toStringメソッドのオーバーライド」でお話しましたtoStringメソッドも、すべてのリテラルで実行可能です。また、「2-04　演算子」でお話した算術演算子や比較演算子、論理演算子などはすべてそれぞれのクラスのインスタンスが持つインスタンスメソッドに過ぎません。「1+2」は、「1」という値を持つIntクラスのインスタンスの「+」メソッドの呼び出し、その引数は「2」という値を持つIntクラスのインスタンスといった感じになります。</span></p>
<p><span>それではまず、文字列型と値型を相互に変換するプログラムを見てみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample41]さまざまなメソッドのサンプル１(Sample41.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample41{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　a:String=123.toString</span></p>
<p><span>　val　b:String=3.14.toString</span></p>
<p><span>　val　c:String=true.toString</span></p>
<p><span>　println(a)</span></p>
<p><span>　println(b)</span></p>
<p><span>　println(c)</span></p>
<p><span>　println()</span></p>
<p><span>　val　d:Int="456".toInt</span></p>
<p><span>　val　e:Double="6.28".toDouble</span></p>
<p><span>　val　f:Boolean="false".toBoolean</span></p>
<p><span>　println(d)</span></p>
<p><span>　println(e)</span></p>
<p><span>　println(f)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample41]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>123</span></p>
<p><span>3.14</span></p>
<p><span>true</span></p>
<p>&nbsp;</p>
<p><span>456</span></p>
<p><span>6.28</span></p>
<p><span>false</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のプログラムはあくまで学習用なので、少し不自然ですがその点だけ留意してください。まず、３つのString型参照変数a、b、cを宣言しています。String型参照変数ですから、String型の値しか代入できません。そこに「123」「3.14」「true」というInt型、Double型、Boolean型のリテラルを代入しようとしています。そのままでは当然型が異なるという理由でコンパイルエラーになるのですが、リテラルの後ろで「toString」メソッドを呼び出しています。少し違和感があるかもしれませんが、正当な記述です。それは、リテラルもクラスのインスタンスだからです。メソッド呼出し後の結果値がString型になるわけですから、問題なく代入することが可能です。</span></p>
<p><span>今回はInt型、Double型、Boolean型だけを例に出しましたが、他の値型（Byte、Short、Long、Float、Char）でも同様です。</span></p>
<p><span>次は反対に、文字列を値型に変換しています。３つの参照変数d、e、fをそれぞれInt型、Double型、Boolean型で宣言しています。なので、文字列リテラル「"456"」「"6.28"」「"false"」は型が異なるので代入できません。しかし、Stringクラス（正確には暗黙の型変換によるStringOpsクラス）にはその文字列を値型に変換するためのtoInt、toDouble、toBooleanメソッドが用意されています。その結果型はそれぞれInt型、Double型、Boolean型なので代入が可能になります。</span></p>
<p><span>その他の値型のために、toByte、toShort、toLong、toFloatメソッドも用意されています。</span></p>
<p><span>ただし、不正な変換、たとえば文字列「"ABC"」に対してtoIntメソッドを呼び出すと、コンパイルは通りますが実行時にプログラムがストップしてしまいます。Scalaでは、プログラム実行時のトラブルのことを「例外」と呼びます（後述）。</span></p>
<p><span>他にも、Stringクラスが持つ便利なメソッドを紹介します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Stringクラスが持つ便利なメソッド一覧（抜粋）]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>メソッド名</span></p>
</td> 
<td>
<p><span>機能</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>length</span></p>
</td> 
<td>
<p><span>文字列の長さを取得する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>charAt</span></p>
</td> 
<td>
<p><span>指定されたインデックス位置にあるCharを取得する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>indexOf</span></p>
</td> 
<td>
<p><span>指定された部分文字列が最初に出現する位置のインデックス番号を取得する（見つからない場合は-1を返す）</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>substring</span></p>
</td> 
<td>
<p><span>文字列の部分を切り取る</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>replaceAll</span></p>
</td> 
<td>
<p><span>文字列を一括置換する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>equalsIgnoreCase</span></p>
</td> 
<td>
<p><span>大文字小文字関係なく等値をチェックする</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>contains</span></p>
</td> 
<td>
<p><span>対象文字列を含むか調査する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>toUpperCase</span></p>
</td> 
<td>
<p><span>すべて大文字に変換する</span></p>
</td> 
</tr> 
<tr> 
<td>
<p><span>toLowerCase</span></p>
</td> 
<td>
<p><span>すべて小文字に変換する</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample42]さまざまなメソッドのサンプル２(Sample42.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample42{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　str="Hello　Scala!"</span></p>
<p><span>　println("str-&gt;"+str)</span></p>
<p><span>　println("str.length-&gt;"+str.length)</span></p>
<p><span>　println("str.charAt(2)-&gt;"+str.charAt(2))</span><span>println("str.indexOf(¥"ca¥")-&gt;"+str.indexOf("ca"))</span><span>println("str.indexOf(¥"Ca¥")-&gt;"+str.indexOf("Ca"))</span><span>println("str.substring(2,　5)-&gt;"+str.substring(2,　5))</span><span>println("str.replaceAll(¥"a¥",¥"A¥")-&gt;"+str.replaceAll("a","A"))</span><span>println("str==¥"hello　scala!¥"-&gt;"+(str=="hello　scala!"))</span><span>println("str.equalsIgnoreCase(¥"hello　scala!¥")-&gt;"+</span></p>
<p><span>　str.equalsIgnoreCase("hello　scala!"))</span></p>
<p><span>　println("str.contains(¥"scala¥")-&gt;"+str.contains("scala"))</span><span>println("str.contains(¥"Scala¥")-&gt;"+str.contains("Scala"))</span><span>println("str.toUpperCase-&gt;"+str.toUpperCase)</span><span>println("str.toLowerCase-&gt;"+str.toLowerCase)</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample42]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>str-&gt;Hello　Scala!</span></p>
<p><span>str.length-&gt;12</span></p>
<p><span>str.charAt(2)-&gt;l</span></p>
<p><span>str.indexOf("ca")-&gt;7</span></p>
<p><span>str.indexOf("Ca")-&gt;-1</span></p>
<p><span>str.substring(2,　5)-&gt;llo</span></p>
<p><span>str.replaceAll("a","A")-&gt;Hello　ScAlA!</span></p>
<p><span>str=="hello　scala!"-&gt;false</span></p>
<p><span>str.equalsIgnoreCase("hello　scala!")-&gt;true</span></p>
<p><span>str.contains("scala")-&gt;false</span></p>
<p><span>str.contains("Scala")-&gt;true</span></p>
<p><span>str.toUpperCase-&gt;HELLO　SCALA!</span></p>
<p><span>str.toLowerCase-&gt;hello　scala!</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>Scalaでは、全角文字、半角文字問わず１文字は１文字として扱われます。たとえば「"Hello"」に対するlengthメソッドの結果値は「5」ですし、「"こんにちは"」に対するlengthメソッドの結果値も「5」になります。</span></p>
<p><span>他にもたくさんのメソッドが用意されていますので、インターネットのScala　API（http://www.scala-lang.org/api/2.11.7/）で調べてみることをおすすめします。</span></p>
<p>
<div id="calibre_link-354"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-57">
<div>
<h2 id="calibre_link-355"><b><a id="calibre_link-153"><b><span><b>5-02　配列</b></span></b></a></b></h2><p><span>Scalaに限らず、ほとんどすべてのプログラミング言語には「配列」という考え方があります。「配列」とは、同じ型の複数のデータを束ねて管理することです。たとえば、１つの変数がある値の居場所〒を入れる箱だとイメージすると、配列はその箱が複数くっついていて、0から順に採番されているようなものです。</span></p>
<p><span>配列では、それぞれの箱のことを「要素」といい、0から順に採番される番号のことを「インデックス番号」といいます。</span></p>
<p><span>ただし、他の多くのプログラミング言語とは異なり、Scalaの配列はArrayクラスのインスタンスという扱いになります。ということは、その配列で複数管理するデータの型が別に必要となりますが、たとえばInt型の配列を表現したい場合はArray[Int]型と記述します。つまり、Array[Int]型は、複数のInt型の値を管理するための配列Array型ということになります。</span></p>
<p><span>この大かっこで囲われた第二の型のことを「型パラメータ」といい、Scalaでは必ず記述しないといけないルールになっています。</span></p>
<p><span>ここで、簡単な配列のサンプルプログラムを実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample43]配列のサンプル(Sample43.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample43{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr:Array[Int]=new　Array[Int](3)</span></p>
<p><span>　arr(0)=123</span></p>
<p><span>　arr(1)=456</span></p>
<p><span>　arr(2)=789</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;arr.length){</span></p>
<p><span>　println(arr(i))</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample43]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>123</span></p>
<p><span>456</span></p>
<p><span>789</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のプログラムの最初の行で、Array[Int]型参照変数arrを宣言し、予約語「new」を使ってArray[Int]クラスのインスタンスを生成しています。基本コンストラクタに渡している「3」という数値は、Int型のデータの要素数が３個という意味です。</span></p>
<p><span>要素数の「3」は、配列インスタンスが持つlengthメソッドで後から取得することもできます（whileループの条件式で実際に使用しています）。この段階では、Int型の３つの要素はすべて整数リテラル0で初期化されています。</span></p>
<p><span>次の３行のプログラムで、３つの要素にそれぞれ異なる値の参照を代入しています。インデックス番号は0から始まるので、2までだという点に注意してください。もし3以上のインデックス番号を指定してしまうと、例外（後述）が発生してプログラムがストップしてしまいます。</span></p>
<p><span>各要素に値を代入するのは簡単で、配列参照変数に丸かっこをつけてインデックス番号を指定し、あとは代入演算子で値を代入するだけです。</span></p>
<p><span>参照変数に直接丸かっこをつけるのはScalaではおなじみのスタイルであり、代入の際はupdateメソッドが暗黙的に呼び出されていると覚えておいてください。つまり、「arr(0)=123」は「arr.update(0,123)」と全く同じ意味になります。また、参照の際はapplyメソッドが暗黙的に呼び出されています。つまり、「println(arr(0))」は「println(arr.apply(0))」と同じ意味です。</span></p>
<p>&nbsp;</p>
<p><span>今回のような初期値が最初から分かっている場合は、Arrayコンパニオンオブジェクトを用いて、次のようにもっと簡潔に記述することもできます。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>val　arr:Array[Int]=Array(123,456,789)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このコンパニオンオブジェクトに直接丸かっこを付加しているのも、結局はArrayコンパニオンオブジェクトが持つapplyメソッドを暗黙的に呼び出しているわけです。つまり、上記コードは下記コードと同じ意味になります。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>val　arr:Array[Int]=Array.apply(123,456,789)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>最後に注意していただきたいのは、valローカル変数arrの指す配列インスタンスの値が変化しているということです。序盤にvarは可変、valは不変と説明しました。一見矛盾しているようですが、それはvalの場合は変数の指すインスタンスが変わらないという意味であり、そのインスタンスの持つデータ（配列の場合なら各要素の値）が変化しないという意味ではありません。インスタンスが持つデータが変化することを「ミュータブル」、インスタンスが持つデータが不変であることを「イミュータブル」といいます。たとえばIntやStringは「イミュータブル」であり、Arrayは「ミュータブル」です。</span></p>
<p>
<div id="calibre_link-356"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-220">
<div>
<h2 id="calibre_link-357"><b><a id="calibre_link-154"><b><span><b>5-02　配列の演習問題</b></span></b></a></b></h2><p><span>Practice20シングルトンオブジェクトは未完成です。</span></p>
<p><span>mainメソッドで定義されているArray[Int]型配列インスタンスのすべての要素を合計して、出力してください。ただし、合計処理にはwhileループをうまく利用すること。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice20]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>配列のすべての要素の合計は777です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice20]配列の演習問題(Practice20.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice20{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(167,218,271,121)</span></p>
<p><span>　//　ここからコーディングしてください</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-358"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-45">
<div>
<h2 id="calibre_link-359"><b><a id="calibre_link-155"><b><span><b>5-03　コマンドライン引数</b></span></b></a></b></h2><p><span>先ほどの節で配列を学習しましたが、それによってずっと保留のままだったある１つの疑問が解消されたと思います。mainメソッドの引数「args:Array[String]」の意味が、Stringの配列だということがようやく分かったということです。このmainメソッドの引数のことを「コマンドライン引数」というのですが、ではこの引数の値は一体どこから渡ってくるのでしょうか？</span></p>
<p>&nbsp;</p>
<p><span>答えは、その名前にあります。「コマンドライン」で渡ってくる引数、つまりコマンドプロンプトで「scala」コマンドを使って実行する時に、自由に文字列を渡すことができるのです。</span></p>
<p>&nbsp;</p>
<p><span><b>[コマンドライン引数の渡し方]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;scala　オブジェクト名　引数１　引数２　引数３　･･･</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このような感じで、半角スペース区切りで複数の文字列を実行時に渡すことができます。その複数の文字列はArray[String]型の値として「args」に格納されます。</span></p>
<p><span>それでは、実際にサンプルを実行してみましょう。</span></p>
<p><span>(実行時は　&gt;scala　Sample44　This　is　a　penと入力してください)</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample44]コマンドライン引数のサンプル(Sample44.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample44{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;args.length){</span></p>
<p><span>　println(args(i))</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample44]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>This</span></p>
<p><span>is</span></p>
<p><span>a</span></p>
<p><span>pen</span></p>
<p>&nbsp;</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このようにして、mainメソッドにいくつでも文字列情報を渡すことが可能です。</span></p>
<p>
<div id="calibre_link-360"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-203">
<div>
<h2 id="calibre_link-361"><b><a id="calibre_link-156"><b><span><b>5-03　コマンドライン引数の演習問題</b></span></b></a></b></h2><p><span>Practice21シングルトンオブジェクトは未完成です。</span></p>
<p><span>コマンドライン引数で渡ってくる２つの数値を加算して、その結果を出力してください。ただし、コマンドライン引数が不正な場合は考慮しなくていいものとします。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice21]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;scala　Practice21　4　8</span></p>
<p><span>4+8=12</span></p>
<p><span>&gt;scala　Practice21　14　65</span></p>
<p><span>14+65=79</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice21]コマンドライン引数の演習問題(Practice21.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice21{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　//ここからコーディングしてください</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p>
<div id="calibre_link-362"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-31">
<div>
<h2 id="calibre_link-363"><b><a id="calibre_link-157"><b><span><b>5-04　タプル</b></span></b></a></b></h2><p><span>配列は、同じ型の複数のデータをまとめて扱う技術でした。Scalaでは、異なる型のデータをひとまとまりに取り扱うこともできます。それを「タプル」といいます。</span></p>
<p><span>タプルの生成方法はとても簡単で、型の異なる複数のデータを丸かっこで囲い、それぞれをカンマ区切りすればTupleNクラスのインスタンスが自動的に生成されます。（Nの部分には実際には整数が入ります）</span></p>
<p><span>そして、各要素には「_N」（Nは1からの連番）フィールドにアクセスすることで値を取得できます。配列のインデックス番号は0から始まりますが、タプルは1から始まるので注意が必要です。</span></p>
<p><span>それでは、次のサンプルプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample45]タプルのサンプル(Sample45.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample45{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　tuple=(123,"Hello",true,3.14)</span></p>
<p><span>　println(tuple._1)</span></p>
<p><span>　println(tuple._2)</span></p>
<p><span>　println(tuple._3)</span></p>
<p><span>　println(tuple._4)</span></p>
<p><span>　val　arr=Array(23,19,46,53,38)</span></p>
<p><span>　val　(max,min)=maxmin(arr)</span></p>
<p><span>　println("Max　Value:"+max)</span></p>
<p><span>　println("Min　Value:"+min)</span></p>
<p>}</p>
<p><span> 　def　maxmin(arr:Array[Int])={</span></p>
<p><span>　var　max=arr(0)</span></p>
<p><span>　var　min=arr(0)</span></p>
<p><span>　var　i=1</span></p>
<p><span>　while(i&lt;arr.length){</span></p>
<p><span>　max=if(max&gt;arr(i))max　else　arr(i)</span></p>
<p><span>　min=if(min&lt;arr(i))min　else　arr(i)</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p><span>　(max,min)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample45]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>123</span></p>
<p><span>Hello</span></p>
<p><span>true</span></p>
<p><span>3.14</span></p>
<p><span>Max　Value　:　53</span></p>
<p><span>Min　Value　:　19</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まず始めに、タプルを生成する記述「val　tuple=(123,"Hello",true,3.14)」があります。これで異なる型の４つのデータを保持するTuple4インスタンスが自動生成されます。その後は「tuple._1」といった感じでフィールドにアクセスします。</span></p>
<p><span>タプルの便利な使い方として、メソッドの結果値を複数返せることが挙げられます。</span></p>
<p><span>maxminメソッドは、引数で渡ってきたArray[Int]型の値の中から、最大のものと最小のものを抽出して結果値として返すメソッドです。最大値と最小値、複数の値を返すわけですから、タプルが適しています。</span></p>
<p><span>ポイントは、メソッドの結果値を変数で受け取る際に「val　(max,min)=maxmin(arr)」と記述することで、タプルの値を分解してそれぞれmax変数とmin変数に代入できることです。タプルを使用する際は、このテクニックは非常に有効なのでぜひマスターしてください。</span></p>
<p>
<div id="calibre_link-364"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-24">
<div>
<h2 id="calibre_link-365"><b><a id="calibre_link-158"><b><span><b>5-04　タプルの演習問題</b></span></b></a></b></h2><p><span>Practice22シングルトンオブジェクトのmainメソッドは完成しています。（変更しないでください）</span></p>
<p><span>Int配列インスタンスを受け取って、配列の要素の合計値と平均値の２つを結果値として返すsumAverageメソッドを定義してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice22]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>配列の要素の合計：287</span></p>
<p><span>配列の要素の平均：57.4</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice22]タプルの演習問題(Practice22.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice22{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(13,48,93,52,81)</span></p>
<p><span>　val　(sum,average)=sumAverage(arr)</span></p>
<p><span>　println("配列の要素の合計："+sum)</span></p>
<p><span>　println("配列の要素の平均："+average)</span></p>
<p>}</p>
<p><span> 　//ここにsumAverageメソッドを作成してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p>
<div id="calibre_link-366"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-44">
<div>
<h2 id="calibre_link-367"><b><a id="calibre_link-159"><b><span><b>5-05　List</b></span></b></a></b></h2><p><span>配列は「ミュータブル」ですが、その「イミュータブル」版がListになります。配列と同様、Listにも大かっこを用いた型パラメータの指定が必須になります。Listコンパニオンオブジェクトを用いて、値を初期化したインスタンスを取得します。一度初期化すると、後から要素の値を変更できません。そこが配列との大きな違いです。</span></p>
<p><span>では、簡単なListのサンプルプログラムを実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample46]Listのサンプル１(Sample46.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample46{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list:List[String]=List("A","B","C")</span><span>//list(0)="D"</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;list.length){</span></p>
<p><span>　println(list(i))</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample46]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>A</span></p>
<p><span>B</span></p>
<p><span>C</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まずはListコンパニオンオブジェクトを用いて、指定した値で初期化したListインスタンスを取得しています。配列と違って後から要素の値を変更することはできませんから、コメントアウトしている「list(0)="D"」のコメントをはずすとコンパイルエラーになります。</span></p>
<p>&nbsp;</p>
<p><span>List自体はイミュータブルですが、Listインスタンスと値を結合して、あるいはListインスタンスとListインスタンスを結合して、新しいListインスタンスを生成することは可能です。その場合、「::」または「:::」という特殊な演算子（実際はメソッド）を用います。</span></p>
<p><span>そのサンプルプログラムを以下に示します。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample47]Listのサンプル２(Sample47.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample47{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list1=List(3,4,5)</span></p>
<p><span>　val　list2=List(6,7,8)</span></p>
<p><span>　println("list1:"+list1)</span></p>
<p><span>　println("list2:"+list2)</span></p>
<p><span>　val　list3=list1:::list2</span></p>
<p><span>　println("list3:"+list3)</span></p>
<p><span>　val　list4=1::2::list3</span></p>
<p><span>　println("list4:"+list4)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample47]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>list1:List(3,　4,　5)</span></p>
<p><span>list2:List(6,　7,　8)</span></p>
<p><span>list3:List(3,　4,　5,　6,　7,　8)</span></p>
<p><span>list4:List(1,　2,　3,　4,　5,　6,　7,　8)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はローカル変数宣言時に型推論を用いて、型の指定を省略しています。</span></p>
<p><span>Listはイミュータブルですが、ListとListを連結して新しいListを生成できます。そのための演算子が「:::」です。この演算子は少し変わっていて、「:::」の右側にあるListインスタンスのメソッドになります。つまり、「list1:::list2」は「list2.:::(list1)」と同じ意味になります。これで、list1とlist2の要素を連結した、新しいListインスタンスが生成されます。</span></p>
<p><span>Listの先頭に要素を追加して、新しいListを生成できます。そのための演算子が「::」です。この「::」の演算子のことを「コンス」といいます。コンスもその右側にあるListインスタンスのメソッドになります。つまり、「1::2::list3」は「list3.::(2).::(1)」と同じ意味になります。これで、list3の先頭に「1」と「2」という要素が追加された新しいListインスタンスが生成されます。</span></p>
<p>
<div id="calibre_link-368"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-58">
<div>
<h2 id="calibre_link-369"><b><a id="calibre_link-160"><b><span><b>5-05　Listの演習問題</b></span></b></a></b></h2><p><span>Practice23シングルトンオブジェクトのmainメソッドは完成しています。（変更しないでください）</span></p>
<p><span>List[Int]型インスタンスを受け取って、要素の値が偶数の個数をカウントして結果値として返すcountEvenメソッドを定義してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice23]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>Listの偶数の個数：3</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice23]Listの演習問題(Practice23.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice23{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list=List(5,13,6,9,18,2,21,1)</span></p>
<p><span>　println("Listの偶数の個数："+countEven(list))</span></p>
<p>}</p>
<p><span> 　//ここにcountEvenメソッドを作成してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-370"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-4">
<div>
<h2 id="calibre_link-371"><b><a id="calibre_link-161"><b><span><b>5-06　for式</b></span></b></a></b></h2><p><span>Scalaには繰り返し構文「whileループ」「do-whileループ」の他に「for式」があります。「for式」はArrayやListなどの「コレクション」と呼ばれるデータ構造に対して反復処理する際に非常に便利です。また、「for式」には非常に高度な用法が多数用意されています。「for式」は基本的に予約語「for」「&lt;-」の２つを用います。</span></p>
<p>&nbsp;</p>
<p><span><b>[for式の基本構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>for(変数　&lt;-　コレクション参照変数){</span></p>
<p><span> 　繰り返したい処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>コレクション参照変数はたくさんのデータを保持しているので、その１つ目のデータが「&lt;-」の左前の変数に格納されてループを回り、今度は２つ目のデータが変数に格納されてループを回り......、をコレクションの要素数分繰り返すわけです。</span></p>
<p><span>このfor式の丸かっこの「変数&lt;-コレクション参照変数」の部分は「ジェネレーター」と呼ばれます。また、ジェネレーターの変数は必ずval変数になります。しかし、valを付加することはできませんので注意しましょう。</span></p>
<p><span>まずは、基本的なサンプルプログラムをコーディング・実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample48]for式のサンプル１(Sample48.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample48{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(12,34,56)</span></p>
<p><span>　for(x&lt;-arr){</span></p>
<p><span>　println(x)</span></p>
<p>}</p>
<p><span>　val　list=List("AB","CD","EF")</span><span>for(str&lt;-list){</span></p>
<p><span>　println(str)</span></p>
<p>}</p>
<p><span>　for(i&lt;-1　to　5){</span></p>
<p><span>　println(i)</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample48]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>12</span></p>
<p><span>34</span></p>
<p><span>56</span></p>
<p><span>AB</span></p>
<p><span>CD</span></p>
<p><span>EF</span></p>
<p><span>1</span></p>
<p><span>2</span></p>
<p><span>3</span></p>
<p><span>4</span></p>
<p><span>5</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>最初のfor式のジェネレーター「&lt;-」の右後ろのval変数arrはArray[Int]型なので、「&lt;-」の左前の変数は型推論からInt型になります。２つ目のfor式のジェネレーター「&lt;-」の右後ろのval変数listはList[String]型なので、「&lt;-」の左前の変数は型推論からString型になります。</span></p>
<p><span>３つ目のfor式は、少し特殊なように見えるかもしれません。ジェネレーターの「&lt;-」の右後ろに記述されている「1　to　5」は、「1」という値を持つInt型インスタンスの「to」メソッドの呼び出しであり、その引数は「5」という値を持つInt型インスタンスです。その結果型は、Range型というコレクションで、「1,2,3,4,5」という値を保持しています。また、ジェネレーター「&lt;-」の左前の変数は実質val変数なので、for式のブロック内で値を変更することはできません。</span></p>
<p>&nbsp;</p>
<p><span>for式ではコレクションのすべての要素を処理するのではなく、「フィルタ」という機能を用いてある条件を満たす値だけを抽出することもできます。</span></p>
<p>&nbsp;</p>
<p><span><b>[フィルタを用いたfor式の構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>for(変数　&lt;-　コレクション参照変数　if　抽出条件){</span></p>
<p><span> 　繰り返したい処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>ジェネレーターの右後ろのifの抽出条件がtrueの要素のみ処理することができます。もちろん、for式のブロック内にif式を記述しても同様のことは可能ですが、フィルタを用いることで簡潔に記述することが可能です。</span></p>
<p><span>では、フィルタを用いたサンプルプログラムをコーディング・実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample49]for式のサンプル２(Sample49.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample49{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(1,4,7,10,13,16)</span></p>
<p><span>　for(x&lt;-arr　if　x%2==0){</span></p>
<p><span>　println(x)</span></p>
<p>}</p>
<p><span>　println()</span></p>
<p><span>　for(x&lt;-arr　if　x%2!=0　if　x&lt;10){</span></p>
<p><span>　println(x)</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample49]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>4</span></p>
<p><span>10</span></p>
<p><span>16</span></p>
<p>&nbsp;</p>
<p><span>1</span></p>
<p><span>7</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まず、「1,4,7,10,13,16」という値を持つArray[Int]型のインスタンス参照変数arrが宣言してあります。</span></p>
<p><span>最初のfor式は変数arrに対してループを行っています。ただし、ジェネレーターの右後ろにフィルタ「if　x%2==0」を追加しています。「2で割った余りが0」、つまり偶数の数値のみ出力しています。</span></p>
<p><span>ちなみに２つ目のfor式のように、フィルタは複数記述することもできます。フィルタに「if　x%2!=0」と「if　x&lt;10」の２つの条件を付加していますので、「奇数でかつ10未満」の値のみ出力されます。</span></p>
<p>&nbsp;</p>
<p><span>１つのfor式でジェネレーターを複数記述することもできます。ジェネレーターを複数記述したい場合は、各ジェネレーターの区切り目にセミコロンが必要になります。それが嫌であれば、ジェネレーターを囲う丸かっこを中かっこに変えて、改行を入れることでも解決できます。</span></p>
<p>&nbsp;</p>
<p><span><b>[複数のジェネレーターを用いたfor式の構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>for(ジェネレーター１;</span></p>
<p><span>　　ジェネレーター２){</span></p>
<p><span> 　繰り返したい処理</span></p>
<p>}</p>
<p><span>または</span></p>
<p><span>for{ジェネレーター１</span></p>
<p><span>　ジェネレーター２}{</span></p>
<p><span> 　繰り返したい処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このジェネレーターを複数記述する構文は、意味的には以下と同じです。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>for(ジェネレーター１){</span></p>
<p><span> 　for(ジェネレーター２){</span></p>
<p><span> 　 　繰り返したい処理</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>では、ジェネレーターを複数記述するサンプルプログラムを実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample50]for式のサンプル３(Sample50.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample50{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　for(i&lt;-1　to　3　;</span></p>
<p><span>　j&lt;-4　to　6){</span></p>
<p><span>　println(i+":"+j)</span></p>
<p>}</p>
<p><span>　/*こちらでも良い</span></p>
<p><span>　for{i&lt;-1　to　3</span></p>
<p><span>　j&lt;-4　to　6}{</span></p>
<p><span>　println(i+":"+j)</span></p>
<p>}</p>
<p>*/</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample50]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>1　:　4</span></p>
<p><span>1　:　5</span></p>
<p><span>1　:　6</span></p>
<p><span>2　:　4</span></p>
<p><span>2　:　5</span></p>
<p><span>2　:　6</span></p>
<p><span>3　:　4</span></p>
<p><span>3　:　5</span></p>
<p><span>3　:　6</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>出力結果をよく見ていただきたいのですが、１つ目のジェネレーターの１回目で、２つ目のジェネレーターのループが３回行われています。その結果、３×３の９行のデータが出力されるわけです。</span></p>
<p>&nbsp;</p>
<p><span>if式と同様に、for式は値を返すことができます。if式は単一の値を返しますが、for式は新たなコレクションを生成して返すことができます。for式で値を返したい場合は、予約語「yield」をfor式のジェネレーターを記述する丸かっこ（もしくは中かっこ）の右後ろに記述します。ブロックの中の処理として値だけを記述し、その値が蓄積されて新しいコレクションインスタンスになるイメージです。</span></p>
<p>&nbsp;</p>
<p><span><b>[値を返すfor式の構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>for(変数&lt;-コレクション参照変数)yield{</span></p>
<p><span> 　蓄積したい値</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>どのコレクションが新たに生成されるかは、ジェネレーターの「&lt;-」の右後ろのコレクションの型に依存します。</span></p>
<p><span>それでは、for式の最後のサンプルプログラムを実行してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample51]for式のサンプル４(Sample51.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample51{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　oldlist=List(1,2,3,4,5,6)</span></p>
<p><span>　val　newlist=for(x&lt;-oldlist)yield{x*x}</span></p>
<p><span>　println("New　List:"+newlist)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample51]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>New　List:List(1,　4,　9,　16,　25,　36)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は「1,2,3,4,5,6」という値を持ったListを元に、それらの値を２乗した新しいListを生成しています。for式は値を返すので、その値をval変数で受け取っています。ポイントは予約語「yield」で、これがないと値が蓄積された新しいコレクションが生成されません。</span></p>
<p><span>今回のfor式を学習する前は、配列やListをwhileループで走査していました。しかし、Scalaではwhileループやdo-whileループよりfor式を使用することを推奨しています。これからはそのことを意識してコーディングしていきましょう。</span></p>
<p>
<div id="calibre_link-372"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-37">
<div>
<h2 id="calibre_link-373"><b><a id="calibre_link-162"><b><span><b>5-06　for式の演習問題</b></span></b></a></b></h2><p><span>Practice24シングルトンオブジェクトのmainメソッドは完成しています。（変更しないでください）</span></p>
<p><span>List[Int]型インスタンスを受け取って、要素の値が0以上のものを抽出して再びList[Int]型インスタンスを生成して結果値として返すchoosePlusメソッドを定義してください。ただし、for式を適切に使用すること。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice24]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>正の数を抽出したList：List(3,　0,　2,　8)</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice24]for式の演習問題(Practice24.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice24{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list=List(3,-5,0,-7,2,8,-1)</span></p>
<p><span>　val　newlist=choosePlus(list)</span></p>
<p><span>　println("正の数を抽出したList："+newlist)</span></p>
<p>}</p>
<p><span> 　//ここにchoosePlusメソッドを作成してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-374"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-25">
<div>
<h2 id="calibre_link-375"><b><a id="calibre_link-163"><b><span><b>5-07　match式</b></span></b></a></b></h2><p><span>Scalaには条件分岐を行うための言語構文として「if式」がありますが、他にも条件に応じた多分岐を行うための言語構文として「match式」があります。</span></p>
<p><span>「match式」は「match」「case」「=&gt;」の３つの予約語を使って構成します。</span></p>
<p>&nbsp;</p>
<p><span><b>[match式の基本構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>変数　match{</span></p>
<p><span> 　case　値１　=&gt;　処理１</span></p>
<p><span> 　case　値２　=&gt;　処理２</span></p>
<p><span> 　case　_　=&gt;　その他の処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>たとえば、変数の値とcaseの値１が一致する場合、処理１を行います。同様に、変数の値とcaseの値２が一致する場合、処理２を行います。「case」の後には、あらゆる型の値を記述することができます。</span></p>
<p><span>「case　_」は上記caseのどの値とも一致しない場合に行う処理を記述します。「if式」の「else」と同じようなものです。</span></p>
<p><span>また、「match式」は「if式」や「for式」と同様に、値を返すことができます。予約語「=&gt;」の後に処理を書かずに、値を記述すればそれを返すことができます。</span></p>
<p>&nbsp;</p>
<p><span>match式を用いて値を返すサンプルプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample52]match式のサンプル(Sample52.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample52{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　season="summer"</span></p>
<p><span>　val　seasonjp=season　match{</span></p>
<p><span>　case　"spring"=&gt;"春"</span></p>
<p><span>　case　"summer"=&gt;"夏"</span></p>
<p><span>　case　"autumn"=&gt;"秋"</span></p>
<p><span>　case　"winter"=&gt;"冬"</span></p>
<p><span>　case　_      　=&gt;"？"</span></p>
<p>}</p>
<p><span>　println("英語の"+season+</span></p>
<p><span>　"は日本語で"+seasonjp+"です。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample52]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>英語のsummerは日本語で夏です。</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>val変数seasonには季節を表現する英単語が格納されています。それを、match式を用いて日本語に変換しています。</span></p>
<p><span>match式の左辺に、val変数seasonjpが宣言されているのがポイントです。変数seasonの値と、caseの後の値が一致した場合に「=&gt;」の右後ろの値が変数seasonjpに格納されます。もし一致するものがなければ、「case　_」の「？」が格納されます。</span></p>
<p><span>今回はmatch式の基本的な文法だけを紹介しましたが、match式には非常に高度な用法も多数用意されています。</span></p>
<p>
<div id="calibre_link-376"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-67">
<div>
<h2 id="calibre_link-377"><b><a id="calibre_link-164"><b><span><b>5-07　match式の演習問題</b></span></b></a></b></h2><p><span>Practice25シングルトンオブジェクトのmainメソッドは完成しています。（変更しないでください）</span></p>
<p><span>第一、第二引数にInt型の値を受け取り、第三引数の四則演算記号に沿った演算結果の値を結果値として返すcalculateメソッドを定義してください。ただし、calculate　メソッドの内部処理にはmatch式を使用し、第三引数の演算記号が不正の場合は無条件に0を返すものとします。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice25]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>8+4=12</span></p>
<p><span>8-4=4</span></p>
<p><span>8*4=32</span></p>
<p><span>8/4=2</span></p>
<p><span>8?4=0</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice25]match式の演習問題(Practice25.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice25{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("8+4="+calculate(8,4,"+"))</span><span>println("8-4="+calculate(8,4,"-"))</span><span>println("8*4="+calculate(8,4,"*"))</span><span>println("8/4="+calculate(8,4,"/"))</span><span>println("8?4="+calculate(8,4,"?"))</span><span>}</span></p>
<p><span> 　//　ここにcalculateメソッドを作成してください</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-378"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-214">
<div>
<h2 id="calibre_link-379"><b><a id="calibre_link-165"><b><span><b>5-08　例外処理try式</b></span></b></a></b></h2><p><span>コンパイルはきちんと通るのに、いざ実行するとプログラムがストップしてしまうことがあります。このことを「例外がスローされる」といいます。しかし、そう簡単にプログラムが止まってしまってはいけないケースは多々あります。たとえば、実際に運用しているシステムなどがそうです。</span></p>
<p><span>例外がスローされても、プログラムをストップさせることなく対応することが可能です。それを「例外処理」といいます。「例外処理」には「try式」を使用します。</span></p>
<p><span>「try式」は予約語「try」「catch」「finally」を用いて組み立てます。</span></p>
<p>&nbsp;</p>
<p><span><b>[例外処理の構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>try{</span></p>
<p><span> 　例外がスローされる可能性のある処理</span></p>
<p>}</p>
<p><span>catch{</span></p>
<p><span> 　case　ex:例外クラス１=&gt;例外対応処理１</span></p>
<p><span> 　case　ex:例外クラス２=&gt;例外対応処理２</span></p>
<p>}</p>
<p><span>finally{</span></p>
<p><span> 　後始末処理</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>「try」ブロックの中には、例外がスローされる可能性のある処理を記述します。もし例外がスローされたら、その例外を「catch」ブロックで捕まえようとします。</span></p>
<p><span>実は、スローされる例外もクラスのインスタンスであり、例外クラスとしての型があります。</span></p>
<p><span>caseの例外クラス型と一致すれば、「=&gt;」の右後ろの処理を行います。その後は、プログラムはストップすることはありません。もし「catch」ブロックで例外を捕捉できなかった場合は、メソッド呼び出し元を辿っていきます。最後まで捕捉できなければ、プログラムはストップします。</span></p>
<p><span>最後の「finally」ブロックは、例外がスローされてもされなくても、必ず実行されます。ファイルやデータベースのリソース開放などによく用いられます。</span></p>
<p><span>try式もif式やfor式と同様に、値を返すことができます。もし例外がスローされなければ「try」ブロックの最後の値が、例外がスローされればそれを捕捉したcaseの「=&gt;」の右後ろの値が採用されます。</span></p>
<p><span>それでは、次のサンプルプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample53]例外処理のサンプル(Sample53.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample53{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　result=</span></p>
<p><span>　try{</span></p>
<p><span>　val　x=args(0)</span></p>
<p><span>　val　y=x.toInt</span></p>
<p><span>　val　z=y*5</span></p>
<p><span>　y+"に5を掛けた値は"+z</span></p>
<p>}</p>
<p><span>　catch{</span></p>
<p><span>　case　ex:ArrayIndexOutOfBoundsException=&gt;</span></p>
<p><span>　"コマンドライン引数なし"</span></p>
<p><span>　case　ex:NumberFormatException=&gt;</span></p>
<p><span>　"不正な文字列"</span></p>
<p>}</p>
<p><span>　finally{</span></p>
<p><span>　println("finally処理")</span></p>
<p>}</p>
<p><span>　println(result)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample53]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;scala　Sample53</span></p>
<p><span>finally処理</span></p>
<p><span>コマンドライン引数なし</span></p>
<p>&nbsp;</p>
<p><span>&gt;scala　Sample53　abc</span></p>
<p><span>finally処理</span></p>
<p><span>不正な文字列</span></p>
<p>&nbsp;</p>
<p><span>&gt;scala　Sample53　10</span></p>
<p><span>finally処理</span></p>
<p><span>10に5を掛けた値は50</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>try式を使って、適切に例外対応を行っています。tryブロックの中では「コマンドライン引数を受け取る」「受け取った値を整数変換する」「その値に５を掛ける」という３つの処理を行っています。</span></p>
<p><span>コマンドライン引数がない場合には「ArrayIndexOutOfBoundsException」例外が、整数変換に失敗した場合には「NumberFormatException」例外がそれぞれスローされますので、catchブロックで例外を捕捉してエラーメッセージを返しています。</span></p>
<p><span>もし例外がスローされなければ、tryブロックの最後の値が返されて、valローカル変数resultに代入されます。</span></p>
<p><span>finallyブロックの処理は例外がスローされてもされなくても実行されている点に注意してください。</span></p>
<p>
<div id="calibre_link-380"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-207">
<div>
<h2 id="calibre_link-381"><b><a id="calibre_link-166"><b><span><b>5-08　例外処理try式の演習問題</b></span></b></a></b></h2><p><span>Practice26シングルトンオブジェクトは一応完成していますが、不完全です。</span></p>
<p><span>このプログラムは、割り算を行うdivideメソッドを用いて４つの割り算を計算しています。コンパイル・実行すると、３つ目で０による割り算のためArithmeticException例外がスローされ、大量のエラーメッセージを出力して処理がストップします。</span></p>
<p><span>そこで、mainメソッドを改良して０による割り算が行われた場合は「0割が発生しました！」とだけ出力して速やかに処理を終了するようにしてください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice26]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>[1]28/7=4</span></p>
<p><span>[2]72/8=9</span></p>
<p><span>0割が発生しました！</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice26]例外処理try式の演習問題(Practice26.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice26{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("[1]28/7="+divide(28,7))</span></p>
<p><span>　println("[2]72/8="+divide(72,8))</span></p>
<p><span>　println("[3]44/0="+divide(44,0))</span></p>
<p><span>　println("[4]54/6="+divide(54,6))</span></p>
<p>}</p>
<p><span> 　def　divide(x:Int,y:Int)={</span></p>
<p><span>　x/y</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-382"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-1">
<div>
<h2 id="calibre_link-383"><b><a id="calibre_link-167"><b><span><b>5-09　関数リテラルと関数値</b></span></b></a></b></h2><p><span>オブジェクトやクラス、トレイトがメンバとして持つ「処理のひとまとまり」のことを「メソッド」と呼びました。Scalaでは、もっと大きな意味で、「処理のひとまとまり」のことを「関数」と呼びます。つまり「メソッド」とは、クラスなどのメンバとしての「関数」のことです。</span></p>
<p><span>Scalaは、関数をリテラルとして記述することができます。これを「関数リテラル」といいます。</span></p>
<p>&nbsp;</p>
<p><span><b>[関数リテラルの構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>(引数リスト)　=&gt;　関数本体</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>「関数リテラル」はいわば設計図であり、ソースファイルのコンパイル後は実際にはクラスに変換されます。実行時はそのクラスがインスタンス化され、ひとつの値という扱いになります。それを「値としての関数」という意味で「関数値」といいます。</span></p>
<p><span>「関数値」は変数に代入したり、関数の引数として渡したり、関数実行後の結果値として返すこともできます。</span></p>
<p><span>それでは、関数リテラルと関数値のサンプルプログラムをコーディングしてみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample54]関数リテラルと関数値のサンプル(Sample54.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Sample54{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　sum=(x:Int,y:Int)=&gt;x+y</span></p>
<p><span>　val　multiply=(x:Int,y:Int)=&gt;x*y</span></p>
<p><span>　println("1+2="+sum(1,2))</span></p>
<p><span>　println("3*4="+multiply(3,4))</span></p>
<p><span>　println("5+6="+calc(sum))</span></p>
<p>}</p>
<p><span> 　def　calc(func:(Int,Int)=&gt;Int)=func(5,6)</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample54]　実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>1+2=3</span></p>
<p><span>3*4=12</span></p>
<p><span>5+6=11</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まず２つのval変数sumとmultiplyを定義しています。変数sumの値は「Int型の引数を２つ受け取って合計を返す関数そのもの」であり、変数multiplyの値は「Int型の引数を２つ受け取って積を返す関数そのもの」です。</span></p>
<p><span>実際には関数リテラル「(x:Int,y:Int)=&gt;x+y」と「(x:Int,y:Int)=&gt;x*y」はコンパイル後にクラスファイル（例えば「Sample54$$anonfun$1.class」）となります。プログラムを実行すると、このクラスがインスタンス化されて関数値となり、val変数sumとmultiplyに格納されます。</span></p>
<p><span>その次に、２つの関数を呼び出しています。関数リテラルはクラスになるとapplyメソッドを持つことになるので、「sum(1,2)」は実際には「sum.apply(1,2)」ということになります。</span></p>
<p><span>最後に、calcというメソッドを定義しています。引数は「Int型の引数を２つ受け取ってInt型の値を返す関数」を受け取るので、引数の型は「(Int,Int)=&gt;Int」型になります。</span></p>
<p>
<div id="calibre_link-384"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-17">
<div>
<h2 id="calibre_link-385"><b><a id="calibre_link-168"><b><span><b>5-09　関数リテラルと関数値の演習問題</b></span></b></a></b></h2><p><span>Practice27シングルトンオブジェクトは未完成です。</span></p>
<p><span>val変数aとbが宣言してあります。その２つの変数の値を加算・減算・乗算・除算する関数を値として持つ配列変数を定義します。そしてfor式を用いて配列を走査し、演算結果を出力してください。</span></p>
<p>&nbsp;</p>
<p><span><b>[Practice27]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>30</span></p>
<p><span>18</span></p>
<p><span>144</span></p>
<p><span>4</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Practice27]関数リテラルと関数値の演習問題(Practice27.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice27{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　a=24</span></p>
<p><span>　val　b=6</span></p>
<p>&nbsp;</p>
<p><span>　//四則演算関数を値としてもつ配列を宣言します</span></p>
<p>&nbsp;</p>
<p><span>　//for式を用いて配列を走査し、演算を行います</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>
<div id="calibre_link-386"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-32">
<div>
<h2 id="calibre_link-387"><b><a id="calibre_link-169"><b><span><b>5-10　パッケージ</b></span></b></a></b></h2><p><span>「パッケージ」とは、ディレクトリを利用してクラスやオブジェクト、トレイトを分類することです。</span></p>
<p><span>たとえば、Windowsパソコンだと、マイドキュメントというディレクトリが用意されています。そのディレクトリ直下に画像や動画や音楽ファイルなどすべてをごちゃまぜに保存する人はまずいません。画像用、動画用、音楽用の各サブディレクトリを作成して、そこに保存するでしょう。さらに、画像だったら日付別サブディレクトリを設けたり、音楽だったらアーティスト別のサブディレクトリを設けたりすると思います。こうやって、ディレクトリをうまく利用してファイルを分類して管理しやすくします。</span></p>
<p><span>Scalaでも同じです。規模の大きなシステムになると、たくさんのクラスやオブジェクト、トレイトを管理しなくてはいけません。そのときに、ディレクトリをうまく利用して分類するのです。</span></p>
<p><span>今まで記述してきたサンプルプログラムはパッケージを考慮していませんでした。そういうクラスなどは「無名パッケージ」に含まれているといいます。</span></p>
<p><span>パッケージを使ってクラスなどを分類するには、予約語「package」を用います。パッケージを使って分類するには、２つの方法があります。</span></p>
<p>&nbsp;</p>
<p><span><b>[その１　ソースファイルの先頭に「package　パッケージ名」を記述する方法]</b></span></p>
<p>&nbsp;</p>
<p><span>パッケージ名はドット区切りで階層化することができます。そのソースファイルに記述されているクラスやオブジェクト、トレイトはすべてそのパッケージに含まれることになります。次のサンプルプログラムを入力・コンパイルしてみてください。</span></p>
<p><span>（うまく実行できないかもしれませんが、その理由は後ほど解説します）</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample55]パッケージのサンプル１(Sample55.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
<p><span>object　Sample55{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("PackageSample")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample55]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>PackageSample</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>とても基本的なコードですが、ソースファイルの先頭に「package　jp.co.test」と記述されています。</span></p>
<p><span>コンパイルの方法はいつもと同じなのですが、いつもとは違う結果になります。いつもなら、拡張子scalaのソースファイルをコンパイルすると、拡張子classのバイナリファイルがソースファイルとおなじディレクトリに生成されていました。しかし、今回はソースファイルがあるディレクトリに「jp」「co」「test」の順番にディレクトリが生成され、その中に拡張子classのバイナリファイルが生成されています。</span></p>
<p><span>そして、いつもの要領で実行しようとするとエラーになります。何故でしょうか？ここでしっかり理解して頂きたいことがあります。今まではパッケージを考慮していませんでしたから、たとえば「Sample01」オブジェクトの完全修飾名も「Sample01」でした。「完全修飾名」とは、クラスやオブジェクト、トレイトの本名のことです。今回の「Sample55」オブジェクトは「jp.co.test」パッケージに含まれていますので、完全修飾名は「jp.co.test.Sample55」になります。</span></p>
<p>&nbsp;</p>
<p><span>よって、以下のように実行しないといけません。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>&gt;scala　jp.co.test.Sample55</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>ポイントは、コマンドプロンプトのカレントディレクトリを「jp」ディレクトリの１つ上に合わせる点です。</span></p>
<p><span>また、パッケージを階層化する際は、package文をソースコードの先頭に連続して記述することもできます。つまり、</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>は、以下のようにも記述可能です。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp</span></p>
<p><span>package　co</span></p>
<p><span>package　test</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[その２　「package　パッケージ名」の後にブロックを記述する方法]</b></span></p>
<p>&nbsp;</p>
<p><span>「package　パッケージ名」の後にブロックを記述し、その中にクラスやオブジェクト、トレイトを記述する方法です。</span></p>
<p><span>この方法は、packageブロックをネストすることも可能です。「ネスト」とは、ブロックの中にまたブロックを記述することです。</span></p>
<p><span>ここで、次のプログラムをコーディングしてみましょう。（コンパイルは可能ですが、mainメソッドがないので実行はできません）</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample56]パッケージのサンプル２(Sample56.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　creature{</span></p>
<p><span> 　package　plant{</span></p>
<p><span>　class　Rose{</span></p>
<p><span>　override　def　toString="バラ"</span></p>
<p>}</p>
<p><span>　class　Tulip{</span></p>
<p><span>　override　def　toString="チューリップ"</span></p>
<p>}</p>
<p>}</p>
<p><span> 　package　animal{</span></p>
<p><span>　class　Dog{</span></p>
<p><span>　override　def　toString="犬"</span></p>
<p>}</p>
<p><span>　class　Cat{</span></p>
<p><span>　override　def　toString="猫"</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>コンパイルを行うと、まずカレントディレクトリに「creature」ディレクトリが生成されており、その中に「plant」「animal」の２つのディレクトリが生成されているのが確認できます。そして、「plant」ディレクトリに「Rose.class」「Tulip.class」ファイルが、「animal」ディレクトリに「Dog.class」「Cat.class」ファイルが生成されます。</span></p>
<p>&nbsp;</p>
<p><span>このプログラムは実行できませんが、次の「5-11　インポート」で使用します。</span></p>
<p>
<div id="calibre_link-388"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-47">
<div>
<h2 id="calibre_link-389"><b><a id="calibre_link-170"><b><span><b>5-11　インポート</b></span></b></a></b></h2><p><span>先ほど「5-10　パッケージ」でコーディングした「Rose」「Tulip」「Dog」「Cat」クラスを他のオブジェクトから利用してみましょう。</span></p>
<p><span>同じカレントディレクトリ内に、次のプログラムを記述してください。（まだコンパイルはできません）</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample57]別パッケージのサンプル（コンパイルできない）(Sample57.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
<p><span>object　Sample57{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　rose=new　Rose</span></p>
<p><span>　val　tulip=new　Tulip</span></p>
<p><span>　val　dog=new　Dog</span></p>
<p><span>　val　cat=new　Cat</span></p>
<p><span>　println(rose)</span></p>
<p><span>　println(tulip)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>このプログラムはコンパイルできません。何故なら、異なるパッケージのクラスは単純名ではアクセスできないからです。「単純名」とは、パッケージ名を省いた名前のことです。ただ、同一パッケージ内のクラスやオブジェクト、トレイトは単純名だけでアクセスすることができます。</span></p>
<p><span>今回のオブジェクト「Sample57」のパッケージ名は「jp.co.test」です。そして「val　rose=new　Rose」と記述していますが、「Rose」という名前のクラスは「jp.co.test」パッケージにはありません。そのような時は、クラスの完全修飾名を使用すれば解決します。</span></p>
<p><span>先ほどの「Sample57」プログラムを書き直してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample57]別パッケージのサンプル２（修正版）(Sample57.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
<p><span>object　Sample57{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　rose=new　creature.plant.Rose</span></p>
<p><span>　val　tulip=new　creature.plant.Tulip</span></p>
<p><span>　val　dog=new　creature.animal.Dog</span></p>
<p><span>　val　cat=new　creature.animal.Cat</span></p>
<p><span>　println(rose)</span></p>
<p><span>　println(tulip)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span><b>[Sample57]実行結果</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>バラ</span></p>
<p><span>チューリップ</span></p>
<p><span>犬</span></p>
<p><span>猫</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>これでコンパイル・実行とも可能になりました。しかし、まだ問題が１つ残っています。「val　rose=new　creature.plant.Rose」は、少し記述が長いですね。毎回、完全修飾名を書くとなると、記述するのが大変になるのは目に見えています。</span></p>
<p><span>そこで、「インポート」という仕組みを使用すると解決できます。それには予約語「import」を使用します。インポートは簡単に言うと、別のパッケージのクラスやオブジェクト、トレイトなどの完全修飾名を事前に予約して、単純名だけで使用できるようにすることです。</span></p>
<p>&nbsp;</p>
<p><span><b>[インポートの基本構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>import　完全修飾名</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>インポートはプログラムの任意の場所に記述することが可能ですが、通常はソースコードの上部、パッケージ文の下あたりに記述するのが一般的です。</span></p>
<p><span>先ほどの「Sample57」プログラムを、インポート文を使って書き直してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample57]インポートのサンプル１(Sample57.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
<p><span>import　creature.plant.Rose</span></p>
<p><span>import　creature.plant.Tulip</span></p>
<p><span>import　creature.animal.Dog</span></p>
<p><span>import　creature.animal.Cat</span></p>
<p><span>object　Sample57{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　rose=new　Rose</span></p>
<p><span>　val　tulip=new　Tulip</span></p>
<p><span>　val　dog=new　Dog</span></p>
<p><span>　val　cat=new　Cat</span></p>
<p><span>　println(rose)</span></p>
<p><span>　println(tulip)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>出力内容は先ほどと同じです。</span></p>
<p><span>これでだいぶすっきりしましたが、まだもう１つ問題点があります。</span></p>
<p><span>今回は「creature.plant」パッケージ内のクラスは２つだけでしたが、実際の植物の種類はもっと多いわけです。たとえば「creature.plant」パッケージに100種類の植物を表すクラスが用意されていて、そのすべてのクラスを使用するとなったらどうでしょう。100行のインポート文を書かなくてはいけなくなります。</span></p>
<p><span>それでは困りますので、もちろん解決方法があります。あるパッケージの中のクラスをすべて一括でインポートすることができるのです。それを「オンデマンドインポート」と言います。</span></p>
<p>&nbsp;</p>
<p><span><b>[オンデマンドインポートの構文]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>import　パッケージ名._</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>本来はクラス名などを記述する部分に、アンダースコアを記述します。</span></p>
<p><span>では、最後にもう一度先ほどの「Sample57」プログラムを修正してみましょう。</span></p>
<p>&nbsp;</p>
<p><span><b>[Sample57]インポートのサンプル２(Sample57.scala)</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>package　jp.co.test</span></p>
<p><span>import　creature.plant._</span></p>
<p><span>import　creature.animal._</span></p>
<p><span>object　Sample57{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　rose=new　Rose</span></p>
<p><span>　val　tulip=new　Tulip</span></p>
<p><span>　val　dog=new　Dog</span></p>
<p><span>　val　cat=new　Cat</span></p>
<p><span>　println(rose)</span></p>
<p><span>　println(tulip)</span></p>
<p><span>　println(dog)</span></p>
<p><span>　println(cat)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>出力内容は先ほどと同じです。</span></p>
<p><span>最後に補足なのですが、今まで使ってきたStringクラスやIntクラス、Arrayクラス、Listクラスにも完全修飾名はあります。たとえば、Intクラスは「scala.Int」、Stringクラスは「java.lang.String」、Arrayクラスは「scala.Array」、Listクラスは「scala.collection.immutable.List」が完全修飾名になります。</span></p>
<p><span>ではなぜインポートせずに単純名だけでクラスを利用できたかというと、Scalaでは暗黙的に次の３行のインポート文が挿入されるからです。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>import　java.lang._</span></p>
<p><span>import　scala._</span></p>
<p><span>import　Predef._</span></p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>これらの暗黙的インポートは、Scalaを快適にコーディングするために自動的に行われていると解釈してください。</span></p>
<p>
<div id="calibre_link-390"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-63">
<div>
<h1 id="calibre_link-391"><b><a id="calibre_link-171"><b><span><b><u>付録　演習問題の解答例</u></b></span></b></a></b></h1><p>
<div id="calibre_link-392"></div>
</p>
 
   
</div>
</div>
<div id="calibre_link-80">
<div>
<p>
<br id="calibre_link-393" /></p>
 
   
<h3><a id="calibre_link-172"><span>2-04　演算子の演習問題の解答例</span></a></h3> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice01{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p>&nbsp;</p>
<p><span>　//1.　Int型のvar変数xを宣言し、</span></p>
<p><span>　// 　初期値として10を代入してください</span></p>
<p><span>　var　x:Int=10</span></p>
<p>&nbsp;</p>
<p><span>　//2.　変数xの値を2倍して、変数xに</span></p>
<p><span>　// 　再格納してください</span></p>
<p><span>　x*=2</span></p>
<p>&nbsp;</p>
<p><span>　//3.　Int型のval変数yを宣言し、</span></p>
<p><span>　// 　初期値として変数xの値を7で割った</span></p>
<p><span>　// 　余りを代入してください</span></p>
<p><span>　val　y:Int=x%7</span></p>
<p>&nbsp;</p>
<p><span>　//4.　変数yの値を文字列の説明付きで</span></p>
<p><span>　// 　出力してください</span></p>
<p><span>　println("変数yの値："+y)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の解答例では、変数xとyの宣言に型の指定を行っていますが、型推論の機能を利用すれば記述しなくても正常に動作します。</span></p>
<p><span>コメント２の処理ですが、「x=x*2」と記述しても間違いではありません。ただ、解答例のように算術代入演算子を用いたほうがスマートになります。</span></p>
<p><span>コメント３では割り算の余りを求めています。剰余演算子の「%」はよく使われますのでしっかり覚えておいてください。</span></p>
<p>
<div id="calibre_link-394"></div>
</p>
 
</div>
</div>
<div id="calibre_link-53">
<div>
<h2 id="calibre_link-395"><a id="calibre_link-173"><span>2-05　if式の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice02{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("身長（cm）を入力してください")</span></p>
<p><span>　val　height=scala.io.StdIn.readDouble</span></p>
<p><span>　println("体重（kg）を入力してください")</span></p>
<p><span>　val　weight=scala.io.StdIn.readDouble</span></p>
<p><span>　val　bmi=weight/((height/100)*(height/100))</span></p>
<p><span>　val　result=</span></p>
<p><span>　if(bmi&gt;=26.5){</span></p>
<p><span>　　　"肥満"</span></p>
<p>}</p>
<p><span>　else　if(bmi&lt;26.5&amp;&amp;bmi&gt;=24){</span></p>
<p><span>　"太り気味"</span></p>
<p>}</p>
<p><span>　else　if(bmi&lt;24&amp;&amp;bmi&gt;=20){</span></p>
<p><span>　"普通"</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　"スリム"</span></p>
<p>}</p>
<p><span>　println("あなたのBMI値は"+bmi+"です")</span></p>
<p><span>　println("あなたは"+result+"です")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>最初のポイントとしては、BMI値を正しく算出することが重要です。身長の入力はセンチメートルで行っていますが、BMI値の算出にはメートルの値を用いる点に注意しましょう。よって、身長の入力数値を100で割っています。また、二乗は同じ値を掛けることで実現しています。（Scalaにはべき乗を算出する演算子はありません）</span></p>
<p>&nbsp;</p>
<p><span>BMIの判定結果はif式を用いて行います。問題文の指示通りにval変数resultを宣言し、if式の結果の値を代入しています。</span></p>
<p>
<div id="calibre_link-396"></div>
</p>
 
</div>
</div>
<div id="calibre_link-223">
<div>
<h2 id="calibre_link-397"><a id="calibre_link-174"><span>2-06　whileループの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice03{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　//答え変数（1から10までの値をランダムに設定）</span></p>
<p><span>　val　answer=scala.util.Random.nextInt(10)+1</span></p>
<p><span>　//回答できる回数変数</span></p>
<p><span>　var　count=3</span></p>
<p><span>　while(count&gt;0){</span></p>
<p><span>　　println("数値を入力してください（残り"+count+"回）")</span><span>//入力値の受付</span></p>
<p><span>　val　input=scala.io.StdIn.readInt</span></p>
<p><span>　//答えと一致した場合</span></p>
<p><span>　if(input==answer){</span></p>
<p><span>　//正解メッセージの表示</span></p>
<p><span>　println("正解です♪答えは"+answer+"でした！")</span><span>//ゲーム終了</span></p>
<p><span>　count=0</span></p>
<p>}</p>
<p><span>　//答えと一致しなかった場合</span></p>
<p><span>　else{</span></p>
<p><span>　//回数カウントを１減らす</span></p>
<p><span>　count-=1</span></p>
<p><span>　//回数カウントが０の場合は答えを表示</span></p>
<p><span>　if(count==0){</span></p>
<p><span>　println("残念...正解は"+answer+"でした！")</span><span>}</span></p>
<p><span>　//終了でない場合はヒントを表示</span></p>
<p><span>　else{</span></p>
<p><span>　//入力値が答えより大きい場合</span></p>
<p><span>　if(input&gt;answer){</span></p>
<p><span>　println("答えは"+input+"より小さい値です")</span><span>}</span></p>
<p><span>　//入力値が答えより小さい場合</span></p>
<p><span>　else{</span></p>
<p><span>　println("答えは"+input+"より大きい値です")</span><span>}</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>まず問題文の指示通りに、回答できる回数を保持するvar変数countを宣言し、初期値に3を代入します。その次に「while(count&gt;0)」というwhileループを記述することで、今回なら3回まで答えられるようになります。</span></p>
<p><span>そして入力値と答えの値が等しいかどうかはif式を用いて判定します。入力値と答えの値が等しければメッセージを表示してゲーム終了になります。ゲームを終了するために、変数countの値を強制的に0に設定しています。入力値と答えの値が等しくない場合は、変数countの値を１減らします。この処理を書き忘れると、何度でも回答できてしまいます。</span></p>
<p><span>これは、あくまで解答の一例です。他にもいろんな考え方がありますので、同じでなくても結果が正しければ問題ありません。</span></p>
<p>
<div id="calibre_link-398"></div>
</p>
 
   

</div>
</div>
<div id="calibre_link-206">
<div>
<h2 id="calibre_link-399"><b><a id="calibre_link-175"><b><span><b>2-07　メソッドの演習問題の解答例</b></span></b></a></b></h2><p><span><b>[解答例１]　</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice04{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=88</span></p>
<p><span>　val　y=79</span></p>
<p><span>　val　z=96</span></p>
<p><span>　print("整数"+x+","+y+","+z+"の中で最小の値は")</span><span>println(min(x,y,z)+"です")</span></p>
<p>}</p>
<p><span> 　//minメソッド</span></p>
<p><span> 　def　min(a:Int,b:Int,c:Int):Int={</span></p>
<p><span>　var　minValue=a</span></p>
<p><span>　if(minValue&gt;b){</span></p>
<p><span>　minValue=b</span></p>
<p>}</p>
<p><span>　if(minValue&gt;c){</span></p>
<p><span>　minValue=c</span></p>
<p>}</p>
<p><span>　minValue</span></p>
<p>}</p>
<p>}　</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>解答例１のminメソッドは、次のような考え方で実現しています。まず、var変数minValueを定義し、初期値として引数aの値を格納します。つまり、引数aの値を最小値だと仮定するわけです。次に引数bとminValueを比較して、引数bの方が小さな値のときはその値をminValueに代入します。引数cでも同様のことを行います。最後に、minValueの値を結果値として返しています。</span></p>
<p>&nbsp;</p>
<p><span><b>[解答例２]</b></span></p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice04{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　x=88</span></p>
<p><span>　val　y=79</span></p>
<p><span>　val　z=96</span></p>
<p><span>　print("整数"+x+","+y+","+z+"の中で最小の値は")</span><span>println(min(x,y,z)+"です")</span></p>
<p>}</p>
<p><span> 　//minメソッド</span></p>
<p><span> 　def　min(a:Int,b:Int,c:Int):Int={</span></p>
<p><span>　if(a&lt;b&amp;&amp;a&lt;c){</span></p>
<p><span>　a</span></p>
<p>}</p>
<p><span>　else　if(b&lt;c){</span></p>
<p><span>　b</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　c</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>解答例２のminメソッドは、次のような考え方で実現しています。minメソッドの中に値を返すif式のみを記述します。「aがbより小さい、かつaがcより小さい」場合はaが最小値なので、ブロックの中に「a」とだけ記述します。次に、それ以外の場合は、bかcのどちらかが最小値です。「bがcより小さい」場合はbが最小値なので、ブロックの中に「b」とだけ記述します。それ以外の場合はcが最小値なのでブロックに中に「c」とだけ記述します。それが、minメソッドの結果値となるわけです。</span></p>
<p>
<div id="calibre_link-400"></div>
</p>
 
</div>
</div>
<div id="calibre_link-62">
<div>
<h2 id="calibre_link-401"><a id="calibre_link-176"><span>2-08　オーバーロードの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice05{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　//円の半径変数の宣言</span></p>
<p><span>　val　r=5.0</span></p>
<p><span>　//円の面積を出力</span></p>
<p><span>　println("半径"+r+"の円の面積は"+getArea(r))</span><span>//底辺と高さ変数の宣言</span></p>
<p><span>　val　base=9.0</span></p>
<p><span>　val　height=5.0</span></p>
<p><span>　//三角形の面積を出力</span></p>
<p><span>　println("底辺"+base+"、高さ"+height+</span></p>
<p><span>　"の三角形の面積は"+getArea(base,height))</span></p>
<p><span>　//上底と下底変数の宣言</span></p>
<p><span>　val　upperBase=8.0</span></p>
<p><span>　val　lowerBase=10.0</span></p>
<p><span>　//台形の面積を出力</span></p>
<p><span>　println("上底"+upperBase+"、下底"+lowerBase+</span></p>
<p><span>　"、高さ"+height+"の台形の面積は"+</span></p>
<p><span>　getArea(upperBase,lowerBase,height))</span></p>
<p>}</p>
<p><span> 　//円の面積取得メソッド</span></p>
<p><span> 　def　getArea(r:Double):Double={</span></p>
<p><span>　3.14*r*r</span></p>
<p>}</p>
<p><span> 　//三角形の面積取得メソッド</span></p>
<p><span> 　def　getArea(base:Double,height:Double):Double={</span></p>
<p><span>　(base*height)/2</span></p>
<p>}</p>
<p><span> 　//台形の面積取得メソッド</span></p>
<p><span> 　def　getArea(upperBase:Double,</span></p>
<p><span>　lowerBase:Double,</span></p>
<p><span>　height:Double):Double={</span></p>
<p><span>　(upperBase+lowerBase)*height/2</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は３種類のgetAreaメソッドをオーバーロードして作成しました。Double型の引数が１個、２個、３個と違っている点がポイントです。</span></p>
<p>&nbsp;</p>
<p><span>結果型をDouble型で明示的に指定していますが、省略可ですので覚えておいてください。ただし、結果値のあるメソッドの場合、メソッド定義の右後ろの等号は必須ですので、くれぐれも忘れないように注意しましょう。</span></p>
<p>
<div id="calibre_link-402"></div>
</p>
 
</div>
</div>
<div id="calibre_link-28">
<div>
<h2 id="calibre_link-403"><a id="calibre_link-177"><span>3-01　クラスの基本の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice06{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　book=new　Book</span></p>
<p><span>　book.title="楽しいScala"</span></p>
<p><span>　book.author="山田太郎"</span></p>
<p><span>　book.price=2980</span></p>
<p><span>　println(book.getInfo)</span></p>
<p>}</p>
<p>}</p>
<p><span>class　Book{</span></p>
<p><span> 　var　title=""</span></p>
<p><span> 　var　author=""</span></p>
<p><span> 　var　price=0</span></p>
<p><span> 　def　getInfo:String={</span></p>
<p><span>　"タイトル："+title+"¥n著者："+</span></p>
<p><span>　author+"¥n価格："+</span></p>
<p><span>　price+"円"</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>３つのvarフィールドには、必ず初期値を代入してください。初期値を代入しないとコンパイルエラーになってしまいます。</span></p>
<p><span>getInfoメソッドの結果値は１つのString型の値ですが、出力内容は３行になっています。これは、文字列の中に改行を表現するエスケープシーケンス「¥n」を使って実現しています。</span></p>
<p>
<div id="calibre_link-404"></div>
</p>
 
</div>
</div>
<div id="calibre_link-217">
<div>
<h2 id="calibre_link-405"><a id="calibre_link-178"><span>3-02　基本コンストラクタの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice07{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　tshirt=new　TShirt("黒","L",2980)</span><span>println("本日セールのTシャツ")</span></p>
<p><span>　tshirt.information()</span></p>
<p><span>　tshirt.changePrice(1480)</span></p>
<p><span>　println("プライズダウン後のTシャツ")</span></p>
<p><span>　tshirt.information()</span></p>
<p>}</p>
<p>}</p>
<p><span>//TShirtクラス</span></p>
<p><span>class　TShirt(c:String,s:String,p:Int){</span></p>
<p><span> 　val　color=c</span></p>
<p><span> 　val　size=s</span></p>
<p><span> 　var　price=p</span></p>
<p><span> 　def　changePrice(newPrice:Int){</span></p>
<p><span>　price=newPrice</span></p>
<p>}</p>
<p><span> 　def　information(){</span></p>
<p><span>　println("色："+color+"　サイズ："+</span></p>
<p><span>　size+"　価格："+price+"円")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>クラスパラメーター名とインスタンスフィールド名は、異なる名前を付けるようにしましょう。また、価格は今回変更可能なフィールドなので、valではなくvarフィールドになります。</span></p>
<p>
<div id="calibre_link-406"></div>
</p>
 
</div>
</div>
<div id="calibre_link-76">
<div>
<h2 id="calibre_link-407"><a id="calibre_link-179"><span>3-03　アクセス修飾子　privateの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice08{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　jp=new　Japanese("山田一郎","2001-04-01",</span><span>false,123456789012L)</span></p>
<p><span>　//外部からはアクセスできない</span></p>
<p><span>　//println(jp.mynumber)　</span></p>
<p><span>　jp.showPrivateData()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Japaneseクラス</span></p>
<p><span>class　Japanese(n:String,b:String,g:Boolean,m:Long){</span></p>
<p><span> 　private　val　name=n</span></p>
<p><span> 　private　val　birthday=b</span></p>
<p><span> 　private　val　gender=g</span></p>
<p><span> 　private　val　mynumber=m</span></p>
<p><span> 　def　showPrivateData(){</span></p>
<p><span>　println("--　"+name+"の個人情報　--")</span><span>println("生年月日："+birthday)</span></p>
<p><span>　println("性別："+(if(gender)"女性"else"男性"))</span><span>println("マイナンバー："+mynumber)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は４つのvalインスタンスフィールドをすべてprivateに設定しました。よって、mainメソッドの「//println(jp.mynumber)」のコメントを取ると、コンパイルエラーになります。privateなメンバは外部から直接アクセスできないからです。</span></p>
<p><span>showPrivateDataメソッドで、性別を出力している部分に注目しましょう。if式は値を返すことが可能なので、printlnメソッドの丸かっこの中に直接記述することも可能です。</span></p>
<p>
<div id="calibre_link-408"></div>
</p>
 
</div>
</div>
<div id="calibre_link-55">
<div>
<h2 id="calibre_link-409"><a id="calibre_link-180"><span>3-04　補助コンストラクタの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice09{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　t1=new　Talent("石原真希",22)</span></p>
<p><span>　val　t2=new　Talent("本上ゆきえ","本田良子")</span><span>val　t3=new　Talent("市川瑠璃子","山田美紀",24)</span><span>t1.profile()</span></p>
<p><span>　t2.profile()</span></p>
<p><span>　t3.profile()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Talentクラス</span></p>
<p><span>class　Talent(sn:String,rn:String,a:Int){</span></p>
<p><span> 　private　val　stageName=sn</span></p>
<p><span> 　private　val　realName=rn</span></p>
<p><span> 　private　var　age=a</span></p>
<p><span> 　//補助コンストラクタ</span></p>
<p><span> 　def　this(sn:String,rn:String){</span></p>
<p><span>　this(sn,rn,-1)</span></p>
<p>}</p>
<p><span> 　//補助コンストラクタ</span></p>
<p><span> 　def　this(sn:String,a:Int){</span></p>
<p><span>　this(sn,"非公開",a)</span></p>
<p>}</p>
<p><span> 　def　profile(){</span></p>
<p><span>　print("芸名："+stageName)</span></p>
<p><span>　print("　本名："+realName)</span></p>
<p><span>　println("　年齢："+</span></p>
<p><span>　(if(age&lt;0)"非公開"else(age+"歳")))</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習は「タレントには必ず芸名があるけど、本名や年齢は非公開にしている人もいる」というところを取り上げてみました。芸名と本名は基本的に変わらないのでvalフィールドにし、年齢は変化していくのでvarフィールドにしました。</span></p>
<p><span>基本コンストラクタは、芸名・本名・年齢のすべてをクラスパラメーターで受け取り、各フィールドに値をセットしています。</span></p>
<p><span>補助コンストラクタをオーバーロードして２つ定義しました。年齢が非公開のタレントは、芸名と本名だけを受け取り、年齢を「-1」として基本コンストラクタを呼び出しています。また、本名が非公開のタレントは、芸名と年齢だけを受け取り、本名を「非公開」として基本コンストラクタを呼び出しています。</span></p>
<p><span>タレントのプロフィールを表示するprofileメソッドでは、年齢がマイナスの値の場合は「非公開」と解釈して表示を行っています。</span></p>
<p>
<div id="calibre_link-410"></div>
</p>
 
</div>
</div>
<div id="calibre_link-215">
<div>
<h2 id="calibre_link-411"><a id="calibre_link-181"><span>3-05　パラメーターフィールドの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice10{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　car1=new　Car("ファット",1234,10.0)</span></p>
<p><span>　val　car2=new　Car("トント",6789)</span></p>
<p><span>　car1.run(7.0)</span></p>
<p><span>　car2.run(7.0)</span></p>
<p><span>　car1.showInfo()</span></p>
<p><span>　car2.showInfo()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Carクラス</span></p>
<p><span>class　Car(private　val　model:String,</span></p>
<p><span>　private　val　number:Int,　</span></p>
<p><span>　private　var　gasoline:Double){</span></p>
<p><span> 　def　this(model:String,number:Int){</span></p>
<p><span>　//ガソリン量の初期値5.0を設定</span></p>
<p><span>　this(model,number,5.0)</span></p>
<p>}</p>
<p><span> 　def　run(need:Double){</span></p>
<p><span>　if(gasoline&gt;=need){</span></p>
<p><span>　println("ナンバー"+number+"の"+</span></p>
<p><span>　model+"はガソリン"+</span></p>
<p><span>　need+"リットル分走行しました")</span></p>
<p><span>　gasoline-=need</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　println("ナンバー"+number+"の"+model+</span></p>
<p><span>　"はガソリン不足のため走行できません")</span></p>
<p>}</p>
<p>}</p>
<p><span> 　def　showInfo(){</span></p>
<p><span>　println("車種："+model+"　ナンバー："+number+</span></p>
<p><span>　"　ガソリン："+gasoline+"リットル")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のCarクラスは３つのフィールドを持っていますが、それらをすべてパラメーターフィールドで定義するという問題です。車種とナンバーは不変なのでval、ガソリン量は常に変化しますのでvarで定義しました。</span></p>
<p><span>補助コンストラクタは、車種とナンバーだけを受け取り、ガソリン量は初期値「5.0」を基本コンストラクタに受け渡しています。</span></p>
<p><span>走行を表現するrunメソッドは、走行に必要なガソリン量を引数で受け取ります。よって、gasolineフィールドの値と比較して、走行できるかを決定しています。走行できた場合はきちんと走行ガソリン分減らすところがポイントです。</span></p>
<p>
<div id="calibre_link-412"></div>
</p>
 
</div>
</div>
<div id="calibre_link-33">
<div>
<h2 id="calibre_link-413"><a id="calibre_link-182"><span>3-06　自己参照のthisの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice11{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　square1=new　Square(2.5,　4.5)</span></p>
<p><span>　val　square2=new　Square(3.5,　4.0)</span></p>
<p><span>　print("２つの四角形で広い方の面積は")</span></p>
<p><span>　print((square1.wider(square2)).area)</span></p>
<p><span>　println("です")</span></p>
<p><span>　square1.add(0.5,　0.5)</span></p>
<p><span>　print("２つの四角形で広い方の面積は")</span></p>
<p><span>　print((square1.wider(square2)).area)</span></p>
<p><span>　println("です")</span></p>
<p>}</p>
<p>}</p>
<p><span>//Squareクラス</span></p>
<p><span>class　Square(private　var　width:Double,　</span></p>
<p><span>　private　var　height:Double){</span></p>
<p><span> 　def　area:Double=width*height</span></p>
<p><span> 　def　wider(other:Square):Square={</span></p>
<p><span>　if(area&gt;=other.area){</span></p>
<p><span>　this</span></p>
<p>}</p>
<p><span>　else{</span></p>
<p><span>　other</span></p>
<p>}</p>
<p>}</p>
<p><span> 　def　add(width:Double,height:Double){</span></p>
<p><span>　this.width+=width</span></p>
<p><span>　this.height+=height</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>面積を算出するareaメソッドは引数なしなので、丸かっこを省略しています。また、メソッドの中身が１行で記述できる場合は等号のあとにブロックは必要ありません。</span></p>
<p><span>addメソッドの引数は今回「width」「height」と、パラメーターフィールドと同じ名前にしているため、「this.width+=width」のようにフィールド側にthisが必要となります。もし引数名を「w」「h」のように命名すれば、「this.」をフィールド側に付ける必要はありません。</span></p>
<p>
<div id="calibre_link-414"></div>
</p>
 
</div>
</div>
<div id="calibre_link-200">
<div>
<h2 id="calibre_link-415"><a id="calibre_link-183"><span>3-07　コンパニオンクラス・オブジェクトの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice12{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("ロボット総生産数："+Robot.getTotal)</span></p>
<p><span>　val　r1=new　Robot("RX")</span></p>
<p><span>　val　r2=new　Robot("SS")</span></p>
<p><span>　val　r3=new　Robot("ZK")</span></p>
<p><span>　println("ロボット総生産数："+Robot.getTotal)</span></p>
<p><span>　r1.introduce()</span></p>
<p><span>　r2.introduce()</span></p>
<p><span>　r3.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Robotコンパニオンオブジェクト</span></p>
<p><span>object　Robot　{</span></p>
<p><span> 　private　var　total=0</span></p>
<p><span> 　def　getTotal=total</span></p>
<p>}</p>
<p><span>//Robotコンパニオンクラス</span></p>
<p><span>class　Robot(private　val　name:String){</span></p>
<p><span> 　Robot.total+=1</span></p>
<p><span> 　private　val　id=Robot.total</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("ID："+id+"　NAME："+name)</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>Robotコンパニオンオブジェクトで、総生産数を表現するtotalフィールドをprivateに設定し、その値を取得するためのgetTotalメソッドを定義しています。これにより、totalフィールドはRobotコンパニオンクラス以外からは読み取り専用となります。getTotalメソッドは引数とその丸かっこ、結果型、ブロックなどが省略されていますが、Scalaではこのような表現はよく用いられますので慣れておきましょう。</span></p>
<p><span>Robotコンパニオンクラスでは、基本コンストラクタ内でRobotコンパニオンオブジェクトのtotalフィールドをインクリメントし、その値を使ってidインスタンスフィールドを初期化しています。こうすることで、製造したロボットに一意の連番を付与することが可能です。</span></p>
<p>
<div id="calibre_link-416"></div>
</p>
 
</div>
</div>
<div id="calibre_link-84">
<div>
<h2 id="calibre_link-417"><a id="calibre_link-184"><span>4-01　継承の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice13{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　p=new　Pitcher("山田",99,0.09,2.13)</span></p>
<p><span>　p.changeBattingAverage(0.02)</span></p>
<p><span>　p.introduce()</span></p>
<p>}</p>
<p>}</p>
<p><span>//BaseballPlayerクラス</span></p>
<p><span>class　BaseballPlayer(val　name:String,</span></p>
<p><span>　val　uniformNumber:Int,</span></p>
<p><span>　var　battingAverage:Double){</span></p>
<p><span> 　def　changeBattingAverage(change:Double){</span></p>
<p><span>　battingAverage+=change</span></p>
<p>}</p>
<p>}</p>
<p><span>//Pitcherクラス</span></p>
<p><span>class　Pitcher(n:String,un:Int,</span></p>
<p><span>　ba:Double,var　era:Double)　</span></p>
<p><span>　extends　BaseballPlayer(n,　un,　ba){</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("選手名："+name)</span></p>
<p><span>　println("背番号："+uniformNumber)</span></p>
<p><span>　println("打率　："+battingAverage)</span></p>
<p><span>　println("防御率："+era)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習のポイントは２つあります。まずひとつは、すべての野球選手には選手名、背番号、打率がありますが、投手だけ防御率があるという点です。つまり、スーパークラスBaseballPlayerに足りないものをサブクラスPitcherで補っているわけですから、これは「差分コーディング」と呼ばれるものになります。よって、Pitcherクラスの防御率eraフィールドのみをパラメーターフィールドに設定する必要があります。</span></p>
<p><span>そしてもうひとつのポイントですが、どうしても打率が0.09のままになってしまった方も多いのではないでしょうか？</span></p>
<p><span>mainメソッドでchangeBattingAverageメソッドを呼んでいるため、打率は0.09から0.11に変化しないといけないのです。そのような方は次のようにPitcherクラスを定義していると思われます。</span></p>
<p>&nbsp;</p>
 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>class　Pitcher(name:String,</span></p>
<p><span>　uniformNumber:Int,</span></p>
<p><span>　battingAverage:Double,</span></p>
<p><span>　var　era:Double)　</span></p>
<p><span>　extends　BaseballPlayer(</span></p>
<p><span>　name,uniformNumber,battingAverage){</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("選手名："+name)</span></p>
<p><span>　println("背番号："+uniformNumber)</span></p>
<p><span>　println("打率　："+battingAverage)</span></p>
<p><span>　println("防御率："+era)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>原因は、Pitcherクラスの３つのクラスパラメーターが、BaseballPlayerクラスのパラメーターフィールドと同じ名前だからです。同じ名前にしてしまうと、Pitcherクラスのintroduceメソッドで打率を表示している部分の「battingAverage」が、スーパークラスBaseballPlayerのパラメーターフィールドの「battingAverage」ではなく、サブクラスPitcherのクラスパラメーターの「battingAverage」を使用してしまうため、値が変化しないわけです。ここはくれぐれも注意しましょう。</span></p>
<p>
<div id="calibre_link-418"></div>
</p>
 
</div>
</div>
<div id="calibre_link-211">
<div>
<h2 id="calibre_link-419"><a id="calibre_link-185"><span>4-02　オーバーライドの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice14{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　b=new　Bicycle</span></p>
<p><span>　val　mb=new　MotorBicycle</span></p>
<p><span>　b.turn()</span></p>
<p><span>　b.move()</span></p>
<p><span>　mb.turn()</span></p>
<p><span>　mb.move()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Bicycleクラス</span></p>
<p><span>class　Bicycle{</span></p>
<p><span> 　def　turn(){</span></p>
<p><span>　println("ハンドルを切ります。")</span></p>
<p>}</p>
<p><span> 　def　move(){</span></p>
<p><span>　println("ペダルを漕いで進みます。")</span></p>
<p>}</p>
<p>}</p>
<p><span>//MotorBicycleクラス</span></p>
<p><span>class　MotorBicycle　extends　Bicycle{</span></p>
<p><span> 　override　def　move(){</span></p>
<p><span>　println("エンジンを動力に進みます。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習では「バイクは自転車の一種である」と考え、バイクを表現するMotorBicycleクラスは自転車を表現するBicycleクラスを継承しています。</span></p>
<p><span>ハンドルを切る仕組みはバイクも自転車も同じですから、MotorBicycleクラスはスーパークラスBicycleのturnメソッドをそのまま引き継いで使います。</span></p>
<p><span>ただ、バイクはペダルを漕いで進むわけではないので、スーパークラスBicycleのmoveメソッドをそのまま使えません。よって、MotorBicycleクラスでmoveメソッドをオーバーライドして再定義します。メソッドを定義する予約語「def」の左前に、オーバーライドをするための予約語「override」を忘れないようにしましょう。</span></p>
<p>
<div id="calibre_link-420"></div>
</p>
 
</div>
</div>
<div id="calibre_link-59">
<div>
<h2 id="calibre_link-421"><a id="calibre_link-186"><span>4-03　予約語superの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice15{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　c1=new　Clock(10,15,30)</span></p>
<p><span>　c1.showData()</span></p>
<p><span>　println()</span></p>
<p><span>　val　c2=new　AlarmClock(15,45,20,6,30)</span></p>
<p><span>　c2.showData()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Clockクラス</span></p>
<p><span>class　Clock(private　var　hour:Int,</span></p>
<p><span>　private　var　minute:Int,</span></p>
<p><span>　private　var　second:Int){</span></p>
<p>&nbsp;</p>
<p><span> 　def　showData(){</span></p>
<p><span>　println("ただいまの時刻："+hour+"時"+</span></p>
<p><span>　          　minute+"分"+second+"秒")</span></p>
<p>}</p>
<p>}</p>
<p><span>//AlarmClockクラス</span></p>
<p><span>class　AlarmClock(h:Int,m:Int,s:Int,</span></p>
<p><span>　private　var　alarmHour:Int,</span></p>
<p><span>　private　var　alarmMinute:Int)</span></p>
<p><span>　extends　Clock(h,m,s){</span></p>
<p>&nbsp;</p>
<p><span> 　override　def　showData(){</span></p>
<p><span>　super.showData()</span></p>
<p><span>　println("アラーム設定時刻："+alarmHour+"時"+</span></p>
<p><span>　alarmMinute+"分")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習では、まず時計を表現するClockクラスを作成し、次にそれを継承して目覚まし時計AlarmClockクラスを作成します。今回の時計は時間が経過しても時・分・秒のフィールドの値はそのままですが、一応変化する前提でvarフィールドに設定しています。サブクラスAlarmClockは、差分コーディングとしてアラームの鳴る時・分を表現するalarmHourフィールドとalarmMinuteフィールドを定義します。そして、スーパークラスのshowDataメソッドをオーバーライドし、かつスーパークラスのshowDataメソッドも活用するために「super.showData()」で呼び出してからアラーム時刻を出力しています。</span></p>
<p><span>Clockクラスの時・分・秒パラメーターフィールドはprivateになっているので、サブクラスAlarmClockからも直接参照することができない所がポイントです。</span></p>
<p>
<div id="calibre_link-422"></div>
</p>
 
</div>
</div>
<div id="calibre_link-19">
<div>
<h2 id="calibre_link-423"><a id="calibre_link-187"><span>4-04　アクセス修飾子protectedの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice16{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　ap=new　Airplane(0,0,100000)</span></p>
<p><span>　ap.takeoff()</span></p>
<p><span>　ap.information()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Vehicleクラス</span></p>
<p><span>class　Vehicle(protected　var　speed:Int,</span></p>
<p><span>　protected　var　fuel:Double)</span></p>
<p><span>//Airplaneクラス</span></p>
<p><span>class　Airplane(private　var　altitude:Int,</span></p>
<p><span>　s:Int,f:Double)</span></p>
<p><span>　extends　Vehicle(s,f){</span></p>
<p>&nbsp;</p>
<p><span> 　def　takeoff(){</span></p>
<p><span>　println("離陸しました。")</span></p>
<p><span>　speed+=500</span></p>
<p><span>　fuel-=100.0</span></p>
<p><span>　altitude+=10000</span></p>
<p>}</p>
<p><span> 　def　information(){</span></p>
<p><span>　println("--　現在の状況　--")</span></p>
<p><span>　println("高度："+altitude+"フィート")</span><span>println("速度：時速"+speed+"km")</span></p>
<p><span>　println("残燃料"+fuel+"リットル")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回のスーパークラスであるVehicleクラスには速度と残燃料を表す２つのパラメーターフィールドがあり、いずれもvarで可変です。外部から簡単に値を変更できないようにし、かつサブクラスからアクセスできるように修飾子protectedを付加している点がポイントです。また、クラスの中身は特に何もないため、クラス定義の右後ろにブロックは必要ありません。</span></p>
<p><span>サブクラスAirplaneは基本コンストラクタで高度・速度・残燃料を受け取りますが、そのうち高度は飛行機クラスにのみ必要なフィールドなので、パラメーターフィールドに設定し、あとの速度と残燃料はクラスパラメーターとしてスーパークラスの基本コンストラクタに受け渡しています。ここで、速度と残燃料のクラスパラメーター名をsとfにしていますが、スーパークラスのパラメーターフィールドspeedとfuelと異なる名前にしているところがポイントです。もし同じ名前にしてしまうと、takeoffメソッドで加算と減算を行っているspeedとfuelはAirplaneのクラスパラメーターの方となり、クラスパラメーターは自動的にval(不変)扱いなのでコンパイルエラーになってしまいます。この点はくれぐれも気をつけてください。</span></p>
<p>
<div id="calibre_link-424"></div>
</p>
 
</div>
</div>
<div id="calibre_link-14">
<div>
<h2 id="calibre_link-425"><a id="calibre_link-188"><span>4-05　抽象クラスと抽象メンバの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice17{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　cook:Worker=new　Cook("酒井")</span></p>
<p><span>　val　designer:Worker=new　Designer("片桐")</span></p>
<p><span>　cook.introduce()</span></p>
<p><span>　cook.work()</span></p>
<p><span>　designer.introduce()</span></p>
<p><span>　designer.work()</span></p>
<p>}</p>
<p>}</p>
<p><span>//Workerクラス</span></p>
<p><span>abstract　class　Worker(val　name:String){</span></p>
<p><span> 　val　jobType:String</span></p>
<p><span> 　def　work()</span></p>
<p><span> 　def　introduce(){</span></p>
<p><span>　println("わたくし"+name+"は"+jobType+"です。")</span><span>}</span></p>
<p>}</p>
<p><span>//Cookクラス</span></p>
<p><span>class　Cook(n:String)　extends　Worker(n){</span></p>
<p><span> 　val　jobType="コック"</span></p>
<p><span> 　def　work(){</span></p>
<p><span>　println(name+"さんはおいしいパスタを作りました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>//Designerクラス</span></p>
<p><span>class　Designer(n:String)　extends　Worker(n){</span></p>
<p><span> 　val　jobType="デザイナー"</span></p>
<p><span> 　def　work(){</span></p>
<p><span>　println(name+"さんは斬新なイラストを描きました。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は抽象クラスWorker（労働者）に職種を表現するjobType抽象フィールドと、働くことを表現するwork抽象メソッドを定義しました。これら２つを抽象メンバにした理由は、サブクラスが決まらないと実装できないからです。ちなみに、抽象クラスには普通のメソッドやフィールド（いわゆる具象メンバ）も定義できる点を押さえておいてください。</span></p>
<p><span>サブクラスCookおよびDesignerで抽象フィールドjobTypeと抽象メソッドworkを実装しています。抽象フィールドや抽象メソッドの実装はオーバーライドに近いものですが、予約語「override」は普通付けません。（付けても良い）</span></p>
<p><span>Workerクラスのintroduceメソッドの中で、値の代入されていないjobType抽象フィールドが使われている点がポイントです。これは、サブクラスで実装した値が使われるという仕組みになっています。</span></p>
<p>
<div id="calibre_link-426"></div>
</p>
 
</div>
</div>
<div id="calibre_link-61">
<div>
<h2 id="calibre_link-427"><a id="calibre_link-189"><span>4-07　toStringメソッドのオーバーライドの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice18{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　book=new　Book("人間失格",500,"太宰治")</span><span>val　magazine=</span></p>
<p><span>　new　Magazine("東京グルメ",980,"ABC出版編集部","上田彩")</span><span>println(book)</span></p>
<p><span>　println(magazine)</span></p>
<p>}</p>
<p>}</p>
<p><span>//Bookクラス</span></p>
<p><span>class　Book(protected　val　title:String,</span></p>
<p><span>　protected　val　price:Int,</span></p>
<p><span>　protected　val　author:String){</span></p>
<p>&nbsp;</p>
<p><span> 　override　def　toString={</span></p>
<p><span>　"タイトル："+title+"　価格："+price+</span></p>
<p><span>　"円　著者："+author</span></p>
<p>}</p>
<p>}</p>
<p><span>//Magazineクラス</span></p>
<p><span>class　Magazine(t:String,p:Int,a:String,</span></p>
<p><span>　val　coverPersonName:String)</span></p>
<p><span>　extends　Book(t,p,a){</span></p>
<p>&nbsp;</p>
<p><span> 　override　def　toString={</span></p>
<p><span>　super.toString+</span></p>
<p><span>　"　表紙："+coverPersonName+"さん"</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習には、ひとつだけひっかけがあります。それは、雑誌MagazineクラスのtoStringメソッドの返す値の前半部分が、スーパークラスBookのtoStringメソッドの内容とまったく同じである点です。よって、雑誌MagazineクラスのtoStringメソッドは「super.toString+"　表紙："+coverPersonName+"さん"」として、効率良く記述することが可能となります。</span></p>
<p><span>あと、繰り返しになりますが、結果値のあるメソッドにはブロックの前に等号が必須なので絶対に忘れないようにしてください。等号が不要なのは、結果値を返さないメソッドの場合のみです。</span></p>
<p>
<div id="calibre_link-428"></div>
</p>
 
</div>
</div>
<div id="calibre_link-0">
<div>
<h2 id="calibre_link-429"><a id="calibre_link-190"><span>4-08　トレイトの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice19{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　button=new　CountButton</span></p>
<p><span>　button.push()</span></p>
<p><span>　button.push()</span></p>
<p><span>　button.push()</span></p>
<p><span>　println("ボタンを押した回数："+button.getCount)</span></p>
<p>}</p>
<p>}</p>
<p><span>//Buttonクラス</span></p>
<p><span>class　Button{</span></p>
<p><span> 　def　push(){</span></p>
<p><span>　println("ボタンを押しました。")</span></p>
<p>}</p>
<p>}</p>
<p><span>//Counterトレイト</span></p>
<p><span>trait　Counter{</span></p>
<p><span> 　private　var　count=0</span></p>
<p><span> 　def　incrementCount(){</span></p>
<p><span>　count+=1</span></p>
<p>}　</p>
<p><span> 　def　getCount=count</span></p>
<p>}</p>
<p><span>//CountButtonクラス</span></p>
<p><span>class　CountButton</span></p>
<p><span>　extends　Button</span></p>
<p><span>　with　Counter{</span></p>
<p>&nbsp;</p>
<p><span> 　override　def　push(){</span></p>
<p><span>　super.push();</span></p>
<p><span>　incrementCount();</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は、ただ押すことができるだけのボタンを表現するButtonクラスを定義し、次に数を数える機能だけを持つCounterトレイトを定義します。このトレイトは、回数を保持するためのcountというprivateなvarフィールドを持ち、その値をインクリメントするincrementCountメソッドとその値を返すgetCountメソッドを定義します。</span></p>
<p><span>数を数えるためのボタンであるCountButtonクラスはButtonクラスを継承し、Counterトレイトをミックスインします。pushメソッドをオーバーライドし、まずはスーパークラスButtonの持つpushメソッドを呼び出してから、Counterトレイトの持つincrementCountメソッドを呼び出します。</span></p>
<p><span>mainメソッドの中では、３回ボタンを押した後にその回数をgetCountメソッドで取得して出力しています。</span></p>
<p>
<div id="calibre_link-430"></div>
</p>
 
</div>
</div>
<div id="calibre_link-48">
<div>
<h2 id="calibre_link-431"><a id="calibre_link-191"><span>5-02　配列の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice20{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(167,218,271,121)</span></p>
<p><span>　var　sum=0</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;arr.length){</span></p>
<p><span>　sum+=arr(i)</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p><span>　println("配列のすべての要素の合計は"+</span></p>
<p><span>　sum+"です。")</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習は、要素数が４つのArray[Int]型配列インスタンスが用意してあり、そのすべての要素を合計するというものです。合計値を保持するために、var変数sumを宣言して0で初期化しています。また、配列のインデックス番号をインクリメントするためのvar変数iも宣言して0で初期化しています。</span></p>
<p><span>配列の要素数はlengthメソッドで取得することが可能ですので、whileループの条件式でうまく利用しています。whileループの条件式に「i&lt;4」と、直接数値を書かないようにしましょう。何故なら、もしこのあと配列要素数を変更することになった場合、いちいちwhileループの条件式も書き直さないといけなくなるからです。このような冗長なプログラムは記述しない習慣を身につけてください。</span></p>
<p>
<div id="calibre_link-432"></div>
</p>
 
</div>
</div>
<div id="calibre_link-208">
<div>
<h2 id="calibre_link-433"><a id="calibre_link-192"><span>5-03　コマンドライン引数の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice21{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　left=args(0).toInt</span></p>
<p><span>　val　right=args(1).toInt</span></p>
<p><span>　println(left+"+"+right+"="+(left+right))</span><span>}</span></p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習では、コマンドライン引数として２つの数値が渡ってくるのですが、それはあくまで文字列だという点を忘れてはいけません。２つのコマンドライン引数を文字列から数値に変換するために、「5-01　さまざまなメソッド」で学習したtoIntメソッドを用いてください。</span></p>
<p>
<div id="calibre_link-434"></div>
</p>
 
</div>
</div>
<div id="calibre_link-36">
<div>
<h2 id="calibre_link-435"><a id="calibre_link-193"><span>5-04　タプルの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice22{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　arr=Array(13,48,93,52,81)</span></p>
<p><span>　val　(sum,average)=sumAverage(arr)</span></p>
<p><span>　println("配列の要素の合計："+sum)</span></p>
<p><span>　println("配列の要素の平均："+average)</span></p>
<p>}</p>
<p><span> 　def　sumAverage(arr:Array[Int])={</span></p>
<p><span>　var　sum=0</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;arr.length){</span></p>
<p><span>　sum+=arr(i)</span></p>
<p><span>　i+=1</span></p>
<p>}</p>
<p><span>　val　average=sum/arr.length.toDouble</span></p>
<p><span>　(sum,average)</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回の演習は、引数で受け取ったInt配列の各要素の合計値と平均値を結果値として返すというちょっと変わったメソッドを作成する内容でした。</span></p>
<p><span>ポイントは、平均値を算出する際に合計値から要素数をそのまま割り算をしてしまうと、どちらもInt型のため演算結果もInt型になってしまう点です。演算結果をDouble型にするには、値のどちらかをDouble型に変換すればいいわけです。「5-01　さまざまなメソッド」で紹介したtoDoubleメソッドを実行すれば、Int型からDouble型に変換できます。</span></p>
<p>
<div id="calibre_link-436"></div>
</p>
 
</div>
</div>
<div id="calibre_link-15">
<div>
<h2 id="calibre_link-437"><a id="calibre_link-194"><span>5-05　Listの演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice23{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list=List(5,13,6,9,18,2,21,1)</span></p>
<p><span>　println("Listの偶数の個数："+countEven(list))</span></p>
<p>}</p>
<p><span> 　def　countEven(list:List[Int])={</span></p>
<p><span>　var　count=0</span></p>
<p><span>　var　i=0</span></p>
<p><span>　while(i&lt;list.length){</span></p>
<p><span>　if(list(i)%2==0){</span></p>
<p><span>　count+=1</span></p>
<p>}</p>
<p><span>　i+=1</span></p>
<p>}</p>
<p><span>　count</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回はList[Int]型で渡ってきた値の中から偶数の個数を数えて結果値として返すcountEvenメソッドを作るというものです。基本的には、配列の時と同様にwhileループを使って各要素にアクセスし、値をチェックします。偶数であるかのチェックは、剰余演算子%を使って、「2で割った余りが0」の時に偶数と判定します。</span></p>
<p>
<div id="calibre_link-438"></div>
</p>
 
</div>
</div>
<div id="calibre_link-21">
<div>
<h2 id="calibre_link-439"><a id="calibre_link-195"><span>5-06　for式の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice24{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　list=List(3,-5,0,-7,2,8,-1)</span></p>
<p><span>　val　newlist=choosePlus(list)</span></p>
<p><span>　println("正の数を抽出したList："+newlist)</span></p>
<p>}</p>
<p><span> 　def　choosePlus(list:List[Int])={</span></p>
<p><span>　for(x&lt;-list　if　x&gt;=0)yield{</span></p>
<p><span>　x</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は引数で渡ってきたList[Int]型インスタンスの要素の中から、値が0以上のものを抽出して新しいList[Int]型インスタンスを生成するメソッドを作成します。</span></p>
<p><span>まず、引数で渡ってきたList[Int]型インスタンスをfor式のジェネレーターにセットし、ひとつずつ値を抽出します。次に、フィルタ機能を使って、0以上の値だけを選別します。最後に、ジェネレーターの右後ろに予約語yieldを指定することで、for式のブロック内の値を蓄積して新しいコレクションを生成します。</span></p>
<p><span>choosePlusメソッドの中には値を返すfor式しかありませんから、当然そのfor式が返す値（新しく生成されたList[Int]型インスタンス）がメソッドの結果値となるわけです。</span></p>
<p>
<div id="calibre_link-440"></div>
</p>
 
</div>
</div>
<div id="calibre_link-70">
<div>
<h2 id="calibre_link-441"><a id="calibre_link-196"><span>5-07　match式の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice25{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　println("8+4="+calculate(8,4,"+"))</span><span>println("8-4="+calculate(8,4,"-"))</span><span>println("8*4="+calculate(8,4,"*"))</span><span>println("8/4="+calculate(8,4,"/"))</span><span>println("8?4="+calculate(8,4,"?"))</span><span>}</span></p>
<p><span> 　def　calculate(first:Int,second:Int,</span></p>
<p><span>　operator:String)={</span></p>
<p>&nbsp;</p>
<p><span>　operator　match{</span></p>
<p><span>　case"+"=&gt;first+second</span></p>
<p><span>　case"-"=&gt;first-second</span></p>
<p><span>　case"*"=&gt;first*second</span></p>
<p><span>　case"/"=&gt;first/second</span></p>
<p><span>　case　_ 　=&gt;0</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回作成するメソッドは、第三引数として渡ってきた四則演算を表す文字列「+」「-」「*」「/」に応じて、第一・第二引数を演算した結果を返すものという内容です。</span></p>
<p><span>予約語「match」の前に第三引数を記述し、各caseの値として四則演算を表す文字列を記述します。予約語「=&gt;」の右側で、各演算を行います。第三引数が不正だった場合のために「case　_」を用意し、無条件に0を返しています。</span></p>
<p>
<div id="calibre_link-442"></div>
</p>
 
</div>
</div>
<div id="calibre_link-7">
<div>
<h2 id="calibre_link-443"><a id="calibre_link-197"><span>5-08　例外処理try式の演習問題の解答例</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice26{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　try{</span></p>
<p><span>　println("[1]28/7="+divide(28,7))</span></p>
<p><span>　println("[2]72/8="+divide(72,8))</span></p>
<p><span>　println("[3]44/0="+divide(44,0))</span></p>
<p><span>　println("[4]54/6="+divide(54,6))</span></p>
<p>}</p>
<p><span>　catch{</span></p>
<p><span>　case　ex:ArithmeticException　=&gt;</span></p>
<p><span>　println("0割が発生しました！")</span></p>
<p>}</p>
<p>}</p>
<p><span> 　def　divide(x:Int,y:Int)={</span></p>
<p><span>　x/y</span></p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>今回は割り算を行うdivideメソッドがスローするArithmeticException例外を捕捉するという内容です。まず４つの割り算処理全体をtryブロックで囲います。次に、catchブロックを記述し、caseにArithmeticExceptionと記述して例外を捕捉します。予約語「=&gt;」の右後ろには「0割が発生しました！」と出力する処理のみを記述しています。</span></p>
<p><span>try式は値を返すことができますが、今回は特に値を返すことはせずにprintlnメソッドを用いて出力だけを行っています。</span></p>
<p>
<div id="calibre_link-444"></div>
</p>
 
</div>
</div>
<div id="calibre_link-43">
<div>
<h2 id="calibre_link-445"><a id="calibre_link-198"><span>5-09　関数リテラルと関数値の演習問題の解答</span></a></h2> 
<table cellspacing="0" cellpadding="0" border="1"> 
<tbody> 
<tr> 
<td>
<p><span>object　Practice27{</span></p>
<p><span> 　def　main(args:Array[String]){</span></p>
<p><span>　val　a=24</span></p>
<p><span>　val　b=6</span></p>
<p><span>　val　functions=Array(</span></p>
<p><span>　(x:Int,y:Int)=&gt;x+y,</span></p>
<p><span>　(x:Int,y:Int)=&gt;x-y,</span></p>
<p><span>　(x:Int,y:Int)=&gt;x*y,</span></p>
<p><span>　(x:Int,y:Int)=&gt;x/y</span></p>
<p><span>　)</span></p>
<p><span>　for(function&lt;-functions){</span></p>
<p><span>　println(function(a,b))</span></p>
<p>}</p>
<p>}</p>
<p>}</p>
</td> 
</tr> 
</tbody> 
</table>
<p>&nbsp;</p>
<p><span>Scalaでは、関数は値として扱われます。よって、関数という値を配列としてまとめることも可能です。今回の演習では、加減乗除を行う４つの関数をまとめる配列を生成します。その関数配列を、for式を用いて走査し、それぞれの関数を呼び出します。</span></p>
<p><span>配列変数functionsの型は型推論の機能を利用して明示的には記述していませんが、実際には「Array[(Int,Int)=&gt;Int]」型となります。</span></p>
<p>
<div id="calibre_link-446"></div>
</p>
</div>
</div>
<div id="calibre_link-73">
<div>
<p>
<br id="calibre_link-447" /></p>
<p><span>【著者紹介】</span></p>
<p><span>飯田健二。1975年生まれ。神戸出身。大学卒業後、プログラマとして７年間さまざまなシステム開発に携わり、８年目で講師に転向。大手企業の新入社員の研修や、職業訓練校などでプログラマを育成。現在は㈱うえじま企画でプログラマを育成する専任講師を勤める。</span></p>
<p>&nbsp;</p>
<p><span>ゼロから学</span><span>ぶ</span><span>Scala</span><span>発行</span><span>　</span><span>201</span><span>6年7月1</span><span>日　初版発行</span></p>
<p><span>著者　飯田　健二</span></p>
<p><span>装丁　内山　知美</span></p>
<p><span>© 2016 Kenji Iida</span></p>
<p><span>発行所　株式会社　うえじま企画</span></p>
<p><span>〒</span><span>114-001</span><span>3</span><span>東京都北区東田</span><span>端</span><span>1-13-10 ツインビル田</span><span>端A</span><span>棟</span></p>
<p><span>Web : http://www.uknet.co.jp</span></p>
</div>
</div>




<script>function myFunction(){document.getElementById("tateyoko").classList.toggle("tateread")}</script></body></html>
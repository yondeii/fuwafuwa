<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Embedded System Advanced 4　日本語版: Training material for engineer Discover! How? (NGO TAMA)</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/css/mainday.css" title="default">
<link rel="alternate stylesheet" href="/css/mainnight.css" title="alternate">
<script type="text/javascript" src="/js/styleswitcher.js"></script>
<script type="text/javascript" src="/js/global.js"></script>
</head>
<body>
<div class="novelpage">
<div class="novelbody">
<div id="tateyoko">
<div id="_top"></div>
<a href="/">🏠</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('default'); return false;">日</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('alternate'); return false;">月</a>&emsp;
<a href="#_top" onclick="myFunction()" style="cursor: pointer;">縦書き／横書き</a>
<div id="calibre_link-33">
<div>
<div>
<table class="noveltitle">
<tr>
<td colspan="2"><i><span><i>Embedded System Advanced 4　日本語版: Training material for engineer Discover! How? (NGO TAMA)</i></span></i></td>
</tr>
<tr>
                    
                    
      </tr>
<tr>
<td colspan="2">NGO TAMA</td>
</tr>
<tr>
<td colspan="2">ENUJIHOH TAMA (2017)</td>
</tr>
<tr>
<td colspan="2"></td>
</tr>
</table>
<div></div>
</div>
<div></div>
</div>
</div>



<div id="calibre_link-0">
<div>
<p>&nbsp;<span>目次</span>
 &nbsp;</p>
<p>&nbsp;<a id="calibre_link-34"></a>
<a href="#calibre_link-1">
<span><u>[1]&nbsp;交流波形の作成</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-2">
<span><u>[2]&nbsp;位相調整</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-3">
<span><u>[3]&nbsp;周波数変更</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-4">
<span><u>[4]&nbsp;三相交流波形</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-5">
<span><u>[5]&nbsp;高速サンプリング</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-6">
<span><u>(1)&nbsp;三相交流波形の取得</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-7">
<span><u>(2)&nbsp;交流波形の保存</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-8">
<span><u>(3)&nbsp;処理状況表示</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-9">
<span><u>[6]&nbsp;不具合の発生</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-10">
<span><u>[7]&nbsp;間引き</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-11">
<span><u>(1)&nbsp;相間の間隔</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-12">
<span><u>(2)&nbsp;実用計算</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-13">
<span><u>[8]&nbsp;回転数計算の再考</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-14">
<span><u>[9]&nbsp;周期の計算</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-15">
<span><u>(1)&nbsp;周期の確認</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-16">
<span><u>[10]&nbsp;電圧、電流の計算</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-17">
<span><u>(1)&nbsp;電圧、電流の確認</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-18">
<span><u>[11]&nbsp;電力の計算</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-19">
<span><u>(1)&nbsp;電力、力率の確認</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-20">
<span><u>[12]&nbsp;微調整</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-21">
<span><u>(1)&nbsp;計算開始</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-22">
<span><u>(2)&nbsp;波形生成</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-23">
<span><u>(3)&nbsp;停止後の処置</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-24">
<span><u>(4)&nbsp;時分割</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-25">
<span><u>[13]&nbsp;パソコンモニター</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-26">
<span><u>(1)&nbsp;読出し指示</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-27">
<span><u>(2)&nbsp;読出し指示応答</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-28">
<span><u>(3)&nbsp;書き込み指示応答</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-29">
<span><u>[14]&nbsp;実機用に変更</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-30">
<span><u>(1)&nbsp;実機用に実装</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-31">
<span><u>(2)&nbsp;動作確認</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;<a href="#calibre_link-32">
<span><u>[15]&nbsp;あとがき</u></span>
</a>
 &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<p>&nbsp;<span>[概要]</span>
 &nbsp;</p>
<p>&nbsp;<span>この章では、発電した電圧と電流を測定する方法を取り上げています。</span>
 &nbsp;</p>
<p>&nbsp;<span>さらに実用システムにとって必要なモニタリングも扱います。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h1>
<a id="calibre_link-1">
<span>[1]&nbsp;交流波形の作成</span>
</a>
</h1>
<p>&nbsp;<span>プログラム作成段階では、発電機を動作させないで、外部から交流波形を入れて模擬する必要があります。</span>
 &nbsp;</p>
<p>&nbsp;<span>このMPUには、2チャンネルの８ビットDA変換器があるので、先ず、これを使い交流電圧と位相のずれた交流電流を作成してみましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000017.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>200usの割り込みで、50Hzの波形を生成します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;hwsetup.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//Interrupt priority</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>INTC.IPR11.BIT._MTU25 =&nbsp;10&nbsp;;</span>
<span>//MTU25.TIER.BIT.TGIU_5 DAC</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//Multifunction timer</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//The DA conversion trigger using the MTU2 channel 5U</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TCRU.BIT.TPSC = 2 ;&nbsp;&nbsp; //MTU2 clock :Pφ/16&nbsp; = 0.32us</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TIORU.BIT.IOC = 0 ;&nbsp;&nbsp; //TIC5U&nbsp; compare match&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TIER.BIT.TGIEU = 1 ;&nbsp; //1：CMFU5&nbsp; interrupt</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TCCR.BIT.CLRU = 1 ;&nbsp; //1：TCNTU_5 clear</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TCNTU = 0 ;&nbsp;</span>
<span>&nbsp;// Timer counter</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TGRU = 625 ;&nbsp;</span>
<span>&nbsp;// 625 * 0.32us =200us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//DAC</span>
 &nbsp;</p>
<p>&nbsp;<span>DAC.DADR0 = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>DAC.DADR1 = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>DAC.DACR.BYTE = 0xFF ;</span>
<span>//1111 1111 チャネル 0,1 の D/A 変換を許可</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>新規にDA変換用のファイルを作成します。</span>
 &nbsp;</p>
<p>&nbsp;<span>開発環境の標準ライブラリーにmath.hを含めて下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//――――――――――――――――――――――――</span>
 &nbsp;</p>
<p>&nbsp;<span>//&nbsp; FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Dac.cpp</span>
 &nbsp;</p>
<p>&nbsp;<span>//&nbsp; DESCRIPTION : Digital to Analog Conversion</span>
 &nbsp;</p>
<p>&nbsp;<span>//&nbsp; CPU TYPE&nbsp;&nbsp;&nbsp; : SH7286</span>
 &nbsp;</p>
<p>&nbsp;<span>//&nbsp; DATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Nov 01, 2016</span>
 &nbsp;</p>
<p>&nbsp;<span>//&nbsp; VERSION ：1.0&nbsp;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//――――――――――――――――――――――――</span>
 &nbsp;</p>
<p>&nbsp;<span>#include &lt;math.h&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "iodefine.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>extern "C" {</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "vect.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "common.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "proto.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>#define PI&nbsp;&nbsp;&nbsp; 3.14159265</span>
 &nbsp;</p>
<p>&nbsp;<span>static int&nbsp;pitch&nbsp;;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//--------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>// Functions</span>
 &nbsp;</p>
<p>&nbsp;<span>//--------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>pitch&nbsp;= 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TSTR.BIT.CSTU = 1 ;</span>
<span>//MTU25U&nbsp; タイマースタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//200us割り込み毎に、SIN値を計算して出力する</span>
 &nbsp;</p>
<p>&nbsp;<span>// 196 MTU2 MTU5 TGIU5</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU25.TSR.BIT.CMFU == 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU25.TSR.BIT.CMFU = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double angle = (2*PI*pitch&nbsp;) / 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double val = sin(angle) * 127 + 127;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR0 = (unsigned char )val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angle -= PI / 6 ;</span>
<span>//-30deg</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angle) * 127 + 127;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR1 = (unsigned char )val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++pitch&nbsp;&gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>pitch&nbsp;= 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Main.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void main(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>InitDac();</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>while ( 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>如何ですか？　正しく50Hzの交流波形が出力されましたか？</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000008.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h1>
<a id="calibre_link-2">
<span>[2]&nbsp;位相調整</span>
</a>
</h1>
<p>&nbsp;<span>では次に、電流の遅れ位相を調整出来るようにしましょう。これは、後で力率を確認する時に役立ちます。</span>
 &nbsp;</p>
<p>&nbsp;<span>テストでは、水温の入力端子に可変抵抗器を付けて行います。実測した入力の最大AD値は約3800です。この範囲で０から90度（PI/2）まで位相を変化させます。</span>
 &nbsp;</p>
<p>&nbsp;<span>また、DA変換器は高速で動作しているので、位相値はグローバル変数として渡しています。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>#define TEST</span>
<span>1</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>extern double g_delay ;</span>
<span>//位相遅れ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void Analog()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>#ifdef TEST</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//位相遅れ</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = ( adcVal[P_Ai03] * 1.570) / 3800 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>double g_delay ;</span>
<span>//位相遅れ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = 0.0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR0 = (unsigned char )val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angle&nbsp;-=&nbsp;g_delay&nbsp;;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angle) * 127 + 127;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>これでVRを回すと位相が変化するのが確認出来ましたか？</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-3">
<span>[3</span>
<span>]</span>
<span>&nbsp;周波数変更</span>
</a>
</h1>
<p>&nbsp;<span>今度は、周波数を変更出来るようにしましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>周波数はテスト用回転数変更VRと連動させる必要があります。</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数はRotate.cpp内のChangeRotation()ファンクションで得られます。</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数(R rpm)と周波数(F Hz)の関係は</span>
 &nbsp;</p>
<p>&nbsp;<span>F(Hz) = R(rpm) / 30 ;&nbsp;</span>
<span>(1)</span>
 &nbsp;</p>
<p>&nbsp;<span>DA変換の周期(P)と周波数(F)の関係は、0.32usのクロックを使い、波形を100分割しているので</span>
 &nbsp;</p>
<p>&nbsp;<span>Ｐ = 1000000 / ( F * 0.32 * 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>= 1000 / ( F * 0.32 )</span>
 &nbsp;</p>
<p>&nbsp;<span>= 300000 / ( R * 0.32 )</span>
 &nbsp;</p>
<p>&nbsp;<span>= 937500 / R</span>
 &nbsp;</p>
<p>&nbsp;<span>です。</span>
 &nbsp;</p>
<p>&nbsp;<span>現在はR=1500でP=625をセットしています。</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数(R)をChangeRotation()からDA側に送ります。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Rotate.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//回転数変更</span>
 &nbsp;</p>
<p>&nbsp;<span>void ChangeRotation(int val)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if (( oldSet &gt;&gt; 2 ) != ( val &gt;&gt; 2 ))</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>newSet = NUMERATOR3 / y;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ChangeHelz( y );</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数が変更された時に、DA側で変換周期を変更します。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>#define NUMERATOR</span>
<span>937500L</span>
 &nbsp;</p>
<p>&nbsp;<span>static short nowRpm ;</span>
<span>//現在回転数</span>
 &nbsp;</p>
<p>&nbsp;<span>static short oldRpm ;</span>
<span>//前回回転数</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>nowRpm = 400;</span>
 &nbsp;</p>
<p>&nbsp;<span>oldRpm = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU25.TSR.BIT.CMFU == 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++pitch &gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>pitch = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( nowRpm != oldRpm )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>oldRpm = nowRpm ;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU25.TGRU = NUMERATOR / nowRpm ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void ChangeHelz( int rpm )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( rpm &lt; 400 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>nowRpm = 400 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( rpm &gt; 2700 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>nowRpm = 2700 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>nowRpm = rpm ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>波形を観測して、周波数の変化を確認して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000010.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>Period = 25ms, Frequency=40Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000012.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>Period = 20ms, Frequency=50Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000005.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>Period = 15ms, Frequency=67Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点でのメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均&nbsp;&nbsp;30us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大&nbsp;&nbsp;4.4ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小&nbsp; 20us</span>
 &nbsp;</p>
<p>&nbsp;<span>でした。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-4">
<span>[4</span>
<span>]</span>
<span>&nbsp;三相交流波形</span>
</a>
</h1>
<p>&nbsp;<span>実際の問題として、装置の交流波形のアナログ入力端子は高電圧を入力するように作られているので、DA出力電圧を直接に入力することが出来ません。</span>
 &nbsp;</p>
<p>&nbsp;<span>そこでテスト時点では、電線で接続をしないで、DA側で計算した値をAD側で受け取るようにします。</span>
 &nbsp;</p>
<p>&nbsp;<span>アナログ入力端子の最大入力電圧値は425Vです。325Vが入力された時に、実効電圧値230Vになるように波高値を調整します。</span>
 &nbsp;</p>
<p>&nbsp;<span>DA側で三相交流波形値を生成しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>#define TEST</span>
<span>1</span>
<span>//疑似電圧、電流データを作成する</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>// ------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned int g_voltage[3] ;</span>
<span>//電圧</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned int g_current[3] ;</span>
<span>//電流</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>//300vの最大値425V</span>
 &nbsp;</p>
<p>&nbsp;<span>//230Vの最大値325V</span>
 &nbsp;</p>
<p>&nbsp;<span>//比率　325/425=0.76</span>
 &nbsp;</p>
<p>&nbsp;<span>//計算の簡略化のために 0.76 * 2047 = 1565.35</span>
 &nbsp;</p>
<p>&nbsp;<span>#define RATE</span>
<span>1565.35</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[n] = 0 ;</span>
<span>//電圧</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[n] = 0 ;</span>
<span>//電流</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TSTR.BIT.CSTU = 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU25.TSR.BIT.CMFU == 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU25.TSR.BIT.CMFU = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add&nbsp;＆ modify&nbsp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>#ifdef TEST</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//U phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double angleA = (2*PI*pitch&nbsp;) / 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double val = sin(angleA) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[0] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR0 = g_voltage[0] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double angleB = angleA&nbsp;-&nbsp;g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angleB) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[0] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR1 = g_current[0] &gt;&gt; 4 ;//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//V phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angleA -= ( 2 * PI ) / 3 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angleA) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[1] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>DAC.DADR1 = g_voltage[1] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angleB = angleA&nbsp;-&nbsp;g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angleB) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[1] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//W phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angleA -= ( 2 * PI ) / 3 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angleA) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[2] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>DAC.DADR1 = g_voltage[2] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>angleB = angleA&nbsp;-&nbsp;g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sin(angleB) * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[2] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>#else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double angle = (2*PI*pitch&nbsp;) / 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR1 = (unsigned char )val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++pitch &gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>pitch = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>これでアナログ入力側に渡す値の準備が出来ました。</span>
 &nbsp;</p>
<p>&nbsp;<span>波形を観測して、三相交流の位相のズレを確認しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>１）U相とV相電圧の位相差　6.72ms＝120.96度</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000020.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>２）U相とW相電圧の位相差　13.34ms＝240.12度</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000000.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-5">
<span>[5</span>
<span>]</span>
<span>&nbsp;高速サンプリング</span>
</a>
</h1>
<p>&nbsp;<span>三相交流波形を高速でサンプリング出来るように、アナログ入力側を変更します。</span>
 &nbsp;</p>
<p>&nbsp;<span>アナログ入力ポートは下図のように接続されています。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000015.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>実効値で+/-300Vの電圧が、途中の回路で+/-5Vに変換されています。また、電流も実効値で+/-100Aが、+/-5Vに変換されています。</span>
 &nbsp;</p>
<p>&nbsp;<span>ＡＤ変換はマルチファンクションタイマーMTU20を使って、50Hzの交流波形を200usでサンプリングします。</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-6">
<span>(1) 三相交流波形の取得</span>
</a>
</h2>
<p>&nbsp;<span>アナログ入力ポートの設定を行います。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;hwsetup.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//マルチファンクションタイマー</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//The AD conversion trigger using the MTU2 channel 0</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU20.TCR.BIT.CKEG = 1 ;</span>
<span>//01：立ち下がりエッジでカウント</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU20.TCR.BIT.TPSC = 1 ;</span>
<span>&nbsp;//内部クロック：Pφ／4 でカウント 4/50MHz&nbsp; = 0.08us</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU20.TMDR.BYTE = 0 ;</span>
<span>//通常動作</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU20.TCNT = 0 ;</span>
<span>// Timer counter</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU20.TGRA = 2500 ;</span>
<span>// 2500 * 0.08us = 200us</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>テスト時には、DAC側で生成した値を受け取ります。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>#define TEST</span>
<span>1</span>
<span>//DA側で生成した値を読む</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>extern unsigned int g_voltage[3] ;</span>
<span>//電圧</span>
 &nbsp;</p>
<p>&nbsp;<span>extern unsigned int g_current[3] ;</span>
<span>//電流</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC1.ADSR.BIT.ADF = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>#ifdef TEST</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[4] = g_voltage[0] ;</span>
<span>// 発電電圧(U)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[5] = g_current[0] ;</span>
<span>// 発電電流(U)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[6] = g_voltage[1] ;</span>
<span>// 発電電圧(V)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[7] = g_current[1] ;</span>
<span>// 発電電流(V)</span>
 &nbsp;</p>
<p>&nbsp;<span>#else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[4] = ADC1.ADDR4 ;</span>
<span>//&nbsp;発電電圧(U)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[7] = ADC1.ADDR7 ;</span>
<span>//&nbsp;発電電流(V)</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADCR.BIT.ADST = 1 ;</span>
<span>//ADC2変換スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADSR.BIT.ADF = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>#ifdef TEST</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[8] = g_voltage[2] ;</span>
<span>// 発電電圧(W)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[9] = g_current[2] ;</span>
<span>// 発電電流(W)</span>
 &nbsp;</p>
<p>&nbsp;<span>#else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[8] = ADC2.ADDR8 ;</span>
<span>//&nbsp;発電電圧(W)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[9] = ADC2.ADDR9 ;</span>
<span>//&nbsp;発電電流(W)</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[10] = ADC2.ADDR10 ;</span>
<span>// 表示選択VR</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-7">
<span>(2) 交流波形の保存</span>
</a>
</h2>
<p>&nbsp;<span>サンプリングした交流波形を保存して、必要なデータが揃った時点で計算します。</span>
 &nbsp;</p>
<p>&nbsp;<span>なお、交流波形の電圧値の計算方法は、この「Discover! How?」シリーズの「Frequency+Voltage&amp;Current+VisualC#」に詳しく掲載しています。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>#define HALFBUF</span>
<span>120</span>
 &nbsp;</p>
<p>&nbsp;<span>#define MIDVAL</span>
<span>2047</span>
<span>//2.50V</span>
 &nbsp;</p>
<p>&nbsp;<span>#define LOWVAL</span>
<span>1640</span>
<span>//2.00V</span>
 &nbsp;</p>
<p>&nbsp;<span>#define MANY</span>
<span>5</span>
 &nbsp;</p>
<p>&nbsp;<span>#define XPITCH</span>
<span>200</span>
<span>//200us</span>
 &nbsp;</p>
<p>&nbsp;<span>#define HEAD</span>
<span>30</span>
 &nbsp;</p>
<p>&nbsp;<span>#define TAIL</span>
<span>50</span>
 &nbsp;</p>
<p>&nbsp;<span>#define MAXVOLT</span>
<span>425</span>
<span>//300Vの最大値</span>
 &nbsp;</p>
<p>&nbsp;<span>#define MAXCURR</span>
<span>100</span>
<span>//70Aの最大値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//交流波形構造体</span>
 &nbsp;</p>
<p>&nbsp;<span>struct WAVEBUF {</span>
 &nbsp;</p>
<p>&nbsp;<span>short waveStep ;</span>
<span>//取得シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>short voltBuf[HALFBUF] ;</span>
<span>//電圧バッファ</span>
 &nbsp;</p>
<p>&nbsp;<span>short currBuf[HALFBUF] ;</span>
<span>//電流バッファ</span>
 &nbsp;</p>
<p>&nbsp;<span>short wavePtr ;</span>
<span>//ポインタ</span>
 &nbsp;</p>
<p>&nbsp;<span>bool ready ;</span>
<span>//データ準備出来た</span>
 &nbsp;</p>
<p>&nbsp;<span>short helz ;</span>
<span>//0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>short volt ;</span>
<span>//0.1V</span>
 &nbsp;</p>
<p>&nbsp;<span>short peak ;</span>
<span>//V</span>
 &nbsp;</p>
<p>&nbsp;<span>short curr ;</span>
<span>//0.1A</span>
 &nbsp;</p>
<p>&nbsp;<span>short&nbsp;theta ;</span>
<span>//位相差</span>
 &nbsp;</p>
<p>&nbsp;<span>short result[6];</span>
<span>//計算結果</span>
 &nbsp;</p>
<p>&nbsp;<span>short check[6] ;</span>
<span>//状況監視</span>
 &nbsp;</p>
<p>&nbsp;<span>};</span>
 &nbsp;</p>
<p>&nbsp;<span>static struct WAVEBUF U_WB ;</span>
<span>//Ｕ相</span>
 &nbsp;</p>
<p>&nbsp;<span>static struct WAVEBUF V_WB ;</span>
<span>//Ｖ相</span>
 &nbsp;</p>
<p>&nbsp;<span>static struct WAVEBUF W_WB ;</span>
<span>//Ｗ相</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private function</span>
 &nbsp;</p>
<p>&nbsp;<span>static void InitWaveBuf( struct WAVEBUF *sp );</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool Prepare( struct WAVEBUF *sp, int volt, int curr );</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool CalcHelz( struct WAVEBUF *sp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>/初期化</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitAdc()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;U_WB );</span>
<span>//Ｕ相</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;V_WB );</span>
<span>//Ｖ相</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;W_WB );</span>
<span>//Ｗ相</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2.TSTR.BIT.CST0 = 1 ;</span>
<span>//MTU20 タイマースタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//電圧電流測定用バッファの初期化</span>
 &nbsp;</p>
<p>&nbsp;<span>static void InitWaveBuf( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;waveStep = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; HALFBUF ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;voltBuf[n] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;currBuf[n] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;wavePtr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;helz = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;volt = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;peak = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;curr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;theta = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 6 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[n] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt;&nbsp;6&nbsp;; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[n] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[7] = ADC1.ADDR7 ;</span>
<span>//&nbsp;電流(V)</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>Prepare( &amp;U_WB, adcRaw[4], adcRaw[5] );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>Prepare( &amp;V_WB, adcRaw[6], adcRaw[7] );</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADCR.BIT.ADST = 1 ;</span>
<span>//変換スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[11] = ADC2.ADDR11 ;</span>
<span>//&nbsp;回転数変更VR</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>Prepare( &amp;W_WB, adcRaw[8], adcRaw[9] );</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 10 ; n &lt; 12 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//電圧、電流値保存（割り込み専用）</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool Prepare( struct WAVEBUF *sp, int volt, int curr )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>int n, ptr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>bool end = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>switch ( sp-&gt;waveStep )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>case 0: //５個以上マイナス側にあることを確認</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;voltBuf[sp-&gt;wavePtr] = volt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;currBuf[sp-&gt;wavePtr] = curr;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( volt &gt;= LOWVAL )</span>
<span>//2.0V以下になってから開始する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;wavePtr = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++sp-&gt;wavePtr &gt;= MANY )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;waveStep++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>case 1: //プラス側になるのを待つ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;voltBuf[sp-&gt;wavePtr] = volt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;currBuf[sp-&gt;wavePtr] = curr;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( volt &lt; MIDVAL )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//まだ、マイナス側ならシフトする</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ptr = sp-&gt;wavePtr;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n = MANY-1 ; n &gt;= 0 ; n-- )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;voltBuf[ptr-n-1] = sp-&gt;voltBuf[ptr-n];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;currBuf[ptr-n-1] = sp-&gt;currBuf[ptr-n];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//プラスになった後は順にバッファに入れる</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;waveStep++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[0] += 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>case 2 :&nbsp;//バッファにデータを入力しながら再びマイナス側になったのを検知する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++sp-&gt;wavePtr &lt; HALFBUF )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;voltBuf[sp-&gt;wavePtr] = volt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;currBuf[sp-&gt;wavePtr] = curr;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( volt &lt; MIDVAL )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//値がマイナス領域に入った後に、少しだけバッファに入れる</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ptr = sp-&gt;wavePtr;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>for ( n = 0; n &lt; MANY; n++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if (sp-&gt;voltBuf[--ptr] &gt;= MIDVAL)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( n &gt;= MANY )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;ready = true;</span>
<span>//計算準備OK！</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;check[1] += 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;waveStep++;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//異常</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;wavePtr = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;waveStep = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>end = true ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>case 3 :</span>
<span>//計算完了待ち</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sp-&gt;ready == false )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;wavePtr = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;waveStep = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[2] += 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>end = true ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sp-&gt;check[0] &gt; 9999 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>for ( n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;check[n] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>return end;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void Analog()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = ( adcVal[P_Ai03] * 1.570) / 3800 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>//周期の計算を行う</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( U_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>CalcHelz( &amp;U_WB );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>U_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( V_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>CalcHelz( &amp;V_WB );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>V_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( W_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>CalcHelz( &amp;W_WB );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>W_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//周期の計算</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool CalcHelz( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>return true ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-8">
<span>(3)&nbsp;処理状況表示</span>
</a>
</h2>
<p>&nbsp;<span>Prepareファンクションが動作しているかを、LCD画面で確認しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>状況監視のために用意したcheckデータを調べます。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static const char scProcess[][21] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>{"U&nbsp; 0000&nbsp; 0000&nbsp; 0000 "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"V&nbsp; 0000&nbsp; 0000&nbsp; 0000 "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"W&nbsp; 0000&nbsp; 0000&nbsp; 0000 "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"u0000&nbsp; v0000&nbsp; w0000 "}};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//進行状況 for LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>int&nbsp;GetProcess(int val[])</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = U_WB.check[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = V_WB.check[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[2] = W_WB.check[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[3] = U_WB.check[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[4] = V_WB.check[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[5] = W_WB.check[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[6] = U_WB.check[2] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[7] = V_WB.check[2] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[8] = W_WB.check[2] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[9] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[10] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[11] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return 12 ;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetProcessMsg( int val[], char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char line[22], temp[8] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[0] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scProcess[n], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 4, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[3], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 4, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[9], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+6], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 4, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[15], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( line, scProcess[3], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int k = val[n] - val[n+6];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( k, temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 4, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[1+n*7], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Display.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void DispLCD()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>case&nbsp;D_Process&nbsp;:</span>
<span>//処理状況</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DispFunc( GetProcess,&nbsp; GetProcessMsg );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>selectLED = L_ADC ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>ここまでをコンパイル、実行してLCD画面で確認して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>変数checkの数値は増えていますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で、待機状態のメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>31us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>4.4ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>しかし、運転ステージでのメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>1.1ms</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>46.4ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>225us</span>
 &nbsp;</p>
<p>&nbsp;<span>と、格段に処理に時間が掛かっています。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>さらに大きな問題が起きました。</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数を1510rpm以上に上げると、システムが停止してしまいます</span>
 &nbsp;</p>
<p>&nbsp;<span>先ず、これを解決しましょう。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-9">
<span>[6] 不具合の発生</span>
</a>
</h1>
<p>&nbsp;<span>このあたりから処理が多くなり、回転数を1500rpm以上に上げ、周波数を変えるとプログラムが止まってしまいます。</span>
 &nbsp;</p>
<p>&nbsp;<span>少し過去に戻り、調査するとDACでの波形生成に突き当たります。</span>
 &nbsp;</p>
<p>&nbsp;<span>最初は一つの相の波形でしたが、途中から三相の波形を生成しています。</span>
 &nbsp;</p>
<p>&nbsp;<span>このMPUは数値演算ユニットを内蔵していないので、SINの計算に時間が掛かっているようです。</span>
 &nbsp;</p>
<p>&nbsp;<span>200usのインターバルで割り込んで計算処理をしている次の関数の処理時間を計ると、1500rpmを越えた時点で184usでした。</span>
 &nbsp;</p>
<p>&nbsp;<span>INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>組込みシステムの常套手段として、SINの計算をしないでテーブルを参照する方法を使います。</span>
 &nbsp;</p>
<p>&nbsp;<span>下記のように０度から360度までを100等分して計算したSIN値を使用します。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== sinTbl.h ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>const float sinTbl[] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>0,0.06279052,0.1253332,0.1873813,0.2486899,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.309017,0.3681245,0.4257793,0.4817537,0.5358268,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.5877852,0.637424,0.6845471,0.7289686,0.7705132,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.809017,0.8443279,0.8763067,0.9048271,0.9297765,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.9510565,0.9685832,0.9822872,0.9921147,0.9980267,</span>
 &nbsp;</p>
<p>&nbsp;<span>1,0.9980267,0.9921147,0.9822872,0.9685832,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.9510565,0.9297765,0.9048271,0.8763067,0.8443279,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.809017,0.7705132,0.7289686,0.6845471,0.637424,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.5877852,0.5358268,0.4817537,0.4257793,0.3681245,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.309017,0.2486899,0.1873813,0.1253332,0.06279052,</span>
 &nbsp;</p>
<p>&nbsp;<span>0,-0.06279052,-0.1253332,-0.1873813,-0.2486899,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.309017,-0.3681245,-0.4257793,-0.4817537,-0.5358268,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.5877852,-0.637424,-0.6845471,-0.7289686,-0.7705132,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.809017,-0.8443279,-0.8763067,-0.9048271,-0.9297765,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.9510565,-0.9685832,-0.9822872,-0.9921147,-0.9980267,</span>
 &nbsp;</p>
<p>&nbsp;<span>-1,-0.9980267,-0.9921147,-0.9822872,-0.9685832,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.9510565,-0.9297765,-0.9048271,-0.8763067,-0.8443279,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.809017,-0.7705132,-0.7289686,-0.6845471,-0.637424,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.5877852,-0.5358268,-0.4817537,-0.4257793,-0.3681245,</span>
 &nbsp;</p>
<p>&nbsp;<span>-0.309017,-0.2486899,-0.1873813,-0.1253332,-0.06279052</span>
 &nbsp;</p>
<p>&nbsp;<span>};</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>また、位相遅れを角度ではなくて、テーブルオフセットに変更しました。</span>
 &nbsp;</p>
<p>&nbsp;<span>位相遅れ用VRで０度から72度に相当する０から20にしています。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>//extern double g_delay ;</span>
<span>//位相遅れ（角度）</span>
 &nbsp;</p>
<p>&nbsp;<span>extern int g_delay ;</span>
<span>//位相遅れ（テーブルオフセット）</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void Analog()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp;位相遅れ</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>g_delay = ( adcVal[P_Ai03] * 1.570) / 3800 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = adcVal[P_Ai03] / 190 ;</span>
<span>//0..72degree</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//#include &lt;math.h&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "sinTbl.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// Global data</span>
 &nbsp;</p>
<p>&nbsp;<span>//double g_delay ;</span>
<span>//位相遅れ（角度）</span>
 &nbsp;</p>
<p>&nbsp;<span>int g_delay ;</span>
<span>//位相遅れ（テーブルオフセット）</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>g_delay = 0.0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU25.TSR.BIT.CMFU == 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU25.TSR.BIT.CMFU = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//U phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int step1 = pitch ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double val = sinTbl[step1] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[0] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR0 = g_voltage[0] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int step2 = step1 - g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( step2 &lt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step2 += 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sinTbl[step2] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[0] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DAC.DADR1 = g_current[0] &gt;&gt; 4 ;//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//V phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step1 += 33 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( step1 &gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step1 -= 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sinTbl[step1] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[1] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>DAC.DADR1 = g_voltage[1] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step2 = step1 - g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( step2 &lt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step2 += 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sinTbl[step2] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[1] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//W phase</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step1 += 33 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( step1 &gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step1 -= 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sinTbl[step1] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_voltage[2] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>DAC.DADR1 = g_voltage[2] &gt;&gt; 4 ;</span>
<span>//12bit =&gt; 8 bit</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step2 = step1 - g_delay ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( step2 &lt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>step2 += 100 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>val = sinTbl[step2] * RATE + 2047;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>g_current[2] = (unsigned int)val ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++pitch &gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>pitch = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( nowRpm != oldRpm )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>oldRpm = nowRpm ;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU25.TGRU = NUMERATOR / nowRpm ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>テーブル参照に切り替えたので、この割り込みの処理時間は、184us から30usまで減少しました。</span>
 &nbsp;</p>
<p>&nbsp;<span>運転ステージでのメインサイクル時間は、格段と改良されました。</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.5ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>回転数を2000rpm以上に上げても、システムはもう停止しません。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-10">
<span>[7]&nbsp;間引き</span>
</a>
</h1>
<p>&nbsp;<span>現在は下図のように、三相交流の波形を同時に、毎サイクル計算しています。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000029.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>しかし、隣り合う波形に大きな相違はないので、毎サイクル計算する必要はありません。</span>
 &nbsp;</p>
<p>&nbsp;<span>次図のように、各相を順に計算するようにしてみましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000011.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>enum { U_PHASE, V_PHASE, W_PHASE };</span>
 &nbsp;</p>
<p>&nbsp;<span>static short order ;</span>
<span>//計算順序</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitAdc()</span>
<span>/*初期化部*/</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>order = U_PHASE;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == U_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;U_WB, adcRaw[4], adcRaw[5] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = V_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else if ( order == V_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;V_WB, adcRaw[6], adcRaw[7] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = W_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADCR.BIT.ADST = 1 ;</span>
<span>//ADC2変換スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[11] = ADC2.ADDR11 ;</span>
<span>//回転数変更VR</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == W_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;W_WB, adcRaw[8], adcRaw[9] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = U_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 10 ; n &lt; 12 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で運転ステージでのメインサイクル時間は、ほとんど変わりません。</span>
 &nbsp;</p>
<p>&nbsp;<span>さらに、改良出来ないか、調べましょう。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h2>
<a id="calibre_link-11">
<span>(1)&nbsp;相間の間隔</span>
</a>
</h2>
<p>&nbsp;<span>現状では、毎回200usの割り込みが掛かっているので、他の動作にやや支障が出ます。</span>
 &nbsp;</p>
<p>&nbsp;<span>一つの相の計算が終わってから、少なくとも10msは何もしない区間です。</span>
 &nbsp;</p>
<p>&nbsp;<span>200usの割り込みを、この区間だけ止めるのは如何でしょうか？</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000027.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>また、周期、電圧、電流、電力は制御に直接に使ってはいないので、短周期で計算する必要がありません。ここでは10msではなくて50msの間隔を空けることにします。この区間を作成するのに、タイマーMTU2S5を使用します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;hwsetup.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//Interrupt priority</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>INTC.IPR13.BIT._MTU2S5 =&nbsp;8&nbsp;;</span>
<span>//MTU2S5.TIER.BIT.TGIEA 相間間隔に使用</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//Multifunction timer</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//using the MTU2S channel 5U</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TCRU.BIT.TPSC = 3 ;</span>
<span>//MTU2S clock :64/50MHz = 1.28us</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TIORU.BIT.IOC = 0 ;</span>
<span>//TIC5U&nbsp; compare match&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TIER.BIT.TGIEU = 1 ;</span>
<span>//1：CMFU5&nbsp; interrupt</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TCCR.BIT.CLRU = 1 ;</span>
<span>//1：TCNTU_5 clear</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TCNTU = 0 ;</span>
<span>// Timer counter</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>MTU2S5.TGRU = 7813 ;</span>
<span>// 7813 * 1.28us = 10ms</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU2S5.TGRU = 39063 ;</span>
<span>// 39063 * 1.28us = 50ms</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>一つの相の計算が終わったら、割り込み用のタイマーを止めて、相間間隔用のタイマーをスタートします。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == U_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;U_WB, adcRaw[4], adcRaw[5] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add&nbsp;&amp; modify&nbsp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2.TSTR.BIT.CST0 = 0 ;</span>
<span>//MTU20ストップ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2S5.TSTR.BIT.CSTU = 1 ;</span>
<span>//MTU2S5Uスタート</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = V_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else if ( order == V_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;V_WB, adcRaw[6], adcRaw[7] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add&nbsp;&amp; modify&nbsp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2.TSTR.BIT.CST0 = 0 ;</span>
<span>//MTU20ストップ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2S5.TSTR.BIT.CSTU = 1 ;</span>
<span>//MTU2S5Uスタート</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = W_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == W_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( Prepare( &amp;W_WB, adcRaw[8], adcRaw[9] ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add&nbsp;&amp; modify&nbsp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2.TSTR.BIT.CST0 = 0 ;</span>
<span>//MTU20ストップ</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU2S5.TSTR.BIT.CSTU = 1 ;</span>
<span>//MTU2S5Uスタート</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>order = U_PHASE ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>// 220 MTU2S MTU5S TGIU5</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2S_MTU5S_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU2S5.TSR.BIT.CMFU == 1 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU2S5.TSR.BIT.CMFU = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU2.TSTR.BIT.CST0 = 1 ;</span>
<span>//MTU20スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU2S5.TSTR.BIT.CSTU = 0 ;</span>
<span>//MTU2S5Uストップ</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点でも運転ステージでのメインサイクル時間は、以前とほとんど同じです。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-12">
<span>(2)&nbsp;実用計算</span>
</a>
</h2>
<p>&nbsp;<span>さらに、交流波形以外のアナログ入力データは高速で変換する必要がありません。</span>
 &nbsp;</p>
<p>&nbsp;<span>今まで200msの割り込みが200usになり、無駄な計算をしているので、これを変更します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>static short count ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitAdc()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>count = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI0(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( count == 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 2 ; n &lt; 4 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adcBuf[n] -= (long)adAve[n][adPtr] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adAve[n][adPtr] = adcRaw[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adcBuf[n] += (long)adcRaw[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC1.ADCR.BIT.ADST = 1 ;</span>
<span>//ADC1変換スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( count == 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 10 ; n &lt; 12 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adcBuf[n] -= (long)adAve[n][adPtr] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adAve[n][adPtr] = adcRaw[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adcBuf[n] += (long)adcRaw[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++adPtr &gt;= AVEMAX )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>adPtr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC0.ADANSR.BIT.ANS2 = 0 ;</span>
<span>// 2 スロットルポジション</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC0.ADANSR.BIT.ANS3 = 0 ;</span>
<span>// 3 冷却水温</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADANSR.BIT.ANS2 = 0 ;</span>
<span>//10 表示選択VR</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADANSR.BIT.ANS3 = 0 ;</span>
<span>//11 回転数変更VR</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++count &gt;= 100 )</span>
<span>//20ms/200us = 100</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>count = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC0.ADANSR.BIT.ANS2 = 1 ;</span>
<span>// 2 スロットルポジション</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC0.ADANSR.BIT.ANS3 = 1 ;</span>
<span>// 3 冷却水温</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADANSR.BIT.ANS2 = 1 ;</span>
<span>//10 表示選択VR</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADANSR.BIT.ANS3 = 1 ;</span>
<span>//11 回転数変更VR</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>これは大きな時間の節約にはなりません。</span>
 &nbsp;</p>
<p>&nbsp;<span>次に、回転数の計測を検討しましょう。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-13">
<span>[8]&nbsp;回転数計算の再考</span>
</a>
</h1>
<p>&nbsp;<span>現在では、すべてのクランクパルス入力で計算処理をしていますが、これも隣り合うクランクパルスで大きく変化するものではありません。</span>
 &nbsp;</p>
<p>&nbsp;<span>例えば、間引きして充分と思いますので、2パルスに１回計算するように変更してみましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000007.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>さらに回転数が2000rpmを越えると、高回転異常になるので、2000rpmを越える計算は不要としています。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Rotate.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>enum {STOP, MEDIUM, HIGH };</span>
 &nbsp;</p>
<p>&nbsp;<span>static short speedFlag ;</span>
<span>//回転確認</span>
 &nbsp;</p>
<p>&nbsp;<span>static short working ;</span>
<span>//データ間引き用</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitRotate()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>speedFlag = STOP ;</span>
 &nbsp;</p>
<p>&nbsp;<span>working&nbsp; = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU2_TGIA2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU22.TSR.BIT.TGFA )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (( ctrBuf[0] &gt; 0 ) &amp;&amp; ( newCount &gt;= ( ctrBuf[1] + ctrBuf[2] )))</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>working = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else if ( speedFlag &lt;= MEDIUM )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++working &amp; 0x01 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//中央値を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ctrBuf[0] = ctrBuf[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>rpmPtr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void WatchRotation()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sure &gt;= MAXSURE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( speedFlag != STOP )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>InitRotate();</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sure = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sure++;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>oldPtr = rpmPtr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( newCount &lt; HIGHCTR )</span>
<span>//2000rpm</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>speedFlag = HIGH ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>SetError(ERR_7&nbsp;);</span>
<span>//高回転</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>speedFlag = MEDIUM ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sure = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>int&nbsp;GetRotation( int val[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = speedFlag ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = nowRpm;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>これで他の処理に幾分かのMPU時間を回せると思います。</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で運転していない時のメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.4ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>で、1500rpmでの通常運転時には</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.5ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>です。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-14">
<span>[9]&nbsp;周期の計算</span>
</a>
</h1>
<p>&nbsp;<span>次は周期を求めて、正しい周波数の交流を発電しているかを知る必要があります。また、周期が分かれば、電圧や電流の計算範囲を得ることが出来ます。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//周期の計算</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool CalcHelz( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//最初から上り勾配</span>
 &nbsp;</p>
<p>&nbsp;<span>//ゼロクロス点を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>int m, x, y1, y2;</span>
 &nbsp;</p>
<p>&nbsp;<span>for (m = 0; m &lt; HEAD; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y1 = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y2 = sp-&gt;voltBuf[m + 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ((y1 &lt; MIDVAL) &amp;&amp; (y2 &gt;= MIDVAL))</span>
<span>//ゼロクロス点を越えた</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//xa-x1=(ya-y1)*(x2-x1)/(y2-y1) を求める&nbsp; ya=MIDVAL</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>// x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[0] = m + 1;</span>
<span>//x2: ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[1] = x;</span>
<span>//xa-x1 計算値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if (m &gt;= HEAD)</span>
<span>//見つからない</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>//calcPtrから戻る方向でゼロクロス点を探す</span>
 &nbsp;</p>
<p>&nbsp;<span>for (m = sp-&gt;wavePtr - 1; m &gt; TAIL; m--)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y1 = sp-&gt;voltBuf[m - 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y2 = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ((y1 &gt; MIDVAL) &amp;&amp; (y2 &lt;= MIDVAL)) //ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//d3=xb-x1=(yb-y1)*(x2-x1)/(y2-y1) を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//x1=m, x2=m+1</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>//x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[2] = m;</span>
<span>//x4: ２回目ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[3] = x;</span>
<span>//d3 = xb-x3計算値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//Period=d1+d2+d3</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//Period=(x4-x2)*XPITCH-(xa-x1) + (xb-x3)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;result[4] = (sp-&gt;result[2] -&nbsp;sp-&gt;result[0]) * XPITCH -&nbsp;sp-&gt;result[1] +&nbsp;sp-&gt;result[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//周期 at 200us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if (sp-&gt;result[4] &gt; 1000)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;helz = (int)(5000000L /&nbsp;sp-&gt;result[4]);</span>
<span>//周期 us =&gt;0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return true;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-15">
<span>(1)&nbsp;周期の確認</span>
</a>
</h2>
<p>&nbsp;<span>求めた周期をLCD画面に表示しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static const char scGene2[][21] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>{"U&nbsp; 00.0 Hz&nbsp;&nbsp;&nbsp; 000 pV"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"V&nbsp; 00.0 Hz&nbsp;&nbsp;&nbsp; 000 pV"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"W&nbsp; 00.0 Hz&nbsp;&nbsp;&nbsp; 000 pV"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"Cw 000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "}};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//発電出力 for LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>int&nbsp;GetGenerate2( int val[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = U_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = V_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[2] = W_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[3] = U_WB.peak ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[4] = V_WB.peak ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[5] = W_WB.peak ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[6] = W_WB.check[3] ;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[7] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return 8 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetGeneMsg2( int val[], char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char line[22], temp[8], temp2[4]&nbsp; ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[0] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scGene2[n], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] / 10, temp );</span>
<span>&nbsp;//Frequency 00Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 2, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, "." );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] % 10, temp2 ); // Frequency 0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[3], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3], temp );//Peak voltage 000V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 3, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[14], temp, 3 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( line, scGene2[3], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoa2( val[6], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>adjust( temp, 6, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( &amp;line[3], temp, 6 );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoa2( val[7], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>adjust( temp, 6, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( &amp;line[14], temp, 6 );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>表示する項目が増えてきたので、優先度の低いものは、コメントアウトして調整して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Display.cpp&nbsp;======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void DispLCD()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>case&nbsp;D_Generate2&nbsp;:</span>
<span>//発電出力2</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DispFunc( GetGenerate2, GetGeneMsg2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>selectLED = L_ADC ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>では実行して下さい。回転数を変更すると、周期が変わるのが分かりますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で、運転ステージでのメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.6ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>依然として高速に維持されています。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<span>&nbsp;</span>
<a id="calibre_link-16">
<span>[10]&nbsp;電圧、電流の計算</span>
</a>
</h1>
<p>&nbsp;<span>周期が正しく求められたら、それに基づいて電圧と電流が計算出来ます。</span>
 &nbsp;</p>
<p>&nbsp;<span>実際の入力波形は正弦波ではなく、ノイズが含まれていて、歪みのある波形ですから、波高値から実効値を求めることは出来ません。</span>
 &nbsp;</p>
<p>&nbsp;<span>ここでは原理的な方法で、入力波形を微小部分に分けて、面積を求める方法で行います。</span>
 &nbsp;</p>
<p>&nbsp;<span>周期を求めた直後に、電圧と電流の計算を追加します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool CalcHelz( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>if (sp-&gt;result[4] &gt; 1000)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;helz = (int)(5000000L /&nbsp;sp-&gt;result[4]);</span>
<span>//周期 us =&gt;0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電圧の積分を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double sum = 0.0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>double temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int top = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//半周期分</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m =&nbsp;sp-&gt;result[0]; m &lt;=&nbsp;sp-&gt;result[2]; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sp-&gt;voltBuf[m] - MIDVAL;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sum += temp * temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (sp-&gt;voltBuf[m] &gt; top)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>top = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m =&nbsp;sp-&gt;result[2] -&nbsp;sp-&gt;result[0] + 1;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sqrt(sum / m);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//実際の値に変換する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2047 --- 4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2.5V --- 5V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//-500V --- 0V&nbsp;&nbsp; --- 500V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//volt = (int)((temp * MAXVOLT) / MIDVAL);</span>
<span>//V, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;volt = (int)((temp * MAXVOLT * 10) / MIDVAL);</span>
<span>//0.1V, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;peak = (int)(((top - MIDVAL) * MAXVOLT) / MIDVAL);</span>
<span>//V, top=0...4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電流の積分を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sum = 0.0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//半周期分</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m =&nbsp;sp-&gt;result[0]; m &lt;=&nbsp;sp-&gt;result[2]; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sp-&gt;currBuf[m] - MIDVAL;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sum += temp * temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m =&nbsp;sp-&gt;result[2] -&nbsp;sp-&gt;result[0] + 1;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sqrt(sum / m);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//実際の値に変換する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2047 --- 4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2.5V --- 5V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//-100A --- 0V&nbsp;&nbsp; ---&nbsp;100A</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;curr = (int)((temp * MAXCURR * 10) / MIDVAL);</span>
<span>//0.1A, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return true;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-17">
<span>(1)&nbsp;電圧、電流の確認</span>
</a>
</h2>
<p>&nbsp;<span>では計算した値をLCD画面で確認しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static const char scGene[][21] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>{"U&nbsp; 000.0 V&nbsp;&nbsp; 00.0 A "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"V&nbsp; 000.0 V&nbsp;&nbsp; 00.0 A "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"W&nbsp; 000.0 V&nbsp;&nbsp; 00.0 A "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"Cu 000000&nbsp; Cv 000000"}};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//発電出力 for LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>int&nbsp;GetGenerate( int val[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = U_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = V_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[2] = W_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[3] = U_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[4] = V_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[5] = W_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[6] =&nbsp;U_WB.check[3] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[7] = V_WB.check[3] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return 8 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetGeneMsg( int val[], char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char line[22], temp[8], temp2[4]&nbsp; ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[0] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scGene[n], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] / 10, temp );</span>
<span>//Voltage 000V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 3, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, "." );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] % 10, temp2 );</span>
<span>// Voltage 0.1V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[3], temp, 5 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3] / 10, temp );</span>
<span>//Current 00A</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 2, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, "." );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3] % 10, temp2 );</span>
<span>// Current 0.1A</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[13], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( line, scGene[3], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 2 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+6], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 6, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[3+n*11], temp, 6 );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//For LCD display</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetAllVal( int val[])</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = adcVal[P_Ai02] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = adcVal[P_Ai03] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[2] = adcVal[P_Ai10] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[3] = adcVal[P_Ai11] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[4] = U_WB.currBuf[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[5] = U_WB.currBuf[10] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[6] = U_WB.currBuf[20] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[7] = U_WB.currBuf[30] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>return 8 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Display.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void DispLCD()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>case&nbsp;D_Generate&nbsp;:</span>
<span>//発電出力1</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DispFunc( GetGenerate, GetGeneMsg );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>selectLED = L_ADC ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>では、実行してLCD画面で確認して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で、1500rpmで運転時のメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.5ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>です。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-18">
<span>[11]&nbsp;電力の計算</span>
</a>
</h1>
<p>&nbsp;<span>次は、電圧と電流の位相差を求めて、有効電力を計算します。</span>
 &nbsp;</p>
<p>&nbsp;<span>力率の計算では、cosの計算の代わりに0度から90度までを1.8度毎に計算したテーブルを使います。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== cosTbl.h ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>const float cosTbl[] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>1,0.9995065,0.9980267,0.995562,0.9921147,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.9876884,0.9822872,0.9759167,0.9685832,0.9602937,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.9510565,0.9408808,0.9297765,0.9177547,0.9048271,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.8910065,0.8763067,0.860742,0.8443279,0.8270805,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.809017,0.790155,0.7705132,0.750111,0.7289686,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.7071068,0.6845471,0.6613119,0.637424,0.6129071,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.5877852,0.5620834,0.5358268,0.5090414,0.4817537,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.4539905,0.4257793,0.3971479,0.3681245,0.3387379,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.309017,0.2789911,0.2486899,0.2181432,0.1873813,</span>
 &nbsp;</p>
<p>&nbsp;<span>0.1564345,0.1253332,0.09410831,0.06279052,0.03141076</span>
 &nbsp;</p>
<p>&nbsp;<span>};</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>#include "cosTbl.h"</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>#define PI&nbsp;&nbsp;&nbsp; 3.14159265</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool CalcHelz( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;curr = (int)((temp * MAXCURR * 10) / MIDVAL);</span>
<span>//0.1A, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電流のゼロクロス点を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int n =&nbsp;sp-&gt;result[0] + HEAD ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m =&nbsp;sp-&gt;result[0]; m &lt; n ; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y1 = sp-&gt;currBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>y2 = sp-&gt;currBuf[m + 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ((y1 &lt; MIDVAL) &amp;&amp; (y2 &gt;= MIDVAL))</span>
<span>//ゼロクロス点を越えた</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//xa-x1=(ya-y1)*(x2-x1)/(y2-y1) を求める&nbsp; ya=MIDVAL</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>// x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[5] = m + 1;</span>
<span>//x2: ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( m &lt; n )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電圧と電流の位相差を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = sp-&gt;result[2] - sp-&gt;result[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( m &gt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = ((sp-&gt;result[5] - sp-&gt;result[0] ) * 100 ) /&nbsp;m&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//offset</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( sp-&gt;theta &lt; 50 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;check[3] += 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[4] =&nbsp;sp-&gt;result[0];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[5] =&nbsp;sp-&gt;result[2];</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return true;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-19">
<span>(1) 電力、力率の確認</span>
</a>
</h2>
<p>&nbsp;<span>LCD画面で確認しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static const char scGene3[][21] = {</span>
 &nbsp;</p>
<p>&nbsp;<span>{"Upf&nbsp; 0.000&nbsp;&nbsp; 00.0 KW"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"Vpf&nbsp; 0.000&nbsp;&nbsp; 00.0 KW"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"Wpf&nbsp; 0.000&nbsp;&nbsp; 00.0 KW"},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 000000&nbsp; "}};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//発電出力 for LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>int&nbsp;GetGenerate3( int val[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>double pf =&nbsp;cosTbl[U_WB.theta];</span>
<span>//Power factor</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[0] = (int)( pf * 1000.0 );&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電力＝電圧＊電流＊力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[3] = (int)(( U_WB.volt * U_WB.curr * pf ) / 10000.0 );</span>
<span>//0.1KW</span>
 &nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;<span>pf =&nbsp;cosTbl[V_WB.theta];</span>
<span>//Power factor</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[1] = (int)( pf * 1000.0 );&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電力＝電圧＊電流＊力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[4] = (int)(( V_WB.volt * V_WB.curr * pf ) / 10000.0 );</span>
<span>//0.1KW</span>
 &nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;<span>pf =&nbsp;cosTbl[W_WB.theta];</span>
<span>//Power factor</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[2] = (int)( pf * 1000.0 );&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電力＝電圧＊電流＊力率</span>
 &nbsp;</p>
<p>&nbsp;<span>val[5] = (int)(( W_WB.volt * W_WB.curr * pf ) / 10000.0 );</span>
<span>//0.1KW</span>
 &nbsp;</p>
<p>&nbsp;<span>val[6] = U_WB.check[4] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>val[7] = U_WB.check[5] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return 8 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//LCD</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetGeneMsg3( int val[], char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char line[22], temp[8], temp2[4]&nbsp; ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[0] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scGene3[n], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] / 1000, temp );</span>
<span>&nbsp;//pf</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, "." );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n] % 1000, temp2 );</span>
<span>&nbsp;//pf 0.000</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp2, 3, '0' );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[5], temp, 5 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3] / 10, temp );//Power 0.1KW</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, "." );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoa2( val[n+3] % 10, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( temp, temp2 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adjust( temp, 4, ' ' );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( &amp;line[13], temp, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( line, scGene3[3], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoa2( val[6], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>adjust( temp, 6, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( &amp;line[0], temp, 6 );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoa2( val[7], temp );</span>
 &nbsp;</p>
<p>&nbsp;<span>adjust( temp, 6, ' ');</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( &amp;line[12], temp, 6 );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Display.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void DispLCD()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>case&nbsp;D_Generate3&nbsp;:</span>
<span>//発電出力3</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>DispFunc( GetGenerate3, GetGeneMsg3 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>selectLED = L_ADC ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>LCD画面で力率と電力をチェックして下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で、1500rpmで運転時のメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.5ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>です。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>電圧、電流と電力の計算を入れても、なおも高速に維持されています。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-20">
<span>[12]&nbsp;微調整</span>
</a>
</h1>
<p>&nbsp;<span>次に移る前に、細かな調整をして置きます。</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-21">
<span>(1) 計算開始</span>
</a>
</h2>
<p>&nbsp;<span>周期や電圧、電流の計算は、始動後に行うようにします。</span>
 &nbsp;</p>
<p>&nbsp;<span>また、発電電圧が所定の電圧の90%以上になっているかも調べます。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool running ;</span>
<span>//運転中</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitAdc()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>running = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[7] = g_current[1] ;</span>
<span>// 7 発電電流(V)</span>
 &nbsp;</p>
<p>&nbsp;<span>#endif</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( running == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == U_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ADC2.ADCR.BIT.ADST = 1 ;</span>
<span>//ADC2変換スタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_ADC_ADI2(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>adcRaw[11] = ADC2.ADDR11 ;</span>
<span>//&nbsp;回転数変更VR</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( running == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( order == W_PHASE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( count == 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void Analog()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>running = IsRunning();</span>
<span>//運転中か</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( running == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//周期の計算を行う</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( U_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>W_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//発電電圧が充分か調べる</span>
 &nbsp;</p>
<p>&nbsp;<span>bool IsGeneVolt()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>int val = ( U_WB.volt + V_WB.volt + W_WB.volt ) / 3 ;</span>
<span>//0.1V</span>
 &nbsp;</p>
<p>&nbsp;<span>int val2 = ( 2200 * 90 ) / 100 ;</span>
<span>//198.0V</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( val &gt;= val2 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return true ;</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetVoltage()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>return ( U_WB.volt + V_WB.volt + W_WB.volt ) / 3 ;</span>
<span>//0.1V</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetCurrent()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>return ( U_WB.curr + V_WB.curr + W_WB.curr ) / 3 ;</span>
<span>//0.1A</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetHelz()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>return ( U_WB.helz + V_WB.helz + W_WB.helz ) / 3 ;</span>
<span>//0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-22">
<span>(2)&nbsp;波形生成</span>
</a>
</h2>
<p>&nbsp;<span>DACによる波形生成は、スターターが回り、回転数が400rpmを越えた時に開始して、運転停止指示を受けた後に、波形が0Vになった時に終了するようにします。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Dac.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>static bool stopFlag ;</span>
<span>//電圧が0Vになってから出力を停止する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>void InitDac()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>stopFlag = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU5_TGIU5(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++pitch&nbsp;&gt;= 100 )</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>pitch&nbsp;= 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( stopFlag == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>MTU25.TSTR.BIT.CSTU = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//DAC出力を開始する</span>
 &nbsp;</p>
<p>&nbsp;<span>void StartDAC()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>pitch&nbsp;= 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>stopFlag = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU25.TSTR.BIT.CSTU = 1 ;</span>
<span>//MTU25U&nbsp; タイマースタート</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//出力停止</span>
 &nbsp;</p>
<p>&nbsp;<span>void StopDAC()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>stopFlag = true;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-23">
<span>(3) 停止後の処置</span>
</a>
</h2>
<p>&nbsp;<span>また停止後は、交流波形の入力はないので、値が更新されずに表示が残ったままになるのを防止します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Rotate.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void WatchRotation()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sure &gt;= MAXSURE )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( speedFlag != STOP )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>InitRotate();</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ClearAdcData();</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sure = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//停止後に表示が残るのを防ぐ</span>
 &nbsp;</p>
<p>&nbsp;<span>void ClearAdcData()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;U_WB );</span>
<span>//Ｕ相</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;V_WB );</span>
<span>//Ｖ相</span>
 &nbsp;</p>
<p>&nbsp;<span>InitWaveBuf( &amp;W_WB );</span>
<span>//Ｗ相</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//位相遅れ</span>
 &nbsp;</p>
<p>&nbsp;<span>g_delay = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>order = U_PHASE;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h2>
<a id="calibre_link-24">
<span>(4)&nbsp;時分割</span>
</a>
</h2>
<p>&nbsp;<span>周期の計算部で、多くのテーブルスキャンを行っています。しかし、周期や電圧、電流の計算は制御には直接に関わっておらず、高速に値を求める必要はないので、この計算部分を時分割で行うようにしてみます。</span>
 &nbsp;</p>
<p>&nbsp;<span>交流波形構造体の中に、時分割用のシーケンスを追加します。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>//交流波形構造体</span>
 &nbsp;</p>
<p>&nbsp;<span>struct WAVEBUF {</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>short sequence ;</span>
<span>//CalcHelz シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>static void InitWaveBuf( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>sp-&gt;sequence = 0 ;</span>
<span>//CalcHelz シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>周期の計算部のシーケンスを時分割にします。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private data</span>
 &nbsp;</p>
<p>&nbsp;<span>enum { H_HEAD,H_TAIL,H_VOLT,H_CURR,H_PHASE,H_END };</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private function</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>static int CalcHelz( struct WAVEBUF *sp );</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//周期の計算</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; change &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>static int CalcHelz( struct WAVEBUF *sp )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//最初から上り勾配</span>
 &nbsp;</p>
<p>&nbsp;<span>//ゼロクロス点を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>int m, n, x, y1, y2, top;</span>
 &nbsp;</p>
<p>&nbsp;<span>double sum, temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>switch ( sp-&gt;sequence )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_HEAD :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m = 0; m &lt; HEAD; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y1 = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y2 = sp-&gt;voltBuf[m + 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ((y1 &lt; MIDVAL) &amp;&amp; (y2 &gt;= MIDVAL))</span>
<span>//ゼロクロス点を越えた</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//xa-x1=(ya-y1)*(x2-x1)/(y2-y1), ya=MIDVAL</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>// x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[0] = m + 1;</span>
<span>//x2:&nbsp;ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[1] = x;</span>
<span>//xa-x1&nbsp;計算値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[4] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (m &gt;= HEAD)</span>
<span>//見つからない</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;sequence = H_END ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;sequence++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_TAIL :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp;calcPtrから戻る方向でゼロクロス点を探す</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m = sp-&gt;wavePtr - 1; m &gt; TAIL; m--)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y1 = sp-&gt;voltBuf[m - 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y2 = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ((y1 &gt; MIDVAL) &amp;&amp; (y2 &lt;= MIDVAL)) //ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//d3=xb-x1=(yb-y1)*(x2-x1)/(y2-y1)&nbsp;を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//x1=m, x2=m+1</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>//x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[2] = m;</span>
<span>//x4:&nbsp;２回目ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[3] = x;</span>
<span>//d3 = xb-x3計算値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//Period=d1+d2+d3</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//Period=(x4-x2)*XPITCH-(xa-x1) + (xb-x3)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[4] = (sp-&gt;result[2] - sp-&gt;result[0]) * XPITCH - sp-&gt;result[1] + sp-&gt;result[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//周期at 200us</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (sp-&gt;result[4] &lt;= 1000)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;sequence = H_END ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;helz = (int)(5000000L / sp-&gt;result[4]);</span>
<span>//周期 us =&gt;0.1Hz</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;sequence++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_VOLT :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電圧の積分を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sum = 0.0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = 0.0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>top= 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//半周期分</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m = sp-&gt;result[0]; m &lt;= sp-&gt;result[2]; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>temp = sp-&gt;voltBuf[m] - MIDVAL;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sum += temp * temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if (sp-&gt;voltBuf[m] &gt; top)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>top = sp-&gt;voltBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = sp-&gt;result[2] - sp-&gt;result[0] + 1;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sqrt(sum / m);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//実際の値に変換する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2047 --- 4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2.5V --- 5V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//-500V --- 0V&nbsp;&nbsp; --- 500V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//volt = (int)((temp * MAXVOLT) / MIDVAL);</span>
<span>//V, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;volt = (int)((temp * MAXVOLT * 10) / MIDVAL);</span>
<span>//0.1V, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;peak = (int)(((top - MIDVAL) * MAXVOLT) / MIDVAL);</span>
<span>//V, top=0...4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;sequence++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_CURR :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電流の積分を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sum = 0.0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//半周期分</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m = sp-&gt;result[0]; m &lt;= sp-&gt;result[2]; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>temp = sp-&gt;currBuf[m] - MIDVAL;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sum += temp * temp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = sp-&gt;result[2] - sp-&gt;result[0] + 1;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>temp = sqrt(sum / m);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//実際の値に変換する</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2047 --- 4095</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//&nbsp; 0&nbsp;&nbsp; --- 2.5V --- 5V</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//-100A --- 0V&nbsp;&nbsp; --- 100A</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;curr = (int)((temp * MAXCURR * 10) / MIDVAL);</span>
<span>//0.1A, temp=0...2047</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;sequence++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_PHASE :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//電流のゼロクロス点を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n = sp-&gt;result[0] + HEAD ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (m = sp-&gt;result[0]; m &lt; n ; m++)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y1 = sp-&gt;currBuf[m];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>y2 = sp-&gt;currBuf[m + 1];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ((y1 &lt; MIDVAL) &amp;&amp; (y2 &gt;= MIDVAL))</span>
<span>//ゼロクロス点を越えた</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//xa-x1=(ya-y1)*(x2-x1)/(y2-y1), ya=MIDVAL</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x = (MIDVAL - y1) * XPITCH;</span>
<span>// x2-x1 = XPITCH</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>x /= (y2 - y1);</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;result[5] = m + 1;</span>
<span>//x2:&nbsp;ゼロクロス点</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>break;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( m &lt; n )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//電圧と電流の位相差を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>m = sp-&gt;result[2] - sp-&gt;result[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( m &gt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = ((sp-&gt;result[5] - sp-&gt;result[0] ) * PI ) / m ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//radian</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = ((sp-&gt;result[5] - sp-&gt;result[0] ) * 100 ) / m ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//offset</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( sp-&gt;theta &lt; 50 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;check[3] += 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;theta = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[4] = sp-&gt;result[0];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;check[5] = sp-&gt;result[2];</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;sequence++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case H_END :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;sequence = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>default :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;sequence = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>return sp-&gt;sequence&nbsp; ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この周期の計算を呼び出す部分を、下記のように変更します。</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>void Analog()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//周期の計算を行う</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &amp; modify &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( U_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( CalcHelz( &amp;U_WB ) == H_END )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>U_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>U_WB.sequence = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( V_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( CalcHelz( &amp;V_WB ) == H_END )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>V_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>V_WB.sequence = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( W_WB.ready == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( CalcHelz( &amp;W_WB ) == H_END )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>W_WB.ready = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>W_WB.sequence = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>メインサイクル時間を確認して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>この時点で、1500rpmで運転時のメインサイクル時間は</span>
 &nbsp;</p>
<p>&nbsp;<span>１）平均</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>２）最大</span>
<span>3.8ms</span>
 &nbsp;</p>
<p>&nbsp;<span>３）最小</span>
<span>20us</span>
 &nbsp;</p>
<p>&nbsp;<span>でした。</span>
 &nbsp;</p>
<p>&nbsp;<span>測定誤差範囲に入っています。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-25">
<span>[13]&nbsp;パソコンモニター</span>
</a>
</h1>
<p>&nbsp;<span>実機のデバッグがほぼ終了し動作するようになったら、パソコンでモニターすることが必要になります。それは運転状態を連続して記録するとか、携帯などの遠隔システムに異常発生を知らせるためです。</span>
 &nbsp;</p>
<p>&nbsp;<span>パソコンモニターについては、下記の本に詳しく記載しています。</span>
 &nbsp;</p>
<p>&nbsp;<span>"Discover! How?"シリーズの中の"Monitor+Equipment+Visual C#"です。</span>
 &nbsp;</p>
<p>&nbsp;<span>もちろん、あなたがお得意の言語で作成して下されば充分です。</span>
 &nbsp;</p>
<p>&nbsp;<span>これからパソコンモニターに対するインターフェイスを追加しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>この制御ソフトは、パソコン側から指示が来た時にだけ応答する方式です。</span>
 &nbsp;</p>
<p>&nbsp;<span>パソコンからは2種類の指示が送られて来ます。</span>
 &nbsp;</p>
<p>&nbsp;<span>１）指定アドレスからのデータ読出し指示</span>
 &nbsp;</p>
<p>&nbsp;<span>２）指定アドレスにデータの書き込み指示</span>
 &nbsp;</p>
<p>&nbsp;<span>指定アドレスはパソコンモニターとの取り決めで、下記のようにしています。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;pasodef.h&nbsp;======================</span>
 &nbsp;</p>
<p>&nbsp;<span>enum {</span>
<span>//&nbsp;アドレス</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_STATE=0,</span>
<span>//State&nbsp;(25)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_HISTORY=DM_STATE+25,</span>
<span>//履歴 (12)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_ADC=&nbsp;DM_HISTORY+12,</span>
<span>//A/D&nbsp;(16)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_DAC=&nbsp;DM_ADC+16,</span>
<span>//D/A&nbsp;(8)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_CTRL=DM_DAC+8,</span>
<span>//制御値&nbsp;(25)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_CALC=DM_CTRL+25,</span>
<span>//計算値 (25)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_INOUT=DM_CALC+25,</span>
<span>//DI/DO&nbsp;(6)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_OUTCLR=DM_INOUT+6,</span>
<span>//出力クリア命令(1)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_REMO=DM_OUTCLR+1,</span>
<span>//リモート&nbsp;(20)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_TMRNUM=&nbsp;DM_REMO+20,</span>
<span>//タイマーの数(1)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_CNTLNUM=DM_TMRNUM+1,</span>
<span>//制御定数の数(1)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_TMRTBL=DM_CNTLNUM+1,</span>
<span>//タイマー時間テーブル(100)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_TMSTAT=DM_TMRTBL+100,</span>
<span>//タイマーの状態(40)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_CTRLTBL=DM_TMSTAT+40,</span>
<span>//制御定数テーブル(100)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_TMSET=DM_CTRLTBL+100,</span>
<span>//内蔵時計の設定(10)</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_REAL=DM_TMSET+10,</span>
<span>//実測値(25)</span>
 &nbsp;</p>
<p>&nbsp;<span>MAXDATA=DM_REAL+25</span>
 &nbsp;</p>
<p>&nbsp;<span>};</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>パソコンとの通信規約は下記の通りです。</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000023.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>一般的な通信フォーマットは下記の通りです。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000003.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000018.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(1)&nbsp;読出し指示</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000031.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(2)&nbsp;書き込み指示</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000014.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>先ず、ここまでの範囲で通信プログラムの大枠を作りましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-26">
<span>(1) 読出し指示</span>
</a>
</h2>
<p>&nbsp;<span>パソコンモニターからの読出し指示に対して下記のように応答します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// Private function</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetHappen( char *s&nbsp; );</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetHistory( char *s );</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetGroup2( char *s );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// モニター読み出し指示</span>
 &nbsp;</p>
<p>&nbsp;<span>//[@01ssRDaaaaddddff*¥r]</span>
 &nbsp;</p>
<p>&nbsp;<span>static void ReadMonitor( char *s )</span>
<span>//aaaadddd</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char buff[6] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( buff, s, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[4] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int addr = htoi4( buff );</span>
<span>// 読み出し開始アドレス</span>
 &nbsp;</p>
<p>&nbsp;<span>s += 4;</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( buff, s, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[4] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int size = htoi4( buff );</span>
<span>// 読み出しＷＯＲＤ数</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>strcpy( txBuf,"@" );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( query, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( txBuf, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>//@01ssRDaaaa%%%%</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( txBuf,"00RD" );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( addr, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( txBuf, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = txBuf + 11 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int n1, n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( addr &gt;= DM_STATE &amp;&amp; addr &lt;&nbsp;DM_HISTORY&nbsp;)</span>
<span>//装置概要（第１グループ）</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetGroup1( t );</span>
<span>//回転数、発電電圧、電流、電力</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;=&nbsp;&nbsp;DM_HISTORY&nbsp;&amp;&amp; addr &lt; DM_ADC )</span>
<span>//故障履歴</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>switch ( addr -&nbsp;DM_HISTORY&nbsp;)</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case 0 :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case 1 :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetHappen( t );</span>
<span>//異常履歴状態読出し</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case 2 :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetHistory( t );</span>
<span>//異常履歴詳細読出し</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_ADC &amp;&amp; addr &lt;&nbsp;DM_DAC&nbsp;)</span>
<span>//アナログ入力電圧</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetAdcData( t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_CTRL &amp;&amp; addr &lt; DM_CALC )</span>
<span>//運転関係（第2グループ）</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetGroup2( t );</span>
<span>//運転ステージ、シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_INOUT &amp;&amp; addr &lt; DM_OUTCLR )</span>
<span>//デジタル入出力</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = GetInData( t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n2 = GetOutData( t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMRNUM &amp;&amp; addr &lt; DM_TMRTBL )</span>
<span>//テ－ブルの数</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>switch ( addr - DM_TMRNUM )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case 0 :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( TMRNUM, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>case 1 :</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( CTRLNUM, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>break ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMRTBL &amp;&amp; addr &lt; DM_TMSTAT )</span>
<span>//タイマ－時間</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = TimerTime( addr - DM_TMRTBL, size, t ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMSTAT &amp;&amp; addr &lt; DM_CTRLTBL )</span>
<span>//タイマ－の状態</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n2 = TimerState( t ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_CTRLTBL &amp;&amp; addr &lt; DM_TMSET )</span>
<span>//制御定数</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = ReadCtrl( addr - DM_CTRLTBL, size, t ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += n1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMSET &amp;&amp; addr &lt; DM_REAL )</span>
<span>//内蔵時計の読み出し</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>unsigned char caleTbl[7] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ReadTimeRTC( caleTbl );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ConvertFromRTC( caleTbl );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n1 = 0 ; n1 &lt; 7 ; n1++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( caleTbl[n1], t ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>n1 = strlen( txBuf ) + 3;</span>
<span>//3= FCS(2) + *(1)</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( n1, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>//@01ssRDaaaa%%%%</span>
 &nbsp;</p>
<p>&nbsp;<span>txBuf[3] = buff[0];</span>
 &nbsp;</p>
<p>&nbsp;<span>txBuf[4] = buff[1];</span>
 &nbsp;</p>
<p>&nbsp;<span>n2 = strlen( txBuf );</span>
 &nbsp;</p>
<p>&nbsp;<span>t = txBuf +n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//ＦＣＳを計算する</span>
 &nbsp;</p>
<p>&nbsp;<span>char *r = txBuf ;</span>
 &nbsp;</p>
<p>&nbsp;<span>char c = *r++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>while ( r &lt; t )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>c ^= *r++ ;</span>
<span>//ＥＯＲ</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( c, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t++ = '*' ;</span>
<span>//ターミネーター</span>
 &nbsp;</p>
<p>&nbsp;<span>*t++ = '¥r' ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-27">
<span>(2) 読出し指示応答</span>
</a>
</h2>
<p>&nbsp;<span>読出し指示に対する応答データの内容は下記の通りです。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(1)&nbsp;装置の状態を把握する項目</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000004.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//装置の状態</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetGroup1( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( GetRpm(), t );</span>
<span>//現在回転数</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int data[16] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>GetDetails( data );</span>
<span>//各相計算値詳細</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 15 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( data[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//各相計算値詳細 for PC</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetDetails( int data[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>int val[8];</span>
 &nbsp;</p>
<p>&nbsp;<span>GetGenerate3( val );</span>
 &nbsp;</p>
<p>&nbsp;<span>data[0] = U_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[1] = U_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[2] = val[3] ;</span>
<span>//電力</span>
 &nbsp;</p>
<p>&nbsp;<span>data[3] = val[0] ;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>data[4] = U_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[5] = V_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[6] = V_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[7] = val[4] ;</span>
<span>//電力</span>
 &nbsp;</p>
<p>&nbsp;<span>data[8] = val[1] ;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>data[9] = V_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[10] = W_WB.volt ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[11] = W_WB.curr ;</span>
 &nbsp;</p>
<p>&nbsp;<span>data[12] = val[5] ;</span>
<span>//電力</span>
 &nbsp;</p>
<p>&nbsp;<span>data[13] = val[2] ;</span>
<span>//力率</span>
 &nbsp;</p>
<p>&nbsp;<span>data[14] = W_WB.helz ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(2)&nbsp;運転関係の詳細項目</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000025.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//運転ステージ、スロットルシーケンス for PC</span>
 &nbsp;</p>
<p>&nbsp;<span>//DM_CTRL</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetGroup2( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int data[10];</span>
 &nbsp;</p>
<p>&nbsp;<span>GetOperation( data );</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 9 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( data[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>GetThrottle( data );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( data[0], t );</span>
<span>//スロットルシーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 3 ; n &lt; 6 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( data[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Operation.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//運転ステージ、運転シーケンス</span>
<span>For PC</span>
 &nbsp;</p>
<p>&nbsp;<span>void GetOperation( int data[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>data[0] = runStage ;</span>
<span>//運転ステージ</span>
 &nbsp;</p>
<p>&nbsp;<span>data[1] = runSeq ;</span>
<span>//運転シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>data[2] = engCmd ;</span>
<span>//エンジン運転指示</span>
 &nbsp;</p>
<p>&nbsp;<span>data[3] = engStep ;</span>
<span>//エンジン制御シーケンス</span>
 &nbsp;</p>
<p>&nbsp;<span>data[4] = engState ;</span>
<span>//エンジン状態</span>
 &nbsp;</p>
<p>&nbsp;<span>data[5] = reason ;</span>
<span>//起動準備</span>
 &nbsp;</p>
<p>&nbsp;<span>data[6] = loadIndex ;</span>
<span>//投入負荷</span>
 &nbsp;</p>
<p>&nbsp;<span>data[7] = tryCtr ;</span>
<span>//リトライカウンター</span>
 &nbsp;</p>
<p>&nbsp;<span>data[8] =&nbsp;restart&nbsp;;</span>
<span>//再起動フラグ</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(3)&nbsp;RTCの読出し</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000024.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//RTCレジスタの配列を、このRTCモジュール用に変換が必要</span>
 &nbsp;</p>
<p>&nbsp;<span>//通信からの配列：</span>
 &nbsp;</p>
<p>&nbsp;<span>//秒、分、時、日、月、年、週</span>
 &nbsp;</p>
<p>&nbsp;<span>//このRTCモジュールの配列：</span>
 &nbsp;</p>
<p>&nbsp;<span>//秒、分、時、日、週、月、年</span>
 &nbsp;</p>
<p>&nbsp;<span>//通信からのデータ配列を、このRTCモジュール用に変換</span>
 &nbsp;</p>
<p>&nbsp;<span>static void ConvertToRTC( unsigned char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned char temp[3];</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[0] = buff[4];</span>
<span>//月</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[1] = buff[5];</span>
<span>//年</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[2] = buff[6];</span>
<span>//週</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[4] = temp[2] ;</span>
<span>//週</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[5] = temp[0] ;</span>
<span>//月</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[6] = temp[1] ;</span>
<span>//年</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//このRTCモジュールの配列を、通信用に変換</span>
 &nbsp;</p>
<p>&nbsp;<span>static void ConvertFromRTC( unsigned char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned char temp[3];</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[0] = buff[4];</span>
<span>//週</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[1] = buff[5];</span>
<span>//月</span>
 &nbsp;</p>
<p>&nbsp;<span>temp[2] = buff[6];</span>
<span>//年</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[4] = temp[1] ;</span>
<span>//月</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[5] = temp[2] ;</span>
<span>//年</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[6] = temp[0] ;</span>
<span>//週</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(4)&nbsp;異常状態</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000032.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//異常履歴状態</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetHappen( char *s&nbsp; )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( GetErrorCode(), t );</span>
<span>//エラーコード</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( GetRecCount(), t );</span>
<span>//履歴保存数</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//異常履歴詳細</span>
 &nbsp;</p>
<p>&nbsp;<span>static int GetHistory( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int data[10] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( GetRecord( data ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 0 ; n &lt; 9 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( data[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(5)アナログ入力</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000009.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Analog.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンに送るデータ</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetAdcData( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( adcVal[P_Ai02], t );</span>
<span>// 2 スロットルポジション</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( adcVal[P_Ai03], t );</span>
<span>// 3 冷却水温</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( adcVal[P_Ai10], t );</span>
<span>//10 表示選択VR</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh4( adcVal[P_Ai11], t );</span>
<span>//11 回転数変更VR（テスト用）</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(6)デジタル入出力</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000019.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000028.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Input.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンへのモニター</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetInData( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>struct inCtr *sp ;</span>
 &nbsp;</p>
<p>&nbsp;<span>const bool *sq ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short mask = 0x0001 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short buff[3];</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[0] =&nbsp;</span>
<span>0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = P_Di00 ; n &lt;= P_Di15 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp = &amp;inTbl[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sq = &amp;logic[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sp-&gt;on &gt; MANY )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( *sq == POS )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>buff[0] |= mask ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else if ( sp-&gt;off &gt; MANY )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( *sq == NEG )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>buff[0] |= mask ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>mask &lt;&lt;= 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[1] = buff[2] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( buff[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000002.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Output.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンへのモニタ</span>
 &nbsp;</p>
<p>&nbsp;<span>int GetOutData( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short mask ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short buff[3] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int n1, n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int k = 0 ; k &lt; 3 ; k++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = k * 16 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n2 = n1 + 16 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>buff[k] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>mask = 0x0001 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for (int&nbsp; n = n1 ; n &lt; n2 &amp;&amp; n &lt; OUTNUM ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( BitCheck( n ) == ON )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>buff[k] |= mask ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>mask &lt;&lt;= 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( buff[n], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(7)タイマーの状態</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000013.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000022.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Timer.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンから全てのタイマ－の状態を読み出す</span>
 &nbsp;</p>
<p>&nbsp;<span>int TimerState( char *s )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>int j, k, m, n ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>j = m = 0 ;&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>for (n = 0 ; n &lt; TMRNUM ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>k = timeTbl[n].stat ;</span>
<span>//２ビットで１タイマー状態を作る</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>k &lt;&lt;= m ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>j |= k ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m += 2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( m &gt;= 16 )</span>
<span>//１ＷＯＲＤ分たまったら書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( j, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>j = m = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( m != 0 )</span>
<span>//きっちり１ＷＯＲＤ分で終わっていないときは残りを書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( j, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(8)下記は指定されたアドレスから25short以内で読み出します。</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_TMRTBL</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Timer.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンから指定した範囲のタイマ－設定時間を読み出す</span>
 &nbsp;</p>
<p>&nbsp;<span>int TimerTime( int m, int n, char *s )</span>
<span>// ｍからｎ個</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int j = 0 ; j &lt; n &amp;&amp; m &lt; TMRNUM ; m++, j++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( timeTbl[m].time, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>DM_CTRLTBL</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Eeprom.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンから指定した範囲の制御定数を読み出す</span>
 &nbsp;</p>
<p>&nbsp;<span>int ReadCtrl( int m, int n, char *s )</span>
<span>// ｍからｎ個</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int j = 0 ; j &lt; n &amp;&amp; m &lt; CTRLNUM ; m++, j++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>itoh4( ctrlTbl[m], t );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>t += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>return t - s ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-28">
<span>(3) 書き込み指示応答</span>
</a>
</h2>
<p>&nbsp;<span>パソコンモニターからの書き込み指示に対して下記のように応答します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// モニター書き込み命令</span>
 &nbsp;</p>
<p>&nbsp;<span>//[@01ssWTaaaadddd..ff*¥r]</span>
 &nbsp;</p>
<p>&nbsp;<span>static void WriteMonitor( char *s, int size )</span>
<span>//aaaadddd....dddd</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char buff[6] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int m, n ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short wd ;</span>
 &nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;<span>//s=aaaadddd....</span>
 &nbsp;</p>
<p>&nbsp;<span>strncpy( buff, s, 4 );</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[4] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int addr = htoi4( buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>s += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( addr &gt;=&nbsp;DM_HISTORY&nbsp;&amp;&amp; addr &lt;&nbsp;DM_ADC&nbsp;)</span>
<span>//履歴読出し番号</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (( addr -&nbsp;DM_HISTORY&nbsp;) == 2 )</span>
<span>//履歴読出し番号</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>SetHistory( n );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_CTRL &amp;&amp; addr &lt; DM_CALC )</span>
<span>//制御指示</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//DM_CTRL+0=起動=1、停止=2、リセット=3、非常停止=4</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>SetRunKey( n );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_INOUT &amp;&amp; addr &lt; DM_OUTCLR )</span>
<span>//デジタル出力指示</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ChkInp( P_Di04 ) == ON )</span>
<span>// 4 自動=OFF／手動=ON</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = ( addr - DM_INOUT - 3 ) * 2 ;</span>
<span>// Input = 3 Byte</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( m &gt;= 0 &amp;&amp; m &lt;= 4 )</span>
<span>//0,2,4</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>wd = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>manuOut[m] = wd ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>s += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>wd = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>manuOut[m+1] = wd ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>Mainte( manuOut );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( m = 0 ; m &lt; 6 ; m++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>manuOut[m] = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_OUTCLR &amp;&amp; addr &lt; DM_REMO )</span>
<span>//全デジタル出力OFF指示</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ChkInp( P_Di04 ) == ON )</span>
<span>// 4 自動=OFF／手動=ON</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>OffOutAll();</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMRTBL &amp;&amp; addr &lt; DM_TMSTAT )</span>
<span>//タイマ－時間</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = addr - DM_TMRTBL ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>while ( size-- &gt; 0 )</span>
<span>//size!</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>wd = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>s += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>PutTime( m, wd );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>writeTimeEEPROM( m, wd );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_CTRLTBL &amp;&amp; addr &lt; DM_TMSET )</span>
<span>//制御定数</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m = addr - DM_CTRLTBL ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>while ( size-- &gt; 0 )</span>
<span>//size!</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>wd = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>s += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>SetCtrl( m, wd );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>writeCtrlEEPROM( m, wd );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>m++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else if ( addr &gt;= DM_TMSET &amp;&amp; addr &lt; DM_REAL )</span>
<span>//内蔵時計の設定</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>unsigned char caleTbl[7] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n = 0 ; n &lt; 7 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>wd = htoi4( s ) ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>s += 4 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>caleTbl[n] = (unsigned char)wd ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ConvertToRTC( caleTbl );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>WriteTimeRTC( caleTbl );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>strcpy( txBuf,"@" );</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( query, txBuf+1 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//@01ssWTff* = 10char</span>
 &nbsp;</p>
<p>&nbsp;<span>n = 10;</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( n, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>buff[2] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( txBuf, buff );</span>
 &nbsp;</p>
<p>&nbsp;<span>strcat( txBuf, "WT" );</span>
 &nbsp;</p>
<p>&nbsp;<span>char *t = txBuf + 7 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//ＦＣＳを計算する</span>
 &nbsp;</p>
<p>&nbsp;<span>char *r = txBuf ;</span>
 &nbsp;</p>
<p>&nbsp;<span>char c = *r++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>while ( r &lt; t )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>c ^= *r++ ;</span>
<span>//ＥＯＲ</span>
 &nbsp;</p>
<p>&nbsp;<span>itoh2( c, t );</span>
 &nbsp;</p>
<p>&nbsp;<span>t += 2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t++ = '*' ;</span>
<span>//ターミネーター</span>
 &nbsp;</p>
<p>&nbsp;<span>*t++ = '¥r' ;</span>
 &nbsp;</p>
<p>&nbsp;<span>*t = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000030.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(1)&nbsp;異常履歴</span>
 &nbsp;</p>
<p>&nbsp;<span>読み出したい番号をDM_HISTORYの「異常履歴読み出し番号」に書き込んだ後に、「異常履歴読み出し番号」の読出し指示をすると、該当する履歴が送られて来ます。</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000006.gif" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(2)&nbsp;押しボタン操作</span>
 &nbsp;</p>
<p>&nbsp;<span>パネルの押しボタンを押す代わりに、パソコンからの指示でボタンを操作します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Input.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//パソコンからのボタン操作指示</span>
 &nbsp;</p>
<p>&nbsp;<span>//起動=1、停止=2、リセット=3、非常停止=4</span>
 &nbsp;</p>
<p>&nbsp;<span>void SetRunKey( int n )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( n &gt;= 1 &amp;&amp; n &lt;= 4 )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>struct inCtr *sp ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n += P_Di11 ;</span>
<span>//P_Di12..P_Di15</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp = &amp;inTbl[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;on = LIMIT * 20 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp-&gt;off = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>OnTimer(TM22);</span>
<span>//パソコンキー有効時間</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>void Input()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp++ ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&gt;&gt;&gt; add &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( ChkTimer(TM22) != ON )&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n = P_Di12 ; n &lt;= P_Di15 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>sp = &amp;inTbl[n] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( sp-&gt;on &gt; 0 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>sp-&gt;on-- ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//&lt;&lt;&lt; end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== common.h ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//Timer</span>
 &nbsp;</p>
<p>&nbsp;<span>enum {</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>TM22,</span>
<span>//パソコンキー有効時間</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== timer.h ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>const unsigned short timeBase[TMRNUM] = {</span>
<span>//100ms</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>10,</span>
<span>//TM22</span>
 &nbsp;</p>
<p>&nbsp;<span>:</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000016.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(3)&nbsp;デジタル出力</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Output.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>// メインテナンスモード</span>
 &nbsp;</p>
<p>&nbsp;<span>void Mainte( unsigned short *p )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short&nbsp;indicate, onoff, mask ;</span>
 &nbsp;</p>
<p>&nbsp;<span>int n1, n2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>// １６個毎に処理する</span>
 &nbsp;</p>
<p>&nbsp;<span>for ( int k = 0 ; k &lt; 3 ; k++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n1 = k * 16 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>n2 = n1 + 16 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>indicate&nbsp;= *p++ ;</span>
<span>// 指示有り</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>onoff = *p++ ;</span>
<span>// ＯＮ／ＯＦＦ情報</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>mask = 0x0001 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (&nbsp;indicate&nbsp;)</span>
<span>// 何かの指示有りなら</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = n1 ; n &lt; n2 &amp;&amp; n &lt; OUTNUM ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if (&nbsp;indicate&nbsp;&amp; mask )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( onoff &amp; mask )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>OnOut( n );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>OffOut( n );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>mask &lt;&lt;= 1 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>(4)&nbsp;時間、定数データの書き込み</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Eeprom.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//時間データをEEPROMに書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>bool writeTimeEEPROM( int n, short wd )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( alive == false )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false ;</span>
 &nbsp;</p>
<p>&nbsp;<span>if (!( n &gt;= 0 &amp;&amp; n &lt; TMRNUM ))</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short adrs = EETIME + n * 2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short val = wd ;</span>
 &nbsp;</p>
<p>&nbsp;<span>bool flag = WriteEEPROM(adrs, (unsigned char*)&amp;val, 2);</span>
 &nbsp;</p>
<p>&nbsp;<span>//EEPROMの書き込み時間だけ待つ</span>
 &nbsp;</p>
<p>&nbsp;<span>Wait( 10000 );</span>
<span>//10ms</span>
 &nbsp;</p>
<p>&nbsp;<span>//識別コードを計算して書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>return CalcEEPROM();&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//定数データをEEPROMに書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>bool writeCtrlEEPROM( int n, short nVal )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( alive == false )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false ;</span>
 &nbsp;</p>
<p>&nbsp;<span>if (!( n &gt;= 0 &amp;&amp; n &lt; CTRLNUM ))</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false ;</span>
 &nbsp;</p>
<p>&nbsp;<span>unsigned short adrs = EECTRL + n * 2 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>short val = nVal ;</span>
 &nbsp;</p>
<p>&nbsp;<span>bool flag = WriteEEPROM(adrs, (unsigned char*)&amp;val, 2);</span>
 &nbsp;</p>
<p>&nbsp;<span>//EEPROMの書き込み時間だけ待つ</span>
 &nbsp;</p>
<p>&nbsp;<span>Wait( 10000 );</span>
<span>//10ms</span>
 &nbsp;</p>
<p>&nbsp;<span>//識別コードを計算して書き込む</span>
 &nbsp;</p>
<p>&nbsp;<span>return CalcEEPROM();&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>デバッグのために、パソコンから送られてきた指示をLCD画面に表示出来るようにしておきましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Sci_1.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>static const char&nbsp;scSCI1[][21] = {</span>
<span>//RS232C通信1</span>
 &nbsp;</p>
<p>&nbsp;<span>{"SCI1&nbsp; 19200&nbsp; 8odd1&nbsp; "},</span>
 &nbsp;</p>
<p>&nbsp;<span>{"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "}};</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//LCDからの問い合わせに応答する</span>
 &nbsp;</p>
<p>&nbsp;<span>bool IsRecvData1( bool flag, char buff[] )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>char line[22] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( flag == false )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( buff, scSCI1[0], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( int n = 0 ; n &lt; 3 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scSCI1[1], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( dspOK == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//1st line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( buff, scSCI1[0], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int n = strlen( lcdBuf );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( n &lt;= 20 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//2nd line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcpy( line, lcdBuf );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int m = strlen( line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n = m ; n &lt; 20 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>strcat( &amp;line[n], " " );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//3rd line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scSCI1[1], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//2nd line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, lcdBuf, 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//3rd line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcpy( line, &amp;lcdBuf[20] );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>int m = strlen( line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>for ( n = m ; n &lt; 20 ; n++ )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>strcat( &amp;line[n], " " );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//4th line</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strncpy( line, scSCI1[1], 20 );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, line );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>strcat( buff, "," );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>dspOK = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return true;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>buff[0] = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return false;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>===== Display.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//RS232C&nbsp;通信&nbsp;1</span>
 &nbsp;</p>
<p>&nbsp;<span>static void DispSCI_1()</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( first == true)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>first = false;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>IsRecvData1( false, lcdBuff );</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ShowLcdBuff( 4, 1 );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( IsRecvData1( true, lcdBuff ) == true )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>ShowLcdBuff( 4, 1 );</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000026.jpg" alt="" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>ではコンパイルして、実行してみましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>パソコンモニターと接続して、各種の情報が得られましたか？</span>
 &nbsp;</p>
<p>&nbsp;<span>通常運転時のメインサイクル時間は、最大でも3.8ms程度でした。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<img src="images/000001.jpg" alt="monitorImage" />
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-29">
<span>[14]&nbsp;実機用に変更</span>
</a>
</h1>
<p>&nbsp;<span>さて、いよいよ作成したプログラムを実際の機械で実行する最終段階に入ります。</span>
 &nbsp;</p>
<p>&nbsp;<span>実機を運転する時は、プログラムを下記のように変更する必要があります。</span>
 &nbsp;</p>
<p>&nbsp;<span>１）テスト用の割り込みを停止する。</span>
 &nbsp;</p>
<p>&nbsp;<span>２）実機用のクランクポジションセンサーソフトに変更する。</span>
 &nbsp;</p>
<p>&nbsp;<span>３）下記の制御定数値を実機で測定して設定する。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(1)&nbsp;スターター起動時のスロットル開度（パルス値）=&gt;C00</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(2)&nbsp;負荷投入開始時のスロットル開度（パルス値）=&gt;C01</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(3)&nbsp;スロットルポジション最小値（AD値）=&gt;C02</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;(4)&nbsp;スロットルポジション最大値（AD値）=&gt;C03</span>
 &nbsp;</p>
<p>&nbsp;<span>(5) スロットル可動範囲の最大パルス数&nbsp;=&gt;C11</span>
 &nbsp;</p>
<p>&nbsp;<span>(6) 冷却水温異常値&nbsp;=&gt;C10</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2>
<a id="calibre_link-30">
<span>(1) 実機用に実装</span>
</a>
</h2>
<p>&nbsp;<span>では、実機用のクランクポジションセンサー部を実装します。</span>
 &nbsp;</p>
<p>&nbsp;<span>テストで使ったものと形式は同様ですが、アドレスとレジスタ記号が異なります。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;hwsetup.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//Interrupt priority</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>INTC.IPR09.BIT._MTU21G = 15&nbsp;;</span>
<span>//MTU21.TIER.BIT.TGIEA</span>
 &nbsp;</p>
<p>&nbsp;<span>INTC.IPR09.BIT._MTU21C = 14&nbsp;;</span>
<span>//MTU21.TIER.BIT.TCIEV</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>INTC.IPR10.BIT._MTU22G = 15&nbsp;;</span>
<span>//MTU22.TIER.BIT.TGIEA</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>INTC.IPR10.BIT._MTU22C = 14&nbsp;;</span>
<span>//MTU22.TIER.BIT.TCIEV</span>
 &nbsp;</p>
<p>&nbsp;<span>//</span>
<span>INTC.IPR11.BIT._MTU24G =&nbsp;9&nbsp;;</span>
<span>//MTU24.TIER.BIT.TGIEA&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//マルチファンクションタイマー</span>
 &nbsp;</p>
<p>&nbsp;<span>//-----------------------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//MTU2 チャネル１をクランクポジションセンサーに使用 PE4/TIOC1A</span>
 &nbsp;</p>
<p>&nbsp;<span>//インプットキャプチャで回転数を計測する</span>
 &nbsp;</p>
<p>&nbsp;<span>//PE4/TIOC1A</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TMDR.BYTE = 0 ;</span>
<span>//通常動作</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TCR.BIT.CCLR = 1 ;</span>
<span>//TGRA のインプットキャプチャでTCNT クリア</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TCR.BIT.CKEG = 1 ;</span>
<span>//01：立ち下がりエッジでカウント</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TCR.BIT.TPSC = 3 ;</span>
<span>//周辺クロック：Pφ／64 でカウント 64/50MHz = 1.28us</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TIOR.BIT.IOA = 9 ;</span>
<span>//TIOC1A 端子 01：立ち下がりエッジでカウント</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TIER.BIT.TGIEA = 1 ;</span>
<span>//1：TGFAビットによる割り込み要求（TGIA）を許可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TGR インタラプトイネーブル A&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>MTU21.TIER.BIT.TCIEV = 1 ;</span>
<span>//1：TCFVビットによる割り込み要求（TCIV）を許可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;オーバフローインタラプトイネーブル</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>//ポート機能設定</span>
 &nbsp;</p>
<p>&nbsp;<span>//E port --------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>//クランクポジションセンサー</span>
 &nbsp;</p>
<p>&nbsp;<span>PFC.PEIORL.BIT.B4 = 0 ;</span>
<span>//PE4 TIOC1A 入力&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>PFC.PECRL2.BIT.PE4MD = 6 ;</span>
<span>//PE4 110：TIOC1A 入力（MTU2）</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>実機用のクランクポジションセンサー割り込みを追加します。</span>
 &nbsp;</p>
<p>&nbsp;<span>=====&nbsp;Rotate.cpp ======================</span>
 &nbsp;</p>
<p>&nbsp;<span>//クランクポジションセンサー　MTU2チャネル１</span>
 &nbsp;</p>
<p>&nbsp;<span>// 164 MTU2 MTU1 TGIA1</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU1_TGIA1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU21.TSR.BIT.TGFA )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU21.TSR.BIT.TGFA = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( newCtr &lt; 36 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>newCtr++;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>return ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU21.TCNT = 0 ;</span>
<span>//カウンタークリア</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>newCount = MTU21.TGRA ;</span>
<span>//キャプチャーした値</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>//欠歯を判定する＝前回の値の３倍近い＝２倍を越えているなら欠歯</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if (( ctrBuf[0] &gt; 0 ) &amp;&amp; ( newCount &gt;= ( ctrBuf[1] + ctrBuf[2] )))</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>working = 0;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>else if ( speedFlag &lt;= MEDIUM )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>if ( ++working &amp; 0x01 )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>//中央値を求める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ctrBuf[0] = ctrBuf[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ctrBuf[1] = ctrBuf[2] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>ctrBuf[2] = newCount ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( newCount &gt; ctrBuf[1] )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( ctrBuf[1] &gt; ctrBuf[0] )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = ctrBuf[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else if ( newCount &gt; ctrBuf[0] )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = ctrBuf[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = newCount ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( newCount &gt; ctrBuf[0] )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = newCount ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else if ( ctrBuf[1] &gt; ctrBuf[0] )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = ctrBuf[0] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>else</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>&nbsp;</span>
<span>center = ctrBuf[1] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>// 総和から現在ポイント値を引く</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>rpmSum -= rpmAve[rpmPtr] ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>// 入力値をポイント部へ入れる</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>rpmAve[rpmPtr] = center ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>// 総和に入力値を加える</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>rpmSum += center ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>// ポインタを次に進める</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>if ( ++rpmPtr &gt;= AVENUM )</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>&nbsp;</span>
<span>rpmPtr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>//84msでoverflowする</span>
 &nbsp;</p>
<p>&nbsp;<span>// 168 MTU2 MTU1 TCIV1</span>
 &nbsp;</p>
<p>&nbsp;<span>void INT_MTU2_MTU1_TCIV1(void)</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>if ( MTU21.TSR.BIT.TCFV )</span>
 &nbsp;</p>
<p>&nbsp;<span>{</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>MTU21.TSR.BIT.TCFV = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
<span>newCtr = 0 ;</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>}</span>
 &nbsp;</p>
<p>&nbsp;<span>===========================</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<h2><a id="calibre_link-35"></a>
<a id="calibre_link-31">
<span>(2) 動作確認</span>
</a>
</h2>
<p>&nbsp;<span>では、実機で実行して、次の手順で確認しましょう。</span>
 &nbsp;</p>
<p>&nbsp;<span>異常を感じたら、すぐに緊急停止ボタンを押す、ブレーカーを落とすなど、安全対策を確認してから実行して下さい。</span>
 &nbsp;</p>
<p>&nbsp;<span>１）スタートボタンを押す前に、スロットルの原点復帰が正しく行われましたか？</span>
 &nbsp;</p>
<p>&nbsp;<span>２）スタートボタンを押すと、スロットルが少し開き、スターターが動作しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>３）点火しない時は、何度か繰り返しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>４）点火した時は、さらにスロットルが開き回転数が上昇しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>５）負荷投入ごとに低下する回転数を、回復しようとしていますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>６）全負荷投入後も目標の1500rpm近辺で回転数が安定していますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>７）ここで故意に燃料を止めたら、エンストになりますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>８）エンストしたら自動的に再起動しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>９）制限回数を越えるエンストでは異常停止になりますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>１０）始動時での起動に失敗した時も、再起動しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>１１）運転中に、非常停止ボタンを押すと異常停止し、燃料遮断弁が閉じますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>１２）運転中に、サーマルトリップさせると異常停止し、燃料遮断弁が閉じますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>１３）全負荷投入後、周波数が一定時間以上にわたって許容範囲を逸脱している時に、異常停止しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>１４）同様に、電圧が一定時間以上にわたって許容範囲を逸脱している時に、異常停止しますか？</span>
 &nbsp;</p>
<p>&nbsp;<span>------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>すべてが問題なく機能していたら、完成です！</span>
 &nbsp;</p>
<p>&nbsp;<span>あなたは、ついに目標に到達しました！</span>
 &nbsp;</p>
<p>&nbsp;<span>おめでとうございます！</span>
 &nbsp;</p>
<p>&nbsp;<span>プロとしての実力をしっかりと身に付けられたことと思います。</span>
 &nbsp;</p>
<p>&nbsp;<span>これからは、ご自分の力で未来を切り開き、人のために役立つシステムを構築されることを</span>
 &nbsp;</p>
<p>&nbsp;<span>心から期待します。</span>
 &nbsp;</p>
<p>&nbsp;</p>
<div></div>
<br />
&nbsp;<h1>
<a id="calibre_link-32">
<span>[15]&nbsp;あとがき</span>
</a>
</h1>
<p>&nbsp;<span>応用課程の説明は以上ですが、このプログラムをベースにして、色々な機能を追加し、ソフトウェア作成能力をさらに向上されることを期待します。</span>
 &nbsp;</p>
<p>&nbsp;<span>ここまでの長い道のりを、きっと苦しみながら共に歩んで下さり、深く感謝申し上げます。</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>------------------------------</span>
 &nbsp;</p>
<p>&nbsp;<span>「筆者のエピソード」</span>
 &nbsp;</p>
<p>&nbsp;<span>自分の長い人生の中では、思い出したくない事柄もたくさんありました。</span>
 &nbsp;</p>
<p>&nbsp;<span>小さくても自分にとって感動的であった事だけを心に抱き、次の山を極めます！</span>
 &nbsp;</p>
<p>&nbsp;<span>『一生を賭してやれば、遂げられぬことはあるまい』という豊田佐吉の言葉を座右にして...</span>
 &nbsp;</p>
<p>&nbsp;<span>&nbsp;</span>
 &nbsp;</p>
<p>&nbsp;<span>今後ますますのご成功とご健康をお祈り申し上げます。</span>
 &nbsp;</p>
<p>&nbsp;<span>有難うございました。</span>
</p>
</div>
</div>


<script>function myFunction(){document.getElementById("tateyoko").classList.toggle("tateread")}</script></body></html>
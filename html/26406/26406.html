<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>jQuery入門道場</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/css/mainday.css" title="default">
<link rel="alternate stylesheet" href="/css/mainnight.css" title="alternate">
<script type="text/javascript" src="/js/styleswitcher.js"></script>
<script type="text/javascript" src="/js/global.js"></script>
</head>
<body>
<div class="novelpage">
<div class="novelbody">
<div id="tateyoko">
<div id="_top"></div>
<a href="/">🏠</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('default'); return false;">日</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('alternate'); return false;">月</a>&emsp;
<a href="#_top" onclick="myFunction()" style="cursor: pointer;">縦書き／横書き</a>
<div id="calibre_link-13">
<div>
<div>
<table class="noveltitle">
<tr>
<td colspan="2"><i><span><i>jQuery入門道場</i></span></i></td>
</tr>
<tr>
                    
                    
      </tr>
<tr>
<td colspan="2">白岩登</td>
</tr>
<tr>
<td colspan="2">Fendora (2014)</td>
</tr>
<tr>
<td colspan="2"></td>
</tr>
</table>
<div></div>
</div>
<div></div>
</div>
</div>



<div id="calibre_link-37">
<div><b>目次</b></div>
<div><a href="#calibre_link-38">まえがき</a></div>
<div><a href="#calibre_link-39">始めに</a>
<div><a href="#calibre_link-40">まず始めに</a></div>
<div><a href="#calibre_link-41">サンプルについて</a></div>
<div><a href="#calibre_link-42">本書のバージョンについて</a></div>
<div><a href="#calibre_link-43">予備知識の確認</a>
<div><a href="#calibre_link-44">JavaScriptの必要知識</a></div>
<div><a href="#calibre_link-45">HTMLのツリー構造</a></div>
<div><a href="#calibre_link-46">Firebug、Chromeデベロッパーツール</a></div>
</div>
</div>
<div><a href="#calibre_link-47">1章 jQueryとは？</a>
<div><a href="#calibre_link-48">jQueryとは？</a>
<div><a href="#calibre_link-49">jQueryの便利さ</a></div>
<div><a href="#calibre_link-50">バージョンについて</a></div>
<div><a href="#calibre_link-51">jQueryを使ってみる</a></div>
<div><a href="#calibre_link-52">CDNを使ってjQueryを読み込む</a></div>
</div>
<div><a href="#calibre_link-53">jQueryの基本</a>
<div><a href="#calibre_link-54">jQueryの基本サンプル</a></div>
</div>
<div><a href="#calibre_link-55">$ 又はjQueryの基本的な使い方</a>
<div><a href="#calibre_link-56">(1) $("セレクター文字列") ... セレクターとしての$()</a></div>
<div><a href="#calibre_link-9">(2) $(関数) ... ドキュメント構築後に処理したい作業の登録用としてのjQuery()</a></div>
<div><a href="#calibre_link-57">(3) $("HTML文字列") ... DOM要素の生成</a></div>
<div><a href="#calibre_link-58">(4) $(DOM要素 又は jQueryオブジェクト) ... セレクター的役割</a></div>
</div>
<div><a href="#calibre_link-59">jQueryオブジェクトとは？</a>
<div><a href="#calibre_link-60">jQueryオブジェクト</a></div>
<div><a href="#calibre_link-11">メソッドチェーン</a></div>
</div>
<div><a href="#calibre_link-61">DOM要素の生成</a>
<div><a href="#calibre_link-62">DOM要素の生成</a></div>
</div>
</div>
<div><a href="#calibre_link-63">2章 セレクター</a>
<div><a href="#calibre_link-64">基本的なセレクター</a>
<div><a href="#calibre_link-17">要素（タグ）セレクター</a></div>
<div><a href="#calibre_link-18">クラスセレクター</a></div>
<div><a href="#calibre_link-19">IDセレクター</a></div>
<div><a href="#calibre_link-20">グループセレクター</a></div>
<div><a href="#calibre_link-21">ユニバーサルセレクター</a></div>
<div><a href="#calibre_link-22">属性セレクター</a></div>
</div>
<div><a href="#calibre_link-65">検索する対象（範囲）を指定する書き方</a></div>
<div><a href="#calibre_link-66">階層構造によるセレクター</a>
<div><a href="#calibre_link-67">子孫セレクター</a></div>
<div><a href="#calibre_link-68">子セレクター</a></div>
<div><a href="#calibre_link-69">隣接兄弟セレクター（Adjacent Sibling）</a></div>
<div><a href="#calibre_link-70">一般兄弟セレクター（General Sibling）</a></div>
</div>
<div><a href="#calibre_link-71">基本、子要素フィルター</a>
<div><a href="#calibre_link-72">少しまとめ</a></div>
<div><a href="#calibre_link-73">:first、:first-child</a></div>
<div><a href="#calibre_link-74">:last、:last-child</a></div>
<div><a href="#calibre_link-75">:nth-child()</a></div>
<div><a href="#calibre_link-76">:only-child</a></div>
<div><a href="#calibre_link-77">:even、:odd</a></div>
<div><a href="#calibre_link-78">:nth-child()、:even、:oddサンプル</a></div>
<div><a href="#calibre_link-79">:eq()、:gt()、:lt()</a></div>
<div><a href="#calibre_link-80">:not()</a></div>
<div><a href="#calibre_link-81">:header</a></div>
<div><a href="#calibre_link-82">:animated</a></div>
</div>
<div><a href="#calibre_link-83">コンテントフィルター</a>
<div><a href="#calibre_link-84">:contains()、:has()</a></div>
<div><a href="#calibre_link-85">:empty、:parent</a></div>
</div>
<div><a href="#calibre_link-86">フォーム系フィルター</a>
<div><a href="#calibre_link-87">フォームのタイプでの選択</a></div>
<div><a href="#calibre_link-88">フォームの状態での選択</a></div>
<div><a href="#calibre_link-89">表示・非表示でのフィルター</a></div>
</div>
<div><a href="#calibre_link-90">.is()フィルター</a></div>
<div><a href="#calibre_link-91">セレクト回数を減らそう</a></div>
</div>
<div><a href="#calibre_link-92">3章 属性、CSS操作</a>
<div><a href="#calibre_link-93">属性、CSS操作</a>
<div><a href="#calibre_link-94">.attr()</a></div>
<div><a href="#calibre_link-95">.removeAttr(name)</a></div>
</div>
<div><a href="#calibre_link-96">クラス操作</a>
<div><a href="#calibre_link-97">.addClass(name)</a></div>
<div><a href="#calibre_link-98">.removeClass([name])</a></div>
<div><a href="#calibre_link-99">.toggleClass()</a></div>
<div><a href="#calibre_link-100">.hasClass(name)</a></div>
</div>
<div><a href="#calibre_link-101">CSS操作</a>
<div><a href="#calibre_link-102">.css()</a></div>
</div>
<div><a href="#calibre_link-103">幅、高さ操作</a>
<div><a href="#calibre_link-104">.width()</a></div>
<div><a href="#calibre_link-105">.height()</a></div>
<div><a href="#calibre_link-106">.innerWidth()、.innerHeight()</a></div>
<div><a href="#calibre_link-107">.outerWidth()、.outerHeight()</a></div>
</div>
<div><a href="#calibre_link-108">スクロール操作</a>
<div><a href="#calibre_link-109">.scrollTop()</a></div>
<div><a href="#calibre_link-110">.scrollLeft()</a></div>
</div>
<div><a href="#calibre_link-111">座標位置</a>
<div><a href="#calibre_link-3">.offset()</a></div>
<div><a href="#calibre_link-4">.position()やや中級</a></div>
</div>
</div>
<div><a href="#calibre_link-112">4章 HTML、テキスト、フォーム値の取得＆設定</a>
<div><a href="#calibre_link-113">HTML、テキスト、フォーム値の取得＆設定</a>
<div><a href="#calibre_link-114">.html()、.text()</a></div>
<div><a href="#calibre_link-7">.val()</a></div>
</div>
<div><a href="#calibre_link-115">要素の追加等</a>
<div><a href="#calibre_link-116">.append()、.prepend()、.before()、.after()</a></div>
<div><a href="#calibre_link-117">.appendTo()、.prependTo()、.insertBefore()、.insertAfter()</a></div>
</div>
<div><a href="#calibre_link-118">包み込み、置換</a>
<div><a href="#calibre_link-119">.wrap()</a></div>
<div><a href="#calibre_link-120">.wrapAll()</a></div>
<div><a href="#calibre_link-121">.wrapInner()</a></div>
<div><a href="#calibre_link-122">.unwrap()</a></div>
<div><a href="#calibre_link-123">.replaceWith()</a></div>
<div><a href="#calibre_link-124">.replaceAll()</a></div>
</div>
<div><a href="#calibre_link-125">削除、クローン（コピー）</a>
<div><a href="#calibre_link-126">.remove()</a></div>
<div><a href="#calibre_link-127">.empty()</a></div>
<div><a href="#calibre_link-128">.clone()</a></div>
</div>
</div>
<div><a href="#calibre_link-129">5章 横断（Traversing）</a>
<div><a href="#calibre_link-130">横断（Traversing）</a>
<div><a href="#calibre_link-131">.first()</a></div>
<div><a href="#calibre_link-132">.last()</a></div>
<div><a href="#calibre_link-133">.eq()</a></div>
<div><a href="#calibre_link-134">.filter()</a></div>
<div><a href="#calibre_link-135">.not()</a></div>
<div><a href="#calibre_link-136">.find()</a></div>
<div><a href="#calibre_link-137">.prev() ～ .siblings()</a></div>
<div><a href="#calibre_link-138">.end() .addBack() （Ver. 1.8～）（.andSelf()（旧））</a></div>
</div>
</div>
<div><a href="#calibre_link-139">6章 jQueryオブジェクト操作</a>
<div><a href="#calibre_link-140">jQueryオブジェクト操作</a>
<div><a href="#calibre_link-141">.length</a></div>
<div><a href="#calibre_link-15">.each(function (index, element))中級</a></div>
<div><a href="#calibre_link-142">.get(n)、.get()</a></div>
<div><a href="#calibre_link-143">.toArray()</a></div>
<div><a href="#calibre_link-144">.map(function (index, element))中級</a></div>
<div><a href="#calibre_link-145">.index()</a></div>
</div>
</div>
<div><a href="#calibre_link-146">7章 イベント</a>
<div><a href="#calibre_link-147">イベントの基本</a></div>
<div><a href="#calibre_link-148">色々なイベント（ショートカット用イベント）</a>
<div><a href="#calibre_link-149">ショートカット用イベント</a></div>
</div>
<div><a href="#calibre_link-150">thisキーワード</a>
<div><a href="#calibre_link-151">thisは、流れに応じて変わる</a></div>
</div>
<div><a href="#calibre_link-152">バブリング（bubbling）とは</a></div>
<div><a href="#calibre_link-153">イベントオブジェクト</a>
<div><a href="#calibre_link-154">イベントオブジェクトの一覧</a></div>
<div><a href="#calibre_link-155">event.clientX、event.clientY</a></div>
<div><a href="#calibre_link-156">event.which</a></div>
<div><a href="#calibre_link-157">event.preventDefault()</a></div>
<div><a href="#calibre_link-158">event.stopPropagation()</a></div>
<div><a href="#calibre_link-159">return false</a></div>
</div>
<div><a href="#calibre_link-160">マウス関係のイベント</a>
<div><a href="#calibre_link-161">.mouseenter()、.mouseleave()、hover()</a></div>
<div><a href="#calibre_link-162">.mouseenter()、.mouseleave() と .mouseover()、.mouseout() の違い</a></div>
<div><a href="#calibre_link-163">.hover()メソッド と .on() と "hover"擬似イベント</a></div>
<div><a href="#calibre_link-164">マウスイベント用の.toggle()（Ver.1.9削除）</a></div>
</div>
<div><a href="#calibre_link-165">.on()とイベント委譲</a>
<div><a href="#calibre_link-166">沢山の要素にイベントを付与したい時や動的に追加した要素もイベントの対象にしたい時</a></div>
<div><a href="#calibre_link-167">イベント委譲（Event Delegation）の流れ</a></div>
</div>
<div><a href="#calibre_link-168">.on()のまとめ</a>
<div><a href="#calibre_link-169">.on( events [, selector] [, data] , handler )</a></div>
<div><a href="#calibre_link-170">.on( events-map [, selector] [, data] )</a></div>
</div>
<div><a href="#calibre_link-171">.one()、off()、.trigger()、.triggerHandler()</a>
<div><a href="#calibre_link-172">.one()</a></div>
<div><a href="#calibre_link-173">.off()</a></div>
<div><a href="#calibre_link-174">.trigger()</a></div>
<div><a href="#calibre_link-175">.triggerHandler()</a></div>
</div>
<div><a href="#calibre_link-176">画像などの読み込みが完了してから処理を実行する</a></div>
<div><a href="#calibre_link-177">古いイベントメソッド</a>
<div><a href="#calibre_link-178">.bind()</a></div>
<div><a href="#calibre_link-179">.live()（Ver.1.9で削除済）</a></div>
<div><a href="#calibre_link-180">.delegate()</a></div>
</div>
<div><a href="#calibre_link-181">従来のイベント付与とjQuery流イベント付与</a></div>
</div>
<div><a href="#calibre_link-182">8章 AJAX</a>
<div><a href="#calibre_link-183">AJAXとは？</a>
<div><a href="#calibre_link-184">AJAXとは？</a></div>
<div><a href="#calibre_link-185">jQueryのAJAX</a></div>
</div>
<div><a href="#calibre_link-186">AJAX前置き</a>
<div><a href="#calibre_link-187">AJAX前置き</a></div>
</div>
<div><a href="#calibre_link-188">$.ajax() 簡単なサンプル</a>
<div><a href="#calibre_link-189">$.ajax() 簡単なサンプル</a></div>
</div>
<div><a href="#calibre_link-190">$.ajax() 解説</a>
<div><a href="#calibre_link-191">$.ajax() 解説</a></div>
</div>
<div><a href="#calibre_link-192">$.get()、$.post()</a>
<div><a href="#calibre_link-193">$.get()</a></div>
<div><a href="#calibre_link-194">$.post()</a></div>
</div>
<div><a href="#calibre_link-195">.load()</a>
<div><a href="#calibre_link-196">.load()</a></div>
</div>
<div><a href="#calibre_link-197">$.getJSON()、$.getScript()</a>
<div><a href="#calibre_link-198">$.getJSON()</a></div>
<div><a href="#calibre_link-199">$.getScript()</a></div>
</div>
<div><a href="#calibre_link-200">.serialize()、.serializeArray()、$.param()中級</a>
<div><a href="#calibre_link-201">.serialize()中級</a></div>
<div><a href="#calibre_link-202">.serializeArray()中級</a></div>
<div><a href="#calibre_link-203">$.param()中級</a></div>
</div>
<div><a href="#calibre_link-204">$.ajaxSetup()（AJAX通信のデフォルト設定）</a>
<div><a href="#calibre_link-205">$.ajaxSetup(options)</a></div>
</div>
<div><a href="#calibre_link-206">AJAX関係のイベント中級</a>
<div><a href="#calibre_link-207">AJAX関係のイベント</a></div>
</div>
<div><a href="#calibre_link-208">新・コールバック関数の指定方法</a>
<div><a href="#calibre_link-209">新・コールバック関数の指定方法</a></div>
</div>
</div>
<div><a href="#calibre_link-210">9章 エフェクト・アニメーション</a>
<div><a href="#calibre_link-211">エフェクト .show() .hide(). toggle()</a>
<div><a href="#calibre_link-212">.show()、.hide()</a></div>
<div><a href="#calibre_link-213">.toggle()</a></div>
</div>
<div><a href="#calibre_link-214">フェード効果</a>
<div><a href="#calibre_link-215">.fadeIn()、.fadeOut()</a></div>
<div><a href="#calibre_link-216">.fadeToggle()</a></div>
<div><a href="#calibre_link-217">.fadeTo()</a></div>
</div>
<div><a href="#calibre_link-218">自作アニメ .animate()</a>
<div><a href="#calibre_link-219">.animate()</a></div>
</div>
<div><a href="#calibre_link-220">キューとは</a>
<div><a href="#calibre_link-221">キューとは</a></div>
<div><a href="#calibre_link-222">キューの取得・追加 .queue()</a></div>
<div><a href="#calibre_link-223">キューの取り出し＆実行 .dequeue()</a></div>
<div><a href="#calibre_link-224">キューのクリア .clearQueue()</a></div>
<div><a href="#calibre_link-225">キュー処理の遅延 .delay()</a></div>
</div>
<div><a href="#calibre_link-226">アニメーションの停止</a>
<div><a href="#calibre_link-33">アニメーションの停止 .stop()</a></div>
<div><a href="#calibre_link-34">アニメーションの完了 .finish()</a></div>
<div><a href="#calibre_link-35">アニメーションを全体的に無効にする $.fx.off</a></div>
<div><a href="#calibre_link-36">アニメーションの連続実行対策</a></div>
</div>
<div><a href="#calibre_link-227">アニメーションの処理が思いと感じたら</a></div>
</div>
<div><a href="#calibre_link-228">10章 プロパティ</a>
<div><a href="#calibre_link-229">.prop()の基本的な使い方</a>
<div><a href="#calibre_link-230">.prop()</a></div>
</div>
<div><a href="#calibre_link-231">属性とプロパティ</a>
<div><a href="#calibre_link-232">属性とプロパティ</a></div>
</div>
<div><a href="#calibre_link-233">checked、disabledな状態にする、状態を調べる</a>
<div><a href="#calibre_link-234">checked、disabledな状態にする、状態を調べる</a></div>
<div><a href="#calibre_link-235">.attr()で変更するやり方は、もう古い</a></div>
</div>
<div><a href="#calibre_link-236">.prop()とデフォルトの値</a>
<div><a href="#calibre_link-237">checked属性、checkedプロパティ、defaultCheckedプロパティ</a></div>
<div><a href="#calibre_link-238">デフォルト（初期）のチェックを付ける</a></div>
<div><a href="#calibre_link-239">disabled="disabled" の話</a></div>
<div><a href="#calibre_link-240">valueを扱う時は、.val()で</a></div>
</div>
</div>
<div><a href="#calibre_link-241">11章 .data()</a>
<div><a href="#calibre_link-29">.data()の基本的な使い方</a>
<div><a href="#calibre_link-242">.data()</a></div>
<div><a href="#calibre_link-243">.removeData()</a></div>
</div>
<div><a href="#calibre_link-30">HTML5のカスタム属性</a>
<div><a href="#calibre_link-244">HTML5のカスタム属性</a></div>
</div>
<div><a href="#calibre_link-31">.data()とHTML5のカスタム属性の関係</a>
<div><a href="#calibre_link-245">.data()とHTML5のカスタム属性の関係</a></div>
<div><a href="#calibre_link-246">注意点1、データは、最初の取得時に固定される</a></div>
<div><a href="#calibre_link-247">注意点2、値は変換できる型に変換される</a></div>
<div><a href="#calibre_link-248">注意点3、キーとなる名前にはハイフンは使わない方が無難</a></div>
<div><a href="#calibre_link-249">その他注意点</a></div>
</div>
</div>
<div><a href="#calibre_link-250">12章 ユーティリィ（関数）</a>
<div><a href="#calibre_link-251">ユーティリティ（関数）とは</a>
<div><a href="#calibre_link-252">ユーティリティ（関数）とは</a></div>
<div><a href="#calibre_link-253">ユーティリティ関数の形式と範囲</a></div>
</div>
<div><a href="#calibre_link-254">ユーティリティ関数 $.each()、$.map()、$.grep()</a>
<div><a href="#calibre_link-255">$.each()</a></div>
<div><a href="#calibre_link-256">$.map()</a></div>
<div><a href="#calibre_link-257">eachとmapのコールバック関数の引数について</a></div>
<div><a href="#calibre_link-258">$.grep(array, function (value, index), invert)</a></div>
<div><a href="#calibre_link-259">$.merge(array1, array2)</a></div>
<div><a href="#calibre_link-260">$.extend( [deep], target, object1 [, objectN ] )</a></div>
<div><a href="#calibre_link-261">$.inArray(value, array [, fromIndex])</a></div>
<div><a href="#calibre_link-262">$.makeArray(obj)</a></div>
<div><a href="#calibre_link-263">$.parseJSON(json)</a></div>
</div>
</div>
<div><a href="#calibre_link-264">13章 プラグインの作り方</a>
<div><a href="#calibre_link-265">jQueryプラグインの作り方</a>
<div><a href="#calibre_link-24">jQueryオブジェクト・メソッドのプラグインの作り方</a></div>
</div>
<div><a href="#calibre_link-25">ユーティリティ関数の作り方</a></div>
<div><a href="#calibre_link-26">一般公開用のメソッドプラグインの作り方（お決まりと作法）</a>
<div><a href="#calibre_link-266">お決まりと作法</a></div>
</div>
</div>
<div><a href="#calibre_link-267">14章 その他</a>
<div><a href="#calibre_link-268">jQuery Migrate</a>
<div><a href="#calibre_link-269">jQuery1.9以上への移行</a></div>
<div><a href="#calibre_link-270">jQuery3.0以上への移行</a></div>
</div>
<div><a href="#calibre_link-271">jQuery1.12、2.2の条件付き読み込み</a></div>
<div><a href="#calibre_link-272">主な廃止された機能</a>
<div><a href="#calibre_link-273">jQuery 1.8で将来廃止予定（deprecated）と位置づけられたもの</a></div>
<div><a href="#calibre_link-274">jQuery 1.9で削除されたもの（removed）</a></div>
<div><a href="#calibre_link-275">jQuery 3.0で将来廃止予定（deprecated）と位置づけられたもの</a></div>
<div><a href="#calibre_link-276">jQuery 3.0で削除されたもの（removed）</a></div>
</div>
</div>
<div><a href="#calibre_link-277">あとがき</a>
<div><a href="#calibre_link-278">筆者による他の書籍の紹介です</a></div>
<div><a href="#calibre_link-279">改定履歴</a></div>
</div>
</div>
<div id="calibre_link-347">
<div id="calibre_link-38"></div><h1 id="calibre_link-357">まえがき</h1>
<p>本書をお買い上げいただき、誠にありがとうございます。本文中に紹介する実際のコード、サンプルページ、その他本書に関する情報は、下記のURLをご覧ください。<br />
<a href="http://jquery-master.net/">http://jquery-master.net/</a>
<br /><br />
本書中のコード（プログラム）は、各々のプログラムにおいて利用していただいて構いません。但し、販売目的やアフィリエイト目的などでコードのかなりの部分を利用する場合は、筆者への許可が必要になります。
<br /><br />
なお、スマホなどでお読みで本書の画像が小さいと感じる場合、ダブルタップすれば拡大表示されると思います。</p>


</div>
<div id="calibre_link-336">
<h1 id="calibre_link-358">始めに</h1>
<h3 id="calibre_link-40"><b>まず始めに</b></h3>
<p>本書は、jQueryの基本を学び、そして中級レベルまで行けるように執筆しました。jQueryは全くの初心者の方や更にステップアップされたい方を対象としています。 当サイトを読み進めていくに当たって、以下の基本的な知識が必要になります。</p>
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
</ul>
<p>深い知識までは必要ありませんが、それなりには理解している必要があります。jQueryは簡単とは言え、その根底ではJavaScriptという言語を使っています。JavaScriptの知識が全く無い方は、まずは、JavaScriptの入門書から読まれることをお勧めします。</p>
<p>また、FirefoxのアドオンのFirebugやChromeで標準で備わっているデベロッパーツール（「F12」を押すと表示）も使えるようにして下さい。変数が格納する情報を出力する「コンソール」と呼ばれるものが必要になります。下記で簡単に導入方法を説明します。</p>
</div>
<div id="calibre_link-286">
<h2 id="calibre_link-41">サンプルについて</h2>
<p>所々にサンプルへのリンクがあります。ブラウザで開けば動作しますが、マウスを必要とするサンプルやFirebugやChromeデベロッパーツールなどが必要になるサンプルでは、スマートフォンでは、確認ができません。必要に応じてPCでご確認下さい。</p>


</div>
<div id="calibre_link-325">
<h2 id="calibre_link-42">本書のバージョンについて</h2>
<p>本書は必要が生じたら、適宜改定を行っていきます。バージョン情報は、パソコンのソフトなどに見られるように「1.x」「1.xx.yy」などのように表記して行きます。細かい修正時は、yyの部分をアップさせ、新しい情報の追加など行った際は、xxの部分をアップさせます。全体的に関わる修正は、最初の数字の部分を1→2→3などのようにアップさせます。改訂履歴は、巻末の<a href="#calibre_link-279">改訂履歴</a>をご覧ください。また、本書の<a href="http://www.amazon.co.jp/gp/product/B00HE4R9H2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00HE4R9H2&amp;linkCode=as2&amp;tag=amazonzon0205-22">Kindle販売ページ</a>にも記載しておきます。</p>
<p>なお、バージョンアップは、現状では、キンドルのサポートに本書のタイトルとASIN番号（B00HE4R9H2）を記載して、改訂版を取得したい旨をメールすると、改訂版に更新されるそうです。別途の費用は発生しません。旧版で付けたメモやハイライトは消えてしまうそうです。（将来的には、もう少しバージョンアップしやすくなるだろうと思われます）</p>


</div>
<div id="calibre_link-27">
<h2 id="calibre_link-43">予備知識の確認</h2>
<p>HTML、CSS、JavaScriptについて、少しだけ確認と補足説明をしておきます。</p>
<h3 id="calibre_link-44"><b>JavaScriptの必要知識</b></h3>
<p>最低限、以下のような事が分かっている必要があります。</p>


<ul>
	<li>変数について</li>
	<li>配列について</li>
	<li>if文などの分岐条件</li>
	<li>データの型について（文字列型、数値型...など）</li>
	<li>関数について</li>
	<li>演算子について（+ - &gt; &lt; =...など）</li>
	<li>forなどの繰り返し文</li>
	<li>オブジェクトの基本的知識</li>
</ul>
<p>大体以上が分かっていれば大丈夫です。オブジェクトに関する深い知識は必要ありませんが、次のようなキー（名前）と値からなるオブジェクトは、理解できる必要があります。</p>
<div>
<pre><span>var</span><span>person</span> = {</pre>
<pre><span>name</span>:<span>"太郎"</span>,</pre>
<pre><span>age</span>:<span>"35"</span>,</pre>
<pre><span>gender</span>:<span>"男性"</span></pre>
<pre>};</pre></div>
<p>このような形式は、jQueryでは、各種関数（メソッド）を呼び出す際に、1つの引数で多数の設定情報を渡すことができますので、頻繁に利用されています。例えば、以下のようになります。</p>
<div>
<pre><span>$</span>(<span>'#night'</span>).<span>css</span>({</pre>
<pre><span>'background-color'</span>:<span>'pink'</span>,</pre>
<pre><span>'font-weight'</span>:<span>'bold'</span>,</pre>
<pre><span>color</span>:<span>'blue'</span></pre>
<pre>});</pre></div>
<p>ちなみにこの形式は、次の様な名前で表現されることが多いです。（options、config、settings、object、map）</p>
<h3 id="calibre_link-45"><b>HTMLのツリー構造</b></h3>
<p>HTMLのツリー構造について、サッと用語を確認しておきます。</p>
<p>次のようなHTML文書があるとします。</p>
<div>
<pre><span>&lt;html&gt;</span></pre>
<pre><span>&lt;head&gt;</span></pre>
<pre><span>&lt;title&gt;</span>HTMLのツリー構造<span>&lt;/title&gt;</span></pre>
<pre><span>&lt;/head&gt;</span></pre>
<pre><span>&lt;body&gt;</span></pre>
<pre><span>&lt;h1&gt;</span>ツリー構造とは？<span>&lt;/h1&gt;</span></pre>
<pre><span>&lt;p&gt;</span>HTMLの<span>&lt;strong&gt;</span>階層構造<span>&lt;/strong&gt;</span>を示します<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;/body&gt;</span></pre>
<pre><span>&lt;/html&gt;</span></pre></div>
<p>この時、これは、次のようなツリー構造に表現できます。</p>
<p><img src="images/000037.gif" alt="" /></p>
<p>家系図の場合と同じですが、次の用語を確認しておきましょう。</p>
<dl>
<dt><b>先祖</b></dt>
<dd>ある要素よりも上の階層に位置する要素を指します。例えば、htmlは、全ての要素から見て先祖です。また、bodyは、h1、p、strong全てから見て、先祖です。</dd>
<dt><b>子孫</b></dt>
<dd>先祖とは逆に、ある要素よりも下の階層に位置する要素を指します。例えば、htmlから見ると、他全ての要素は、子孫です。また、bodyから見ると、h1、p、strongが子孫に当たります。</dd>
<dt><b>親</b></dt>
<dd>1階層だけ上の要素が親要素になります。例えば、head、bodyから見て、htmlは、親です。また、h1、pから見て、bodyは親です。</dd>
<dt><b>子</b></dt>
<dd>親とは逆に、1階層だけ下の要素が子になります。例えば、htmlから見て、head、bodyは、子です。また、bodyから見て、h1、pが子です。</dd>
<dt><b>兄弟（姉妹）</b></dt>
<dd>同じ親を持つ要素同士が兄弟（姉妹）となります。例えば、headとbodyは、兄弟です。また、h1とpも兄弟です。</dd>
</dl>


<h3 id="calibre_link-46"><b>Firebug、Chromeデベロッパーツール</b></h3>
<p>jQuery（JavaScript）の開発をする際は、FirefoxのFirebugやChromeのデベロッパーツールは、必須となります。ここでは導入方法をごく簡単に説明しておきます。</p>
<h4><b>Firefoxユーザーの方</b></h4>
<p>まず、Firebugは、Firefoxのアドオンとして存在しますので、「Firebug」で検索して、このアドオンをインストールして下さい。インストール後、Firebugを有効にします。Firebugは、F12を押すと、表示・非表示を切り替えることができます。左上の「コンソール」と書かれたタブを主に使います。</p>
<p><img src="images/000032.gif" alt="" /></p>
<h4><b>Chromeユーザーの方</b></h4>
<p>Chromeでは、標準でデベロッパーツールが入っています。F12を押すと、表示・非表示を切り替えることができます。右上の「Console」と書かれたタブを主に使います。</p>
<p><img src="images/000026.gif" alt="" /></p>
<h4><b>IEユーザーの方</b></h4>
<p>IE9～にも開発者向けのツールがあります。F12を押すと、表示・非表示を切り替えることができます。左上の「コンソール」と書かれたタブを主に使います。</p>
<p><img src="images/000065.gif" alt="" /></p>
<h4><b>コンソールの使い方</b></h4>
<p>JavaScriptからは、例えば以下のようにして、変数などに格納されている情報を確認することができます。</p>
<div>
<pre><span>var</span><span>person</span> = {</pre>
<pre><span>name</span>:<span>"太郎"</span>,</pre>
<pre><span>age</span>:<span>"35"</span>,</pre>
<pre><span>gender</span>:<span>"男性"</span></pre>
<pre>};</pre>
<pre><span>console</span>.<span>log</span>(<span>person</span>);</pre></div>
<p>すると、以下のような情報が、コンソールに出力されます。</p>
<p><img src="images/000059.gif" alt="" /></p>
<p>jQueryで開発する際には、必須のツールになりますので、是非ご活用下さい。</p>


</div>
<div id="calibre_link-316">
<h1 id="calibre_link-359">1章　jQueryとは？</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-48">jQueryとは？</a></li>
	<li><a href="#calibre_link-53">jQueryの基本</a></li>
	<li><a href="#calibre_link-55">$ 又はjQueryの基本的な使い方</a></li>
	<li><a href="#calibre_link-59">jQueryオブジェクトとは？</a></li>
	<li><a href="#calibre_link-61">DOM要素の生成</a></li>
</ul>


</div>
<div id="calibre_link-355">
<h2 id="calibre_link-48">jQueryとは？</h2>
<p>jQueryとは、John Resig（ジョン・レッシグ）氏によって開発／公開されたJavaScript用のライブラリです。2006年8月に最初のバージョンをリリースして以来、着実にバージョンアップを重ね、2016年6月時点での最新版は、1系はVer.1.12.4、2系は、Ver.2.2.4です。 ライセンスは、MIT Licenseとなっており、ライブラリの著作権表示を消さなければ、商用・非商用を問わず、誰でも自由に利用することができます。jQueryは、比較的に後発に登場したJavaScript用ライブラリですが、今では断トツの人気を博しています。</p>
<p>jQueryには、<strong><b>jQuery本体</b></strong>（jQuery Core）とjQuery公式プラグインの<strong><b>jQuery UI</b></strong>が存在します。また、スマートフォン用の<strong><b>jQuery Mobile</b></strong>も存在します。更にjQueryのプラグインは、公式のもの以外にも世界中の開発者により無数のプラグインが公開されています。本書においては、jQuery本体の解説を行なっていきます。</p>


<h3 id="calibre_link-49"><b>jQueryの便利さ</b></h3>
<p>jQueryのようなJavaScript用ライブラリを使わない場合、自分で生の（素の）JavaScriptで記述し、更に各ブラウザごとの違いも自分で対応させなければ行けません（どちらも煩雑な作業を伴います）。jQueryを使えば、主要なブラウザに、簡単な方法で対応させることができます。特に、現在のVer.1系の最新版でもIE6にも対応している点は見逃せません。<br />
<br />
  例えば、jQueryを使わないで現在チェックされているラジオボタンの値を取得する場合、大体8行位はプログラムが必要になります。 これが、jQueryを使うと、わずか1行で無理なく書けます。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"fruit"</span><span>value</span>=<span>"リンゴ"</span><span>checked</span><span>&gt;</span> リンゴ<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"fruit"</span><span>value</span>=<span>"いちご"</span><span>&gt;</span> いちご<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"fruit"</span><span>value</span>=<span>"みかん"</span><span>&gt;</span> みかん<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;form&gt;</span></pre></div>
<p>jQueryを使った場合は、次の1行で済みます。</p>
<div>
<pre><span>var</span><span>val</span> =<span>$</span>(<span>'[name="fruit"]:checked'</span>).<span>val</span>();</pre></div>
<p>上記valの中にチェックされている値が格納されます。（ここでは、詳しい説明は省略させていただきます）</p>


<h3 id="calibre_link-50"><b>バージョンについて</b></h3>
<p>2016年6月時点での最新版は、1系はVer.1.12.4、2系は、Ver.2.2.4となっており、Ver.2系は、IE6～8をサポートしていません。Ver.1系と2系は、サポートするブラウザが異なるだけで、API（＝使い方）自体は同じです。また、1系と2系はそれぞれ、1.10←→2.0、1.11←→2.1、1.12←→2.2と足並みを揃えてリリースされ、APIがそれぞれで対応しています。</p>
<p>そして、同月にjQuery Ver.3.0もリリースされました。Ver.3系は、2系と同様にIEは9以降のサポートとなります。そして、Ver.3系では、1系や2系の最新版とは、API（＝使い方）に幾らか変更が生じています。また今後は、1系、2系は、1.12.xx、2.2.xxが最後と版となり、一定期間のバグ修正のみが行われます。</p>
<p>jQueryのバージョンは、バグなどの細かい修正時は、例えば1.xx.yyとある時、最後のyyの部分が、アップして行きます（例：1.9.0 → 1.9.1）。
そして、新機能の追加やAPIの仕様変更などがあった際は、xxの部分がアップしていきます（例：1.9.2 → 1.10.0）。</p>
<p>jQueryのバージョンは、その時点における最新版を使うのが理想です。しかし、Ver.1.9ではAPIが整理されて多くの機能（関数など）が削除され、これにより今まで（Ver.1.8まで）利用できていた既存のコード（プログラム）が動かなくなるという事もありました。それも今では、大分落ち着いてきたとは思います。

また、jQuery3系でもAPIに幾らか変更が生じますが、Ver.1.9の時とは異なり、多くの人には影響は与えない、とjQueryチームは述べています。では、自分は何系のどのバージョンを使えば良いか、簡単にまとめますと、</p>
<ul>
	<li>1系の最新版 → IE6～IE8もサポートしたい方</li>
	<li>2系の最新版 → IEは9以降で良いが、既存のプログラムとの互換性を重視したい方</li>
	<li>3系の最新版 → IEは9以降で良く、且つ、最新機能そして最新の仕様で行きたい方</li>
</ul>
<p>と言えると思います。もちろん、1系は1系でも更に古いプラグイン等との互換性を重視されたい方は、Ver.1.8の最新版を使うという選択肢もあることでしょう。ちなみに、Ver.1.9→1.12 及び Ver.2.0→2.2へのバージョンの変化は、ちょっとした改良などもありましたが、これと言って気にしなくても良いレベルです。</p>
<p>なお、本書では、Ver.1.12.4を使って話を進めていきますが、最低でもVer.1.7以上を想定した上での解説となります。また、jQuery 3.0が、1系、2系と異なる箇所で大切な所は、随時解説して行きます。</p>


<h3 id="calibre_link-51"><b>jQueryを使ってみる</b></h3>
<p>それでは、実際にjQueryをダウンロードして使ってみましょう。jQueryは、<a href="http://jquery.com/">本家サイト</a>に行き、「Download jQuery」とある大きなボタンを押します。</p>
<p><img src="images/000042.gif" alt="jQuery本家TOPページ" /></p>
<p>すると、ダウンロード画面に飛びます。画面の「Download the compressed, production jQuery 1.12.4」を右クリックして、表示されるメニューから「名前を付けて保存」などを選択して、取得＆保存します。（その時の最新版をダウンロードして下さい）</p>
<p><img src="images/000030.gif" alt="jQuery本家TOPページ" /></p>
<p>「compressed, production」とあるのは、中身が縮小化されているので、ファイルの中を見ても何だか分かりません。一方、「Uncompressed, development」の方は、そのような処理は行っていないため、jQueryのソースを読むことが可能です。</p>
<p>jQueryのソースを読む予定が無ければ、「compressed, production」の方が軽いので、こちらを選択＆利用します。jquery-1.12.4.min.jsというようなファイル名でダウンロードできたと思いますので、後はこのファイルをHTMLで読みこめば準備OKです。 実際に読み込んだ形は、以下のようになります。（パスは、適宜編集して下さい）</p>
<div>
<pre><span>&lt;!DOCTYPE html&gt;</span></pre>
<pre><span>&lt;html</span><span>lang</span>=<span>"ja"</span><span>&gt;</span></pre>
<pre><span>&lt;head&gt;</span></pre>
<pre><span>&lt;meta</span><span>charset</span>=<span>"utf-8"</span><span>&gt;</span></pre>
<pre><span>&lt;title&gt;</span>jQueryのテスト<span>&lt;/title&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"js/jquery-1.12.4.min.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;/head&gt;</span></pre>
<pre><span>&lt;body&gt;</span></pre>
<div></div>
<pre><span>&lt;/body&gt;</span></pre>
<pre><span>&lt;/html&gt;</span></pre></div>
<p>以上で完了です。以後、jQueryを使ったプログラムを書く場合、このjQueryの読み込みを行った後に記載していきます。jQueryを読み込む前に記載しても、jQueryを使うことはできません。</p>
<h3 id="calibre_link-52"><b>CDNを使ってjQueryを読み込む</b></h3>
<p>さて、ここでもう1つCDNを使ってjQueryを読み込む方法を紹介しましょう。CDNとは、Contents Delivery Networkの略で、Webコンテンツをインターネット経由で配信するために最適化されたネットワークのことです。サーバ側での圧縮転送（gzip）機能に対応していたり、また、ユーザーが過去に他のサイトで同じCDNのURLからファイルを取得していれば、キャッシュ効果も期待できます。また、自分のサーバにjQueryを置く必要がなく、簡単に利用することができます。jQueryでは、幾つかのCDNが利用できますが、ここではGoogleが提供しているCDNで見ていきましょう。例えば、次のように読み込みます。</p>
<div>
<pre>// バージョンは、適宜置き換えて下さい。</pre>
<pre>// その1</pre>
<pre><span>&lt;script</span><span>src</span>=<span>"http://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre>// その2</pre>
<pre><span>&lt;script</span><span>src</span>=<span>"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"</span><span>&gt;&lt;/script&gt;</span></pre></div>
<p>もしページが、非SSLの場合は、その1でOKです。SSLのページを作成する場合は、jQueryの読み込みがSSLに対応していないとブラウザが警告などを表示したりするため、その2を指定します。常時SSLというのが昨今のWEBの流れですので、予めその2で指定しておくのもいいかも知れません。</p>
</div>
<div id="calibre_link-305">
<h2 id="calibre_link-53">jQueryの基本</h2>
<p>このページでは、jQueryの基本について学びます。しかし、基本とはなっていますが、仕組みや概念の説明のため、他の「セレクター」などの章に比べると、難しい部分もあると思います。ですが、一通り読み進めて下さい。中でも大事な部分は、jQueryを書く時は、</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>// この中に処理を書く</span></pre>
<pre>});</pre></div>
<p>上記の中に書いていくという事をしっかり覚えておいて下さい。<br />
なお、本書では、これはjQueryのお決まりみたいなものなので、<strong><b>これ以降は、基本的にこの記述自体は書かずに、その中身部分のみを記載してきます。</b></strong></p>
<h3 id="calibre_link-54"><b>jQueryの基本サンプル</b></h3>
<p>jQueryの主な（基本的な）機能は、HTMLとCSSを操作するためのものです。操作対象とするHTMLを選択する時は、お馴染みのCSSのセレクター構文がそのまま使えます。そして、CSS等を操作するために、jQueryのメソッドを使えばいいのです。 まずは、サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;!DOCTYPE html&gt;</span></pre>
<pre><span>&lt;html</span><span>lang</span>=<span>"ja"</span><span>&gt;</span></pre>
<pre><span>&lt;head&gt;</span></pre>
<pre><span>&lt;meta</span><span>charset</span>=<span>"utf-8"</span><span>&gt;</span></pre>
<pre><span>&lt;title&gt;</span>jQueryのテスト<span>&lt;/title&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"<i><i>js</i></i>jquery-1.12.4.min.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>);</pre>
<pre>});</pre>
<pre><span>&lt;/script&gt;</span></pre>
<pre><span>&lt;/head&gt;</span></pre>
<pre><span>&lt;body&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"color_div"</span><span>&gt;</span>ここのDIVの枠線をjQueryで変更します<span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;/body&gt;</span></pre>
<pre><span>&lt;/html&gt;</span></pre></div>
<p>実行結果</p>
<div id="calibre_link-360">ここのDIVの枠線をjQueryで変更します</div>
<p>jQueryは、$(...) 又はjQuery(...) という形で使用していきます。$は、1文字ですが、これが変数になっています。（少し異様な気もしますが、JavaScriptでは、$という変数名が付けられます）そして、この$は、jQueryのエイリアス（別名）となります。基本的にはどちらを使っても大丈夫です。</p>
<p>上記を解説しますと、まず、</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre></pre>
<pre>});</pre></div>
<p>の部分は、後ほど解説するとして、CSSの設定を変更しているのは、</p>
<div>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid green"</span>);</pre></div>
<p>の部分です。<br />
  まず、CSSでお馴染みのセレクタでHTMLのdiv要素を選択します。<br />
  続けてその取得したdiv要素に対し、jQueryメソッドの.css("", "")を適用して、CSSを設定しています。<br />
  $("セレクター").css("CSSのプロパティ", "CSSの値");<br />
という形になっています。（後の章で、改めて詳しく解説します）</p>
<p>では、</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre></pre>
<pre>});</pre></div>
<p>の部分は、何でしょうか？<br />
これは、JavaScriptは上から下に順に解釈され実行されて行きますが、この $("#color_div") 部分が登場する時点では、まだ該当のHTML（#color_div）が登場してないため、正常に処理を行うことができません。本来はブラウザのHTMLの読み込みが完了した時点又は操作対象の要素が登場し終えた時点で、この処理を書く必要があります。ですが、それらの完了や登場を待たずしても処理を記述したいのが通常のケースで、それを実現する為に、一連の作業をこのjQuery(function ($) {.....});の中に書き、処理を登録しておくのです。そうする事で、HTMLの読み込みが完了した時点で jQuery(function ($) {.....}); の中に書いた一連の作業が実行されます。実際、どういう事か下にまとめてみました。</p>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// この書き方は、#color_divが、まだ登場していないのでアウト！</span></pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"xxx"</span>,<span>"xxx"</span>);</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"color_div"</span><span>&gt;</span>...<span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// これならOK</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"xxx"</span>,<span>"xxx"</span>);</pre>
<pre>});</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"color_div"</span><span>&gt;</span>...<span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"color_div"</span><span>&gt;</span>...<span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// これもOK</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"xxx"</span>,<span>"xxx"</span>);</pre>
<pre>});</pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"color_div"</span><span>&gt;</span>...<span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// jQuery(function ($) {.....});で囲っていないが、</span></pre>
<pre><span>// #color_divが登場した後なので、OK</span></pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"xxx"</span>,<span>"xxx"</span>);</pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>jQueryは、HTMLを操作するのが基本の作業であるため、jQueryを書く時には、jQuery(function ($) {.....});で囲むのが基本になります。</p>
<p>少し慣れてくると、jQuery(function ($) {.....});の中に書かなくてもドキュメントの下部（body終了タグの直前など）であれば、直接書けることが分かってきますが、やはり基本的には、jQuery(function ($) {.....});の中に処理を書くと覚えておきましょう。このjQuery(function ($) {.....}); については、下でまた改めて見ます。</p>
</div>
<div id="calibre_link-343">
<h2 id="calibre_link-55">$ 又はjQueryの基本的な使い方</h2>
<p>$ 又はjQueryは、まず<strong><b>使う形式で大きく2つ</b></strong>に分けられます。次の2つになります。</p>
<ol>
<li value="1">$(xxx) の形</li>
<li value="2">$.xxx() の形</li>
</ol>
<p><strong><b>1つ目の形がjQueryの醍醐味</b></strong>になります。本書でもこちらを集中的に見ていきます。一方、2つ目の書き方は、jQueryでは、ユーティリティ関数などと呼ばれています。汎用的に使えるツール群になっています。<strong><b>1つ目の形は、xxxの部分に何を渡すかによって、更に幾つかに分類することができます。本書では、下記の4つに分類</b></strong>しています。ユーティリティ関数については、ここでは説明を省略して、章を改めてまた見ます。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>呼び出し方</b></th>
<th><b>役割</b></th>
</tr>


<tr>
<td>$("セレクター文字列")</td>
<td>セレクターとしての$()</td>
</tr>
<tr>
<td>$(関数)</td>
<td>ドキュメント構築後に処理したい作業の登録用としてのjQuery()</td>
</tr>
<tr>
<td>$("HTML文字列")</td>
<td>DOM要素の生成</td>
</tr>
<tr>
<td>$(DOM要素 又は jQueryオブジェクト)</td>
<td>セレクター的役割</td>
</tr>
</tbody>
</table>


<h3><b>(1) $("セレクター文字列") ... セレクターとしての$()</b></h3>
<p>先ほど見ましたが、$("セレクター") という形で、HTMLの要素を選択できます。そして、その選択した要素に対して各種操作をしていきます。セレクターには、CSSのセレクターをそのまま利用できます。CSS3で定義されているCSSも利用することができます。また、jQueryが独自に実装しているセレクタも一部あります。<br />
例えば、以下のようなセレクターなどがあります。</p>
<p>$("p a")<br />
  $("#name")<br />
  $("#addr1, #addr2")<br />
$("a[href$='pdf']")</p>
<p>1つ目は、p要素の中にあるa要素（リンク）を全て選択します。<br />
  2つ目は、id属性がnameの要素を選択します。<br />
  3つ目は、id属性がaddr1という要素とaddr2という要素を選択します。（カンマ区切りで複数選択しています）<br />
4つ目は、リンク先がpdfで終わるa要素を全て選択しています。</p>
<p><strong><b>jQueryは、選択した要素を記憶し、そしてその（それらの）要素に対し各種操作が行えるようになります。</b></strong>このセレクター機能は、jQueryでは常時使用することになります。次の章で改めて見ていきます。</p>



<h3 id="calibre_link-9"><b>(2) $(関数) ... ドキュメント構築後に処理したい作業の登録用としてのjQuery()</b></h3>
<p>まさに上記で見た</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre></pre>
<pre>});</pre></div>
<p>です。上記に書いたように、要素が出現する前に何か操作をしようとしても操作できないため、ドキュメントが構築された後に処理したい作業を登録する為のものです。
実は他にも書き方は存在します。以下のようなものです。（意味する内容は同じです）</p>
<div>
<pre><span>// パターン2</span></pre>
<pre><span>$</span>(<span>document</span>).<span>ready</span>(<span>function</span>(<span>$</span>){</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre>
<div></div>
<pre><span>// パターン3</span></pre>
<pre><span>$</span>(<span>function</span>(<span>$</span>){</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre></div>
<p>パターン2は、「ドキュメント（document）が構築された後（ready）に、functionの中を実行して下さい」と読めます。 パターン3は、パターン2が更にシンプルになった版です。ですので、パターン3を使ったほうが、よりすっきり書けます。</p>
<p>と、幾つかのパターンがありますが、私のお勧めは一番最初に書いた書き方です。 それは何故かと言うと、最初の書き方であれば、他のJavaScript用ライブラリとの$の変数名の衝突を抑えることができるからです。 例えばprototype.jsと言うかつて有名だったライブラリがありますが、このライブラリも$という変数名を使用します。自分一人だけでWEBサイトを管理していれば良いのですが、通常は複数の人間が関わることが多いと思います。もし新人さんが、prototype.js用のプラグインを使うために、prototype.jsを加えたとすると、$という変数名がバッティングしてしまいます。そして、パターン2、3で書いていたものが、突然動かなくなります。 安全性を高めるためにも、</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre></pre>
<pre>});</pre></div>
<p>の書き方をオススメします。少し補足しますと、上記のfunction ($) {.....}の中では、$はJavaScriptで言う所のローカル変数となる為、</p>
<div>
<pre><span>$</span> =<span>"hoge"</span>;<span>// ここで$を上書きしても</span></pre>
<div></div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<div></div>
<pre><span>// この中では、安全に$を使うことができます。</span></pre>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>);</pre>
<pre></pre>
<pre><span>// なのでこの中では、jQueryと書くより、$と書いたほうが楽でいい</span></pre>
<pre></pre>
<pre>});</pre></div>
<p>上記のように、functionの中では、jQueryのエイリアスの$を使い続ける事ができます。但し、function ($) の $ を書き忘れないで下さい。これを書き忘れると、上記の記述は動作しなくなります。</p>
<p>更に追加情報として、パターン2の書き方は、jQuery Ver.3.0では「将来廃止予定」に位置づけられています。</p>
<p>さて、「ドキュメント構築後に処理したい...」と書きましたが、JavaScriptなどのプログラムから操作できるようにするための文書オブジェクトモデルをDOM（Document Object Model）と呼んでいます。このDOMが構築された後に、jQuery(function ($) {.....});で登録した作業が実行されます。<br />
  （DOMという用語が馴染めない場合は、HTMLと読み替えて下さい）</p>
<p>jQueryが一般化する前には、以下のような書き方も多く存在しました。</p>
<div>
<pre><span>window</span>.<span>onload</span> =<span>function</span>() {</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>};</pre></div>
<p>この書き方とjQueryの書き方とでは何か異なるのでしょうか？ まず、window.onloadの場合は、ドキュメントの構築のみならずに、他の外部ファイルがあった場合などは、それらも読み込みが完了していなければなりません。画像の場合は、画像をダウンロードして表示されていなければなりません。これらが全て終わった後に処理が実行されるため、少し時間がかかります。JavaScriptからHTMLを操作する為には、そこまで待つ必要はありません。その為、jQueryでは、DOMが構築された後に実行されるようになっています。</p>
<p>また、window.onloadの場合、その性質上1度だけしか書くことができません。2回書くと、先に書いたonloadの変数（プロパティ）が上書きされてしまいます。いつ誰がどこで上書きしてしまうか分からないので、この書き方は辞めましょう。jQueryの書き方の場合、何回でも登録することができ、基本的に登録した順番に処理が実行されていきます。</p>
<p>実は、画像などの読み込み完了する前に処理が実行されるというのは、何かと喜ばしいことですが、逆に、画像などの読み込みが完了してから処理を実行したい、というケースもあります。それについては、イベントの章で改めて見ていきます。</p>






<h3 id="calibre_link-57"><b>(3) $("HTML文字列") ... DOM要素の生成</b></h3>
<p>$("HTMLタグ") の形を使い、DOM要素（HTMLの要素）を簡単に作ることができます。例えば、次のようなHTMLがあるとします。</p>
<div>
<pre><span>&lt;ul</span><span>id</span>=<span>"family"</span><span>&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>ULの最後に&lt;li&gt;三郎&lt;/li&gt;という要素を追加したいとします。この場合、こうするだけで完成です。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"&lt;li&gt;三郎&lt;/li&gt;"</span>).<span>appendTo</span>(<span>"#family"</span>);</pre>
<pre>});</pre></div>
<p>これで、こうなります。</p>
<div>
<pre><span>&lt;ul</span><span>id</span>=<span>"family"</span><span>&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>.appendTo()は、別の章で見ますが、$("&lt;li&gt;三郎&lt;/li&gt;")で生成したDOM要素をid="family"のUL要素に追加しています。</p>
<p>このDOM要素の生成機能は、もう少し先でまた説明します。</p>



<h3 id="calibre_link-58"><b>(4) $(DOM要素 又は jQueryオブジェクト) ... セレクター的役割</b></h3>
<p>DOM要素を$()に渡すことにより、それをjQueryオブジェクトとすることができます。これは多くの場合、$(this) という形で使われますが、この形については後の章で詳しく解説します。DOM要素以外にも、documentやwindowオブジェクトを渡すことができます。</p>
<p>（下記サンプルの document.getElementById(xxx); は、jQueryではなくJavaScript側の機能で、idを指定してDOM要素を取得します）</p>
<div>
<pre><span>// eleは、DOM要素。div1は、$("#div1") と同じこと</span></pre>
<pre><span>var</span><span>ele</span> =<span>document</span>.<span>getElementById</span>(<span>"div1"</span>);</pre>
<pre><span>var</span><span>div1</span> =<span>$</span>(<span>ele</span>);</pre>
<div></div>
<pre><span>var</span><span>w1</span> =<span>$</span>(<span>window</span>).<span>width</span>();<span>// ブラウザの横幅取得</span></pre>
<pre><span>var</span><span>w2</span> =<span>$</span>(<span>document</span>).<span>width</span>();<span>// HTMLドキュメントの横幅取得</span></pre>
<div></div>
<pre><span>// 後の章でこの形で登場します</span></pre>
<pre><span>$</span>(<span>this</span>)</pre>
<div></div></div>



</div>
<div id="calibre_link-326">
<h2 id="calibre_link-59">jQueryオブジェクトとは？</h2>
<h3 id="calibre_link-60"><b>jQueryオブジェクト</b></h3>
<p>$(セレクター)の形で呼び出すと、jQueryオブジェクトと呼ばれるものが返されます。jQueryの基本で、次のように書きました。</p>
<div>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>);</pre></div>
<p>ここでは、$("#color_div") で呼び出した結果、jQueryオブジェクトが返ってきて、その返ってきたjQueryオブジェクトに対して、CSSを変更する操作を行なっています。 これは分解して、次のように書くこともできます。</p>
<div>
<pre><span>var</span><span>color_div</span> =<span>$</span>(<span>"#color_div"</span>);<span>// 一旦jQueryオブジェクトを変数に代入してから</span></pre>
<pre><span>color_div</span>.<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>);<span>// 操作する</span></pre></div>
<p>但しこのように書く必要性が無ければ、あえて2行に分ける必要はありません。</p>
<p>このjQueryオブジェクトとは、<strong><b>選択した要素一式を（配列の形で）含んでいて、かつ、jQueryの機能となるメソッド（関数）を備えたオブジェクト</b></strong>のことを言います。ちょっと話が難しくなりました。 視覚的に分かるように、このjQueryオブジェクトがどういうものかをFirebugを使って見てみましょう。次のHTMLがあるとします。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>まずは、jQueryを使わずに、生のJavaScriptでLI要素を取得した場合です。</p>
<div>
<pre><span>var</span><span>li</span> =<span>document</span>.<span>getElementsByTagName</span>(<span>"li"</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>li</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000021.gif" /></p>
<p>LI要素が3つ取得されているのが分かります。</p>
<p>次に、jQueryの場合です。</p>
<div>
<pre><span>var</span><span>li</span> =<span>$</span>(<span>"li"</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>li</span>)</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000078.gif" /></p>
<p>3つのLI要素も取得されていますが、それ以外にもjQueryで使えるメソッドも一緒に取得されています（緑枠の部分。実際はもっとあるのですが、画面の都合上、一部だけの表示になっています） これがまさに<strong><b>jQueryオブジェクト</b></strong>です。言うなれば、jQueryの武器（メソッド）で武装したDOM要素（HTML要素）が、まさにjQueryオブジェクトと言えます。<br />
書籍によっては、要素がjQueryの機能によって包まれるイメージになるため、プログラミング用語に倣い、jQueryラッパー（jQuery wrapper）などと呼ぶこともあります。 用語の整理がてら、上記を別の図で確認してみましょう。</p>
<p><img src="images/000027.gif" /></p>
<p>jQueryでは、何か操作を行う際、基本的に現在選択対象になっている要素の全てに対して処理を行います。 例えば、先の場合において、</p>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>とすると、LI要素全てに対して、文字色を赤に設定します。しかし、例えばCSSの値を設定するのではなく、値を取得する場合は、<strong><b>選択した要素の最初の要素</b></strong>の値を取得します。</p>
<div>
<pre><span>var</span><span>color</span> =<span>$</span>(<span>".fruit"</span>).<span>css</span>(<span>"background-color"</span>);</pre></div>
<p>この場合、クラス名がfruitの要素の内、最初の要素の背景色を取得します。</p>
<h3 id="calibre_link-11"><b>メソッドチェーン</b></h3>
<p>上記の説明から続きますが、$(セレクター)を呼び出すと、jQueryオブジェクトが返されます。その返されたjQueryオブジェクトに対して操作を書くことができます。</p>
<div>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>);</pre></div>
<p>しかし、実は何かの操作を行った後も、（多くのメソッドでは）操作を行う前と同じjQueryオブジェクトを返します。つまり、例えば次のように操作を繋げて書くことができます。</p>
<div>
<pre><span>$</span>(<span>"#color_div"</span>).<span>css</span>(<span>"border"</span>,<span>"1px solid red"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>jQueryオブジェクトが返ってくる限り、幾つでも繋げて書くことができます。これは、鎖の如くメソッドが繋がることから、メソッドチェーンと呼ばれています。<br />
上記では、.css()メソッドのみしか登場していませんが、実際は各種メソッドを繋げて書くことができます。 ただ、先にも見たように、何かを操作するのではなく、例えばある要素の長さや色などを取得する場合は、その長さや色が返ってくるのであり、jQueryオブジェクトは返ってきませんので、繋げて書くことはできません。</p>



</div>
<div id="calibre_link-310">
<h2 id="calibre_link-61">DOM要素の生成</h2>
<p><a href="#calibre_link-55">$ 又はjQueryの基本的な使い方</a>で見たDOM要素の生成機能を見ていきます。とは言え、便宜上この場所に載せていますが、まだ説明していないjQueryのメソッドが出てきますので、一通り読み終えてから、再度このページに戻って来た方が分かりやすいと思います。</p>
<h3 id="calibre_link-62"><b>DOM要素の生成</b></h3>
<p>「jQueryの基本」で、DOM要素の生成の説明で、次のようなサンプルを見ました。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"&lt;li&gt;三郎&lt;/li&gt;"</span>).<span>appendTo</span>(<span>"#family"</span>);</pre>
<pre>});</pre></div>
<p>$("&lt;li&gt;三郎&lt;/li&gt;") のタグ部分の &lt;li&gt;三郎&lt;/li&gt; は、セレクターと間違われないようタグから開始します。そうすることで、DOM要素を生成することができます。そして、その生成されたDOM要素を選択しているjQueryオブジェクトが返されます。 しかし、実際の所、生成されるだけでどこかに自動で挿入される訳ではありません。まだ、宙ぶらりんな状態です。その為、appendToなどのメソッドを使って、HTMLのどこかに入れ込んであげます。</p>
<p>上記のようにHTMLの中身を含めることもできますが、下記のように単純にタグだけの指定もできます。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>// 下記の書き方、どれでも可能</span></pre>
<pre><span>$</span>(<span>"&lt;a&gt;"</span>)</pre>
<pre><span>$</span>(<span>"&lt;a&gt;&lt;/a&gt;"</span>)</pre>
<pre><span>$</span>(<span>"&lt;img&gt;"</span>)</pre>
<pre><span>$</span>(<span>"&lt;img /&gt;"</span>)</pre>
<div></div>
<pre><span>// しかし本家サイトでは、互換性の為、中身を取るタグについては、</span></pre>
<pre><span>// 終了タグを付けることを推奨している。</span></pre>
<pre><span>// 中身を取らないタグはどちらでも、OKとしている。下記は推奨形式。</span></pre>
<pre><span>$</span>(<span>"&lt;a&gt;&lt;/a&gt;"</span>)</pre>
<pre><span>$</span>(<span>"&lt;img&gt;"</span>)</pre>
<pre><span>$</span>(<span>"&lt;img /&gt;"</span>)</pre>
<pre>});</pre></div>


<h4><b>$("html", attributes )</b></h4>
<p>中級者以上向け機能ですが、第2引数にオブジェクトを指定すると、そのオブジェクトのプロパティは、HTMLの属性として設定されます。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"&lt;a&gt;&lt;/a&gt;"</span>, {</pre>
<pre><span>href</span>:<span>"abc.html"</span>,</pre>
<pre><span>target</span>:<span>"_blank"</span>,</pre>
<pre><span>"class"</span>:<span>"myClass"</span></pre>
<pre> });</pre>
<pre>});</pre></div>
<p>上記を見ると、classのキーだけは、クォーテーションで囲まれていますが、これはclassがJavaScriptの予約語の為、このようにする必要があります。
第2引数を指定するときは、第1引数は、属性など書かれていないシンプルなタグに留めないと行けません。欲張って次のような書き方をすることはできません。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"&lt;a href='bar.html'&gt;&lt;/a&gt;"</span>, {</pre>
<pre><span>target</span>:<span>"_blank"</span></pre>
<pre> });</pre>
<pre>});</pre></div>
<p>また、属性のみに限らず、各種イベントタイプやval, css, html, text, data, width, height, offsetなどのjQueryメソッドをオブジェクトに含めることができます。 更に言えば、Ver.1.8からは、あらゆるjQueryメソッドを指定することができます。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"&lt;div&gt;&lt;/div&gt;"</span>, {</pre>
<pre><span>width</span>:<span>100</span>,</pre>
<pre><span>height</span>:<span>100</span>,</pre>
<pre><span>css</span>: {<span>border</span>:<span>"5px solid gray"</span>},</pre>
<pre><span>addClass</span>:<span>"my-div"</span>,</pre>
<pre><span>on</span>: {</pre>
<pre><span>click</span>:<span>function</span>(<span>event</span>) {</pre>
<pre><span>// イベント設定</span></pre>
<pre>   }</pre>
<pre>  }</pre>
<pre> });</pre>
<pre>});</pre></div>
<p>もっとも、あまり派手にやると訳が分からなくなりますので、第2引数の使用はある程度限定して、イベントの付与などは、別途生成したjQueryオブジェクトに対して行えば良いでしょう。</p>


</div>
<div id="calibre_link-351">
<h1 id="calibre_link-361">2章　セレクター</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-64">基本的なセレクター</a></li>
	<li><a href="#calibre_link-65">検索する対象（範囲）を指定する書き方</a></li>
	<li><a href="#calibre_link-66">階層構造によるセレクター</a></li>
	<li><a href="#calibre_link-71">基本、子要素フィルター</a></li>
	<li><a href="#calibre_link-83">コンテントフィルター</a></li>
	<li><a href="#calibre_link-86">フォーム系フィルター</a></li>
<li><a href="#calibre_link-90">.is()フィルター</a></li>
<li><a href="#calibre_link-91">セレクト回数を減らそう</a></li>
</ul>
</div>
<div id="calibre_link-16">
<h2 id="calibre_link-64">基本的なセレクター</h2>
<p>jQueryでは、CSSでお馴染みのセレクターを使って、要素を選択（取得）します。ここでは、以下の基本的なCSSセレクターを見て行きましょう。</p>


<ul>
	<li><a href="#calibre_link-17">要素（タグ）セレクター</a></li>
	<li><a href="#calibre_link-18">クラスセレクター</a></li>
	<li><a href="#calibre_link-19">IDセレクター</a></li>
	<li><a href="#calibre_link-20">グループセレクター</a></li>
	<li><a href="#calibre_link-21">ユニバーサルセレクター</a></li>
	<li><a href="#calibre_link-22">属性セレクター</a></li>
</ul>
<h3 id="calibre_link-17"><b>要素（タグ）セレクター</b></h3>
<p>要素（タグ）名を元に対象要素を選択します。要素名は、括弧（&lt;&gt;）は付けずに、そのまま書きます。<br />
例えば、</p>
<div>
<pre><span>$</span>(<span>"h2"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>こうすることで、全てのH2要素の文字色を赤色に設定します。</p>
<h3 id="calibre_link-18"><b>クラスセレクター</b></h3>
<p>特定のクラス名を元に対象要素を選択します。クラス名は、ドットの後に続けて書きます。<br />
例えば、</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"man"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"man"</span><span>&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"woman"</span><span>&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>とHTMLがある時に、</p>
<div>
<pre><span>$</span>(<span>".man"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>このようにすると、次の結果になります。</p>
<ul>
	<li>太郎</li>
	<li>次郎</li>
	<li>花子</li>
</ul>
<h3 id="calibre_link-19"><b>IDセレクター</b></h3>
<p>特定のIDを元に対象要素を選択します。IDは、#の後に続けて書きます。IDは、1ページにつき1つのみ存在すべきものです。<br />
例えば、</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>とHTMLがある時に、</p>
<div>
<pre><span>$</span>(<span>"#taro"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>このようにすると、次の結果になります。</p>
<ul>
	<li id="calibre_link-362">太郎</li>
	<li>次郎</li>
	<li>花子</li>
</ul>


<h3 id="calibre_link-20"><b>グループセレクター</b></h3>
<p>複数のセレクターを半角カンマで繋げて、同時に指定することができます。 例えば、H1～H3までの要素全てを選択する場合は、</p>
<div>
<pre><span>$</span>(<span>"h1, h2, h3"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>こうなります。半角カンマの前後の空白はあっても無くても大丈夫です。上記は、要素セレクターのみで組み合わせましたが、下記のように他のセレクター同士でも可能です。</p>
<div>
<pre><span>$</span>(<span>"h1, .man, #taro"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>


<h3 id="calibre_link-21"><b>ユニバーサルセレクター</b></h3>
<p>全ての要素を選択するためのセレクターとしてユニバーサルセレクターがあります。アスタリスクで表現します。（分かりやすく言えば、ワイルドカードですね）</p>
<div>
<pre><span>$</span>(<span>"*"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre>
<pre><span>$</span>(<span>"#important *"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>2行目のように子孫セレクター（後ほど見ます）と組み合わせることもできます。この場合は、IDがimportantの要素の中にあるタグ全てに対して、文字色を赤に設定します。</p>
<h3 id="calibre_link-22"><b>属性セレクター</b></h3>
<p>要素の属性を元に選択するセレクターです。通常は、要素名に続けて書くことが多いですが、クラス名でも大丈夫です。<br />
サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;a</span><span>href</span>=<span>""</span><span>target</span>=<span>"_blank"</span><span>&gt;</span>ピンクです<span>&lt;/a&gt;</span></pre>
<pre><span>&lt;a</span><span>href</span>=<span>""</span><span>target</span>=<span>"_self"</span><span>&gt;</span>青です<span>&lt;/a&gt;</span></pre>
<pre><span>&lt;a</span><span>href</span>=<span>""</span><span>target</span>=<span>"_parent"</span><span>&gt;</span>赤です<span>&lt;/a&gt;</span></pre>
<pre><span>&lt;a</span><span>href</span>=<span>""</span><span>target</span>=<span>"_top"</span><span>class</span>=<span>"fruit"</span><span>&gt;</span>緑です<span>&lt;/a&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"a[target='_blank']"</span>).<span>css</span>(<span>"color"</span>,<span>"pink"</span>);</pre>
<pre><span>$</span>(<span>"a[target='_self']"</span>).<span>css</span>(<span>"color"</span>,<span>"blue"</span>);</pre>
<pre><span>$</span>(<span>"a[target=_parent]"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre>
<pre><span>$</span>(<span>".fruit[target=_top]"</span>).<span>css</span>(<span>"color"</span>,<span>"green"</span>);</pre></div>
<p>実行結果<br />
<a href="#calibre_link-16">ピンクです</a>
<a href="#calibre_link-16">青です</a>
<a href="#calibre_link-16">赤です</a>
<a href="#calibre_link-16">緑です</a></p>
<p>4行目にあるように、クラスセレクターから始めてもOKです。<br />
それでは、1つ1つ属性セレクターを見てみましょう。</p>
<h4><b>[属性名]</b></h4>
<p>ある特定の属性名を含む要素を絞り込みます。</p>
<div>
<pre><span>$</span>(<span>"img[title]"</span>)</pre></div>
<p>この場合、title属性を持つimg要素全てを選択します。</p>
<h4><b>[属性名 = 値]</b></h4>
<p>値と完全一致した属性を持つ要素を絞り込みます。</p>
<div>
<pre><span>$</span>(<span>"a[target='_blank']"</span>)</pre></div>
<p>target属性が_blankのリンクを全て選択します。" と ' のクォーテーションの順番は、正しく入れ子になっていれば変わってもOKです。<br />
また、値が1語の単語の時は、値を括るクォーテーションを取ってもOKです。（[target=_blank]）</p>
<h4><b>[属性名 != 値]</b></h4>
<p>値と完全一致することのない属性を絞り込みます。</p>
<div>
<pre><span>$</span>(<span>"a[target!='_blank']"</span>)</pre></div>
<p>target属性が_blankでないリンクを全て選択します。この記述は、後に出てくる :not([attr="value"]) と等価です。</p>
<p>なお、元々target属性が指定されてないリンクは、デフォルトで_blankではありませんので、それらも選択対象になります。 また、このセレクターは、CSSの仕様には無く、jQueryが独自に拡張しているものです。</p>
<h4><b>[属性名 *= 値]</b></h4>
<p>値と部分一致した属性を持つ要素を絞り込みます。</p>
<div>
<pre><span>&lt;input</span><span>name</span>=<span>"cat"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"cat-5"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"catman"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"dog cat horse"</span><span>&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"input[name*='cat']"</span>)</pre></div>
<p>このセレクターの場合、上記のinput全てにヒットするのでご注意下さい。<br />
（もし単語ベースでの一致にする場合は、この次のセレクターを使います）</p>
<h4><b>[属性名 ~= 値]</b></h4>
<p>上記の *= と少し似ていますが、こちらは、スペースで区切られた単語ベースでの一致判定となります。</p>
<div>
<pre><span>&lt;input</span><span>name</span>=<span>"cat"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"cat-5"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"catman"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>name</span>=<span>"dog cat horse"</span><span>&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"input[name~='cat']"</span>)</pre></div>
<p>この場合は、1行目と4行目のinputにヒットします。</p>
<h4><b>[属性名 ^= 値]</b></h4>
<p>値と前方一致した属性を持つ要素を絞り込みます。</p>
<div>
<pre><span>$</span>(<span>"a[href^='http://']"</span>)</pre>
<pre><span>$</span>(<span>"a[href^='http://'], a[href^='https://']"</span>)</pre></div>
<p>上記の2つ共、外部リンクのみを選択します。（但し、内部リンクが全て相対パスで記述していると想定）<br />
HTTPSのサイトもあることも考えると、2番目の書き方がよりいいでしょう。</p>
<h4><b>[属性名 $= 値]</b></h4>
<p>値と後方一致した属性を持つ要素を絞り込みます。</p>
<div>
<pre><span>$</span>(<span>"a[href$='.pdf']"</span>)</pre></div>
<p>PDFへのリンクを張ってあるリンクをこれで選択できます。</p>
<h4><b>[属性名 = 値][属性名 = 値]</b></h4>
<p>上記で出てきた属性セレクターを組み合わせて、全ての条件に一致するものだけを選択できます。</p>
<div>
<pre><span>$</span>(<span>"a[href^='http://'][target='_blank']"</span>)</pre></div>
<p>URLが、http://から始まるリンクで、かつ、target属性が_blankになっているリンクを選択します。条件は、幾つでも組み合わせられます。</p>


</div>
<div id="calibre_link-12">
<h2 id="calibre_link-65">検索する対象（範囲）を指定する書き方</h2>
<p>通常セレクターは、ドキュメントの最上位からセレクターによる検索（マッチング）を行いますが、第2引数を指定して、特定の要素以下に限定することができます。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;&lt;span&gt;</span>太郎<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;&lt;span&gt;</span>次郎<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;&lt;span&gt;</span>花子<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>とHTMLがある時に、</p>
<div>
<pre><span>$</span>(<span>"span"</span>,<span>"#taro"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>このように書くと、#taro以下のspan要素のみが選択されます。もっともこの場合、$("#taro span")と最初から書けますが、この書き方が役に立つ場面も多いので、是非覚えておいて下さい。（これは、jQueryの独自仕様です）</p>
</div>
<div id="calibre_link-330">
<h2 id="calibre_link-66">階層構造によるセレクター</h2>
<p>ここでは、階層構造に基づくjQueryのセレクター（CSSのセレクター）を見て行きましょう。</p>
<ul>
	<li><a href="#calibre_link-67">子孫セレクター</a></li>
	<li><a href="#calibre_link-68">子セレクター</a></li>
	<li><a href="#calibre_link-69">隣接兄弟セレクター</a></li>
	<li><a href="#calibre_link-70">一般兄弟セレクター</a></li>
</ul>
<h3 id="calibre_link-67"><b>子孫セレクター</b></h3>
<p>ある要素の中にある要素（全て）を選択する場合に使います。半角スペースで階層構造を分けます。</p>
<div>
<pre><span>$</span>(<span>"h2 strong"</span>)</pre>
<pre><span>$</span>(<span>"p.intro a"</span>)</pre></div>
<p>1番目は、h2要素の中にある全てのstrong要素を選択します。2番目は、クラス名introのついたp要素の中にあるリンク全てを選択します。</p>
<h3 id="calibre_link-68"><b>子セレクター</b></h3>
<p>ある要素の中にある要素（全て）を選択する場合に使いますが、上記の子孫セレクターと異なり、直下の子供だけが選択対象になります。 大なり記号（&gt;）を使います。</p>
<div>
<pre><span>$</span>(<span>"body &gt; h2"</span>)</pre></div>
<p>このようにある場合、body直下のh2要素のみを選択します。 もしh2を他のdivの中に入れていた場合は、選択対象になりません。</p>
<div>
<pre><span>&lt;body&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>ここは対象<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>ここは対象外<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/body&gt;</span></pre></div>
<p>この大なり記号（&gt;）、いかにも親と子（大と小）という感じがしますね。</p>
<h3 id="calibre_link-69"><b>隣接兄弟セレクター（Adjacent Sibling）</b></h3>
<p>隣接している兄弟で、後ろ側にある方が選択対象になります。プラス記号（+）を使います。<br />
  兄弟ですので、まず同じ親を共有していなければなりません。また隣接（隣同士）でなければなりません。<br />
例えば、</p>
<div>
<pre><span>$</span>(<span>"h2 + p"</span>)</pre></div>
<p>とある場合、h2のすぐ後に出てくるp要素を選択します。 具体的に見てみましょう。</p>
<div>
<pre><span>&lt;h2&gt;</span>宇宙について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ1<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ2<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ3<span>&lt;/p&gt;</span></pre>
<div></div>
<pre><span>&lt;h2&gt;</span>地球について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ4<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ5<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ6<span>&lt;/p&gt;</span></pre>
<div></div>
<pre><span>&lt;h2&gt;</span>平和について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;div&gt;</span>DIVです<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ7<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ8<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ9<span>&lt;/p&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"h2 + p"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>実行結果は、次のようになります。「パラグラフ7」は、h2と隣接していなので選択対象外です。</p>
<p><img src="images/000061.gif" /></p>
<p>このプラス記号（+）、いかにも、くっついている感がありますね。</p>
<h3 id="calibre_link-70"><b>一般兄弟セレクター（General Sibling）</b></h3>
<p>隣接兄弟セレクターと似ていますが、こちらは、隣接している必要がありません。後ろ側にあれば選択対象になります（但し、前側は対象外です）。記号は、チルダ（~）を使います。<br />
具体例を見てみましょう。HTMLは、兄弟隣接の時と比べdivの中（12行目）だけを変更しています。</p>
<div>
<pre><span>&lt;h2&gt;</span>宇宙について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ1<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ2<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ3<span>&lt;/p&gt;</span></pre>
<div></div>
<pre><span>&lt;h2&gt;</span>地球について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ4<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ5<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ6<span>&lt;/p&gt;</span></pre>
<div></div>
<pre><span>&lt;h2&gt;</span>平和について<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;div&gt;&lt;p&gt;</span>中にあるパラグラフ<span>&lt;/p&gt;&lt;/div&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ7<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ8<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ9<span>&lt;/p&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"h2 ~ p"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>実行結果は、次のようになります。ほとんどのパラグラフが赤になっていますが、divの中に入ったパラグラフだけは兄弟ではないので、対象外になっています。</p>
<p><img src="images/000074.gif" /></p>
<p>このチルダ記号（~）、多少離れていてもOK感があるように見えます。<br />
ちなみに、一般兄弟と訳しましたが、まだこの日本語訳自体、一般的ではありません。 またちなみに、先の隣接兄弟セレクターは、CSS2で定義されていますが、こちらの一般兄弟セレクターは、CSS3で定義されています。</p>
</div>
<div id="calibre_link-295">
<h2 id="calibre_link-71">基本、子要素フィルター</h2>
<p>ここでは、フィルターと呼ばれるものを見てみましょう。フィルターとは、既に選択している要素を更に絞り込みを掛けるセレクターに対して使う用語です。</p>


<ul>
	<li><a href="#calibre_link-73">:first、:first-child</a></li>
	<li><a href="#calibre_link-74">:last、:last-child</a></li>
	<li><a href="#calibre_link-75">:nth-child()</a></li>
	<li><a href="#calibre_link-76">:only-child</a></li>
	<li><a href="#calibre_link-77">:even、:odd</a></li>
	<li><a href="#calibre_link-78">:nth-child()、:even、:oddサンプル</a></li>
	<li><a href="#calibre_link-79">:eq()、:gt()、:lt()</a></li>
	<li><a href="#calibre_link-80">:not()</a></li>
	<li><a href="#calibre_link-81">:header</a></li>
	<li><a href="#calibre_link-82">:animated</a></li>
</ul>
<h3 id="calibre_link-72"><b>少しまとめ</b></h3>
<p>個別のフィルターを見る前に、少しまとめておきましょう。 フィルターには、CSSから来ているのものとjQueryが独自に定義しているものの2つがあります。どちらがどちらと覚える必要は無いものもありますが（:headerや:animatedなど）、中には下記の特徴が影響するため、覚えておいた方がよいものもあります。</p>
<p>CSSからのフィルターは、CSSの仕様に準拠しており、最初の要素を1から数えます。一方、jQuery独自のものは、最初の要素を0から数えます（JavaScriptに準拠しているため）。更に、jQuery独自のものは、選択対象の全体を1つとみなして採番します。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b></b></th>
<th><b>CSSからのフィルター</b></th>
<th><b>jQuery独自に実装</b></th>
</tr>


<tr>
<th><b>フィルター</b></th>
<td>:first-child、:last-child<br />:nth-child()<br />:only-child<br /><br />（更にVer.1.9以降は下記のCSS3のフィルターもサポート）<br />
    :nth-of-type<br />
    :first-of-type、:last-of-type<br />
    :nth-last-child、:nth-last-of-type<br />
    :only-of-type<br />
    :target、:root<br />
    :lang（これはCSS2）
</td>
<td>:first、:last<br />even、:odd<br />:eq()、:gt()、:lt()<br />:header<br />:animated</td>
</tr>
<tr>
  	<th><b>特徴</b></th>
<td>1から数える（CSSに準拠）</td>
<td>0から数える（JavaScriptに準拠）<br />全体を1つとしてみなす</td>
</tr>


</tbody>
</table>
<p>&nbsp;</p>
<p>以降、CSS的な話が多く続きます。CSSからのフィルターのVer.1.9から加わったものについては、解説を省略させていただきます（CSSの話になってしまう為）。</p>
<h3 id="calibre_link-73"><b>:first、:first-child</b></h3>
<p>（いきなり2つのセレクターを見ますが、:first-childは、少し曲者の部分があります）</p>
<p>:firstは、マッチした要素の中から最初の要素だけを選択します。
  一方、:first-childは、親要素に対する最初の子要素を全て選択します。<br />
具体的に見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li:first"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre>
<pre><span>$</span>(<span>"li:first-child"</span>).<span>css</span>(<span>"font-size"</span>,<span>"2em"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000003.gif" /></p>
<p>li:firstの場合は、liでマッチした要素全ての内の最初の要素だけが選択されますので、「太郎」だけが赤文字になります。
一方、li:first-childは、LI要素の中の（その親に対する）最初の子供全てがマッチしますので、「太郎」と「リンゴ」が2倍の大きさのフォントになります。</p>
<p>更に理解を深めたい方は、次のより違いが分かり易い（けど少し難しい）例を見てみましょう。</p>
<div>
<pre><span>&lt;body&gt;</span></pre>
<pre><span>&lt;div&gt;</span>始めに<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ1<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ2<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ3<span>&lt;/p&gt;</span></pre>
<div></div>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフA<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフB<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフC<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/body&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"p:first"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre>
<pre><span>$</span>(<span>"p:first-child"</span>).<span>css</span>(<span>"font-size"</span>,<span>"2em"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000023.gif" /></p>
<p>今回は、p:firstで赤くなったのは、「パラグラフ1」のみです。予想通りです。では、p:first-childは、どうでしょうか？2倍の大きさのフォントになったのは、「パラグラフA」のみです。<br />
「パラグラフ1」もと思いたいところですが、「パラグラフ1」の親のbodyから見ると、「パラグラフ1」は、2番目の子供なのでNGなのです。（1番目は「&lt;div&gt;始めに&lt;/div&gt;」の為）</p>
<p>:first-childは、親要素から見て、最初の子供（first-child）でなければならないからです。LI要素の場合は、もっぱらUL又はOL要素の中にあるので分かり易いですが、それ以外の要素で使うとどれが該当するか分かりにくくなります。そもそも親を指定しませんので。first-childは、最初の段落だけ強調したい（orマージンを大きく取りたい）などの場合に使えると思います。</p>
<p>ご存知の方も多いと思いますが、:first-childは、CSS2で定義されています。一方、:firstは、jQueryが独自に拡張したものです。</p>
<h3 id="calibre_link-74"><b>:last、:last-child</b></h3>
<p>:first, :first-childの「最初」が「最後」に置き換わったバージョンです。
詳しくは、:first, :first-childの方をご覧ください。</p>
<h3 id="calibre_link-75"><b>:nth-child()</b></h3>
<p>ある特定番目の要素を取得するのに使います。例えば、次のようになります。</p>
<ul>
<li>:nth-child(3)　→3番目を取得</li>
<li>:nth-child(even)　→ 偶数番目を取得</li>
<li>:nth-child(odd)　→ 奇数番目を取得</li>
<li>:nth-child(3n)　→3個おきに取得</li>
<li>:nth-child(3n+1)　→3で割った時に1余る番目を取得</li>
</ul>
<p>nとある部分は、0,1,2,3,4...を掛け算すると解釈して下さい。つまり、、、<br />
  3nは、0（3x0）、3（3x1）、6（3x2）、9（3x3）...、番目<br />
  3n+1は、1（3x0+1）、4（3x1+1）、7（3x2+1）、10（3x3+1）...、番目<br />
を取得します。</p>
<p>5n+2は、次のようにも捉えられます。要素を5つずつ整列させた時の各行の2番目、と。次のイメージです。</p>
<p><img src="images/000019.gif" /></p>
<p>動くサンプルは、「:even、:odd」を見終わった<a href="#calibre_link-78">後の次</a>を参照下さい。</p>
<h3 id="calibre_link-76"><b>:only-child</b></h3>
<p>:only-childは、各親要素が1つだけ子要素を持つ場合に、その子要素を選択します。言うなれば、lonelyな子供だけを選択します。 具体例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>一匹狼<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li:only-child"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000063.gif" /></p>
<p>テキストノードは、子要素としてはカウントされないため、例えば以下の様なp要素は、:only-childの対象になります。</p>
<div>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;p&gt;</span>パラグラフ<span>&lt;/p&gt;</span></pre>
<pre> 今日の献立</pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"p:only-child"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000041.gif" /></p>
<h3 id="calibre_link-77"><b>:even、:odd</b></h3>
<p>セレクターでマッチした要素の中から偶数番目（even）、奇数番目（odd）の要素をフィルターして選択します。 一番最初を0から数えるので、直感とは逆になります。つまり、最初が偶数になります。 具体例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>マイク<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>ベル<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>ナルト<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li:even"</span>).<span>css</span>(<span>"color"</span>,<span>"blue"</span>);</pre>
<pre><span>$</span>(<span>"li:odd"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000010.gif" /></p>
<p>UL要素が2つに分かれていますが、2つでも3つでも関係ありません。セレクターでマッチした要素全体でもって偶数か奇数かの判定になります。<br />
  ご覧の通り、「太郎」が、even（偶数）になっています。直感と異なりますのでご注意下さい。<br />
なお、:nth-child()は、1から数えます。詳しくは、<a href="#calibre_link-75">:nth-child()</a>をご覧ください。</p>
<h3 id="calibre_link-78"><b>:nth-child()、:even、:oddサンプル</b></h3>
<p>上記で見た:even、:oddフィルターは、親要素には関係なく、マッチした全体の要素の中において、偶数、奇数を決めます。
一方、:nth-child(even)、:nth-child(odd)は、各親からの順番で数えます。また、:even、:oddフィルターは、JavaScriptに準拠しているため、プログラム言語らしく0から数えますが、:nth-child()は、CSSに準拠しているため（CSS3にて登場）、1から数えます。</p>
<p><a href="http://jquery-master.net/examples/selectors_nth-child.php">確認用のサンプル</a>の「:nth-child(even)」と「:even」ボタンを押し比べてみて、よくよく違いを確かめて下さい。</p>



<h3 id="calibre_link-79"><b>:eq()、:gt()、:lt()</b></h3>
<p>セレクターでマッチした要素の中から、<br /></p>
<ul>
<li>eq(n) ...n番目の要素を選択</li>
<li>gt(n) ...n番目より大きい（超の）要素を選択</li>
<li>lt(n) ...n番目より小さい（未満の）要素を選択</li>
</ul>
<p>します。 一番最初を0から数えるので、直感とは異なります。 具体例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>四郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>五郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li:eq(2)"</span>).<span>css</span>(<span>"font-size"</span>,<span>"2em"</span>);</pre>
<pre><span>$</span>(<span>"li:gt(2)"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre>
<pre><span>$</span>(<span>"li:lt(2)"</span>).<span>css</span>(<span>"color"</span>,<span>"blue"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000029.gif" /></p>
<p>なお、:nth-child()は、1から数えましたね。ところで、ここで1つ問題です。以下のように社員の名前の部分のみピンク色にするjQueryは、どのように記述したら良いでしょうか？少し考えてみてください。</p>
<p><img src="images/000046.gif" alt="" /></p>
<p>HTMLは、こちらです。</p>
<div>
<pre><span>&lt;table</span><span>width</span>=<span>"400"</span><span>border</span>=<span>"1"</span><span>&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;th&gt;</span>社員番号<span>&lt;/th&gt;</span></pre>
<pre><span>&lt;th&gt;</span>名前<span>&lt;/th&gt;</span></pre>
<pre><span>&lt;th&gt;</span>年齢<span>&lt;/th&gt;</span></pre>
<pre><span>&lt;th&gt;</span>性別<span>&lt;/th&gt;</span></pre>
<pre><span>&lt;th&gt;</span>血液型<span>&lt;/th&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;td&gt;</span>101<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>のび太郎<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>25歳<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>男性<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>A型<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;td&gt;</span>102<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>スネ五郎<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>24歳<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>男性<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>O型<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;td&gt;</span>103<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>静子<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>21歳<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>女性<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>A型<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;/table&gt;</span></pre></div>
<p>例えば、以下のようにすると、下の画像のようになります。</p>
<div>
<pre><span>$</span>(<span>"td"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre></div>
<p><img src="images/000051.gif" alt="" /></p>
<p>これは、普通ですね。（最初の行は、thタグなので、色は付きません）<br />
では、下記のようにするとどうでしょうか？</p>
<div>
<pre><span>$</span>(<span>"td:eq(2)"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre></div>
<p>結果は、こうなります。</p>
<p><img src="images/000018.gif" alt="" /></p>
<p>td全部を最初から数えて（0スタート）、2番目に色が付きました。ただ、目的とはだいぶかけ離れています。<br />
そこで、こうするとどうでしょうか？</p>
<div>
<pre><span>$</span>(<span>"td:nth-child(2)"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre></div>
<p>下記のようになります。</p>
<p><img src="images/000046.gif" alt="" /></p>
<p>これが正解です。td:nth-child(2)は、（親から見て）2番目の子となるtd要素を選択します。:eq()と:nth-child()、もし混乱したら、このサンプルを思い出して下さい。</p>
<h3 id="calibre_link-80"><b>:not()</b></h3>
<p>:not(selector) の形で、このセレクターにマッチしない要素のみをフィルターして選択します。
  セレクターは、どのようなものでも記述できます。<br />
以下は、target属性が、blankでないリンクを選択します。</p>
<div>
<pre><span>$</span>(<span>"a:not([target!='blank'])"</span>)</pre></div>
<p>これと似ているものに、<a href="#calibre_link-135">.not()</a>というメソッドがあります。:not()を使って記述が複雑になる場合は、.not()の使用を検討しましょう。</p>
<h3 id="calibre_link-81"><b>:header</b></h3>
<p>h1, h2, ～h6のヘッダー要素をフィルターして選択します。</p>
<h3 id="calibre_link-82"><b>:animated</b></h3>
<p>セレクターが実行された時において、アニメーションが動作中のものをフィルターして選択します。<br />
一見役に立たなそうですが、何気にアニメーション処理を書く際に役に立ちます。アニメーションについては、また改めて見ます。</p>
</div>
<div id="calibre_link-350">
<h2 id="calibre_link-83">コンテントフィルター</h2>
<p>コンテントフィルターは、要素が含んでいるコンテント（中身）に応じて、更に要素を絞り込む時に使います。<br /></p>


<ul>
	<li><a href="#calibre_link-84">:contains()、:has()</a></li>
	<li><a href="#calibre_link-85">:empty、:parent</a></li>
</ul>
<h3 id="calibre_link-84"><b>:contains()、:has()</b></h3>
<p>:contains(text) の形で、textという文字を含んでいる要素を選択します。<br />
:has(selector) の形で、selectorで指定した要素を含む要素のみを選択します。</p>
<p>具体例で見てみましょう。まずは、:contains(text)の場合から。</p>
<div>
<pre><span>&lt;div&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>次郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>三郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>花子<span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"div:contains('郎')"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000020.gif" /></p>
<p>次に、:has()の場合</p>
<div>
<pre><span>&lt;div&gt;&lt;span&gt;</span>山田<span>&lt;/span&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>次郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>三郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>花子<span>&lt;/div&gt;</span>
</pre></div>
<div>
<pre><span>$</span>(<span>"div:has(span)"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000054.gif" /></p>
<p>span要素を含んだdivのみが選択されています。<br />
（spanは、直接の子供に限らず、子孫であれば大丈夫です）</p>
<h3 id="calibre_link-85"><b>:empty、:parent</b></h3>
<p>:emptyは、何ら子要素を持たない要素を選択します。<br />
:parentは、何かしらの子要素を持つ要素を選択します。つまり、親要素のみが対象になります。</p>
<p>（注）ここでの子要素は、単なるテキスト（テキストノード）も含みます。<br />
  :emptyと :parent、とても反対語とは言えない2つですが、機能的にはそれぞれ反対の作用をします。</p>
<p>具体例で見てみましょう。<br /></p>
<div>
<pre><span>&lt;table</span><span>border</span>=<span>"1"</span><span>&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;td&gt;</span>太郎<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>三郎<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;tr&gt;</span></pre>
<pre><span>&lt;td&gt;&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;</span>マイク<span>&lt;/td&gt;</span></pre>
<pre><span>&lt;td&gt;&lt;/td&gt;</span></pre>
<pre><span>&lt;/tr&gt;</span></pre>
<pre><span>&lt;/table&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"td:empty"</span>).<span>css</span>(<span>"background-color"</span>,<span>"gray"</span>);</pre>
<pre><span>$</span>(<span>"td:parent"</span>).<span>css</span>(<span>"background-color"</span>,<span>"yellow"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000053.gif" /></p>
<p>なおこれらとは別に、メソッドの<a href="#calibre_link-127">.empty()</a>、<a href="#calibre_link-137">.parent()、.parents()</a>というのもあります。</p>
</div>
<div id="calibre_link-320">
<h2 id="calibre_link-86">フォーム系フィルター</h2>
<p>フォーム系フィルターは、フォーム系の要素をそのタイプや状態で更に絞り込む時に使います。</p>


<ul>
	<li><a href="#calibre_link-87">フォームのタイプでの選択</a></li>
	<li><a href="#calibre_link-88">フォームの状態での選択</a></li>
	<li><a href="#calibre_link-89">表示・非表示でのフィルター</a></li>
</ul>
<h3 id="calibre_link-87"><b>フォームのタイプでの選択</b></h3>
<p>フォームを構成する要素は、見た目は違っても全てinput要素で、type属性が異なるだけです。（textarea、selectなど一部を除く）<br />
つまり、、、</p>
<div>
<pre><span>&lt;input</span><span>type</span>=<span>"text"</span><span>value</span>=<span>""</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"radio"</span><span>value</span>=<span>""</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>value</span>=<span>""</span><span>&gt;</span></pre></div>
<p>これらのtypeごとに選択するためのセレクターです。（:inputと :buttonは、少し異なります）</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>セレクター</b></th>
<th><b>対象</b></th>
<th><b>代替方法</b></th>
</tr>
<tr>
<td>:button</td>
<td>全ての&lt;button&gt;要素と&lt;input type="button"&gt;要素</td>
<td> $("button, input[type='button']")</td>
</tr>
<tr>
<td>:checkbox</td>
<td>チェックボックス</td>
<td> [type="checkbox"]</td>
</tr>
<tr>
<td>:file</td>
<td>ファイル選択ボックス</td>
<td> [type="file"]</td>
</tr>
<tr>
<td>:image</td>
<td>画像ボタン</td>
<td> [type="image"]</td>
</tr>
<tr>
<td>:input</td>
<td>全てのフォーム構成要素（input、textarea、select、button要素）</td>
<td></td>
</tr>
<tr>
<td>:password</td>
<td>パスワード入力ボックス</td>
<td> [type="password"]</td>
</tr>
<tr>
<td>:radio</td>
<td>ラジオボタン</td>
<td> [type="radio"]</td>
</tr>
<tr>
<td>:reset</td>
<td>リセットボタン</td>
<td> [type="reset"]</td>
</tr>
<tr>
<td>:submit</td>
<td>送信ボタン（button要素の扱いはブラウザによって相違有り）</td>
<td>[type="submit"]</td>
</tr>
<tr>
<td>:text</td>
<td>テキストボックス（&lt;input type="text"&gt;）<br />Ver. 1.5.2よりtype="text"の指定が無くても選択します。</td>
<td> [type="text"]</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>例えば、以下のようになります。</p>
<div>
<pre><span>// 例）ラジオボタンを選択して何か処理する</span></pre>
<pre><span>$</span>(<span>"input:radio"</span>).xxx()</pre></div>
<p>HTML5では、type="tel"を始め、各種入力タイプがありますが、代替方法にあるような書き方で対応できます。また、今回見た:checkboxのような書き方は、jQuery独自であり、今時のブラウザでのパフォーマンス優位性を利用できない（→ querySelectorAll()が使えない）などの理由により、代替方法が推奨されています。<br />
なお、:hiddenについては、少し他と異なるので、下の「表示・非表示でのフィルター」で見てみます。<br />
また、ここで見た:checkboxとすぐ下で見る:checked、単語は似ていますが別物ですのでご注意下さい。</p>
<h3 id="calibre_link-88"><b>フォームの状態での選択</b></h3>
<p>以下の4つがあります。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>セレクター</b></th>
<th><b>対象</b></th>
<th><b>使用例</b></th>
</tr>
<tr>
<td>:checked</td>
<td>チェックボックス（checkbox）とラジオボタン（radio）のチェックが入っている状態の要素</td>
<td>$("input:checked")</td>
</tr>
<tr>
<td>:selected</td>
<td>リストボックス（select＋option）の選択されている状態の要素</td>
<td>$("select option:selected")</td>
</tr>
<tr>
<td>:disabled</td>
<td>利用不可なフォーム要素</td>
<td>$('input:disabled')</td>
</tr>
<tr>
<td>:enabled</td>
<td>利用可能なフォーム要素</td>
<td>$('input:enabled')</td>
</tr>
</tbody>
</table>


<h3><b>表示・非表示でのフィルター</b></h3>
<p>要素の表示・非表示でのフィルターです。以下のものがあります。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>セレクター</b></th>
<th><b>対象</b></th>
</tr>
<tr>
<td>:visible</td>
<td>表示状態の要素</td>
</tr>
<tr>
<td>:hidden</td>
<td>非表示状態の要素</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>ここで表示・非表示とは、その要素が画面上のスペースを取っているか否かで判断します。visibility: hiddenやopacity: 0は、スペースを取るため、visible（表示）と判断されます。</p>
<p>非表示状態は、以下も含みます。</p>
<ul>
<li>CSSのdisplay: none</li>
<li>フォームのtype="hidden"</li>
<li>高さと幅が明示的に0に設定されている要素</li>
<li>先祖要素が非表示のために非表示となっている要素</li>
</ul>
</div>
<div id="calibre_link-299">
<h2 id="calibre_link-90">.is()フィルター</h2>
<p>jQueryオブジェクトが、引数で指定したセレクターにマッチするかをチェックし、1つでもマッチする要素があると、trueを返し、なければ、falseを返します。他のフィルターと異なり、true/falseを返すのでご注意下さい。</p>
<p>例）</p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"man"</span><span>&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>花子<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;</span>花絵<span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// divの1つは、manクラスであるため、retはtrueになる</span></pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"div"</span>).<span>is</span>(<span>".man"</span>);</pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>上記の目的であれば、改めて見る.hasClass()で代用できますが、例えば、先ほど見たばかりの:checkedを使い、次のようにも使えます。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"chk1"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// chk1にチェックあり状態の時は、retはtrueになる</span></pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"#chk1"</span>).<span>is</span>(<span>":checked"</span>);</pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>この.is()は、後の章で見るイベントなどと絡めると、効果を発揮してきます。</p>



</div>
<div id="calibre_link-10">
<h2 id="calibre_link-91">セレクト回数を減らそう</h2>
<p><a href="#calibre_link-11">「メソッドチェーン」</a>で見たように、一度選択したjQueryオブジェクトに鎖のようにメソッドを繋いで書くことができました。そのように書くことで、セレクターによるjQueryオブジェクトの選択を1度で済ませることができます（＝余計な負荷を減らせます）。しかし、場合によっては、散らばった場所において、同じjQueryオブジェクトを参照しないといけないこともあるでしょう。そのような場合、メソッドチェーンも使えなくなります。そのような時は、一度選択したオブジェクトを変数に格納するようにすると良いでしょう。（負荷やメンテナンス的にも）</p>
<div>
<pre><span>var</span><span>div1</span> =<span>$</span>(<span>"#div1"</span>);</pre>
<div></div>
<pre><span>// ここで</span></pre>
<pre><span>div1</span>.<span>xxx</span>(<span>"xx"</span>);</pre>
<div></div>
<pre><span>// また別の場所で、</span></pre>
<pre><span>div1</span>.<span>yyy</span>(<span>"yy"</span>);</pre>
<div></div>
<pre><span>// これまた別の場所で、</span></pre>
<pre><span>div1</span>.<span>zzz</span>(<span>"zz"</span>);</pre></div>
<p>この時、人によっては、変数名を$から書く人もいます。これは、その変数が、jQueryオブジェクトを格納していると一目で分かるようにするためです。</p>
<div>
<pre><span>var</span><span>$div1</span> =<span>$</span>(<span>"#div1"</span>);</pre></div>
<p>他の人のプログラム見た時に、戸惑わないようにしておきましょう。</p>


</div>
<div id="calibre_link-284">
<h1 id="calibre_link-363">3章　属性、CSS操作</h1>
<p>この章で登場するメソッド一覧です。</p>


<ul>
	<li><a href="#calibre_link-94">.attr()</a></li>
	<li><a href="#calibre_link-95">.removeAttr()</a></li>

	<li><a href="#calibre_link-97">.addClass()</a></li>
	<li><a href="#calibre_link-98">.removeClass()</a></li>
	<li><a href="#calibre_link-99">.toggleClass()</a></li>
	<li><a href="#calibre_link-100">.hasClass()</a></li>

	<li><a href="#calibre_link-102">.css()</a></li>

	<li><a href="#calibre_link-104">.width()</a></li>
	<li><a href="#calibre_link-105">.height()</a></li>
	<li><a href="#calibre_link-106">innerWidth()、.innerHeight()</a></li>
	<li><a href="#calibre_link-107">outerWidth()、.outerHeight()</a></li>

	<li><a href="#calibre_link-109">.scrollTop()</a></li>
	<li><a href="#calibre_link-110">.scrollLeft()</a></li>

	<li><a href="#calibre_link-3">.offset()</a></li>
	<li><a href="#calibre_link-4">.position()</a></li>
</ul>


</div>
<div id="calibre_link-296">
<h2 id="calibre_link-93">属性、CSS操作</h2>
<p>属性とは、そのタグの中に書かれている部分で、例えば、&lt;a href="xxx" target="<i><i>blank"&gt; の場合、href="xxx" とtarget="</i></i>blank" が該当します。hrefやtargetが名前（キー）で、xxxや _blankが値です。まずは属性を設定・取得・削除する構文を見ていきます。</p>

  
<ul>
	<li><a href="#calibre_link-94">.attr()</a></li>
	<li><a href="#calibre_link-95">.removeAttr()</a></li>
</ul>
<h3 id="calibre_link-94"><b>.attr()</b></h3>
<p>jQueryでは、.attr()というメソッドを使って、属性を設定又は取得します。.attr()には、4つの構文があります。 他のメソッドと同じく、引数の数や引数のタイプによって、これらの構文を区別します。</p>
<h4><b>.attr(name)</b></h4>
<p>マッチした要素の内の1番最初の要素の属性の値を<strong><b>取得</b></strong>します。</p>
<div>
<pre><span>&lt;a</span><span>href</span>=<span>"http://www.yahoo.co.jp/"</span><span>id</span>=<span>"mylink"</span><span>&gt;</span>Yahoo<span>&lt;/a&gt;</span></pre>
<pre><span>&lt;a</span><span>href</span>=<span>"http://www.google.co.jp/"</span><span>&gt;</span>Google<span>&lt;/a&gt;</span></pre></div>
<div>
<pre><span>var</span><span>url</span> =<span>$</span>(<span>"#mylink"</span>).<span>attr</span>(<span>"href"</span>);</pre>
<pre><span>// これで、urlには "http://www.yahoo.co.jp/" と格納されます。</span></pre>
<div></div>
<pre><span>var</span><span>url</span> =<span>$</span>(<span>"a"</span>).<span>attr</span>(<span>"href"</span>);</pre>
<pre><span>// こちらも同上</span></pre></div>
<p>1つ目は、IDで指定していますので、マッチ（選択）される要素は、1つのはずです。その要素のhref属性の値を返します（取得します）。（ここではYahooのURL）<br />
    2つ目は、クラス名で指定していますので、複数の要素がマッチする可能性はありますが、たとえ複数マッチしても、マッチした要素の最初の要素のhref属性の値を返します。（つまり、こちらもYahooのURL）<br />
  （1つの要素にもマッチしない場合やマッチした要素に該当の属性名が無い場合は、undefinedが返ります）</p>
<p>また、HTML5では、頭にdata-を付けることによりカスタム属性を使うことができますが、それも取得することができます。<br />
  例えば、以下になります。</p>
<div>
<pre><span>&lt;span</span><span>id</span>=<span>"taro"</span><span>data-myid</span>=<span>"101"</span><span>&gt;</span>太郎<span>&lt;/span&gt;</span></pre></div>
<div>
<pre><span>var</span><span>id</span> =<span>$</span>(<span>"#taro"</span>).<span>attr</span>(<span>"data-myid"</span>);</pre>
<pre><span>// idは、"101"が格納される</span></pre></div>


<h4><b>.attr(name, value)</b></h4>
<p>属性名（name）に値（value）を<strong><b>設定</b></strong>します。</p>
<div>
<pre><span>&lt;img</span><span>id</span>=<span>"myphoto"</span><span>src</span>=<span>"skytree.jpg"</span><span>/&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>'#myphoto'</span>).<span>attr</span>(<span>'alt'</span>,<span>'スカイツリー'</span>);</pre></div>
<p>これで、img要素（#myphoto）にalt「スカイツリー」を付与しています。<br />
また、img要素であれば、src属性を変更して、画像を切り替えることもできます。</p>
<div>
<pre><span>$</span>(<span>'#myphoto'</span>).<span>attr</span>(<span>'src'</span>,<span>'skytree2.jpg'</span>);</pre></div>


<h4><b>.attr(map)</b></h4>
<p>{name: value, name: value} のオブジェクト形式で、複数同時に属性を<strong><b>設定</b></strong>することもできます。</p>
<div>
<pre><span>$</span>(<span>'#myphoto'</span>).<span>attr</span>({<span>alt</span>:<span>'スカイツリー'</span>,<span>title</span>:<span>'東京の新名所'</span>});</pre></div>


<h4><b>.attr(name, function (index, attr))<span><b>中級</b></span></b></h4>
<p>マッチした要素の全てに第2引数で指定する関数を実行し、その関数から返された値を属性値に<strong><b>設定</b></strong>します。</p>
<p>関数には引数が2つ渡され、1つ目は、マッチした要素のインデックス番号（0スタート）で、2つ目は、マッチした要素の変更前の属性値です。関数内のthisは、処理中の要素を指します。具体例を見てみましょう。</p>
<div>
<pre><span>&lt;img</span><span>src</span>=<span>"taro.gif"</span><span>alt</span>=<span>"太郎"</span><span>title</span>=<span>"15歳"</span><span>/&gt;</span></pre>
<pre><span>&lt;img</span><span>src</span>=<span>"jiro.gif"</span><span>alt</span>=<span>"次郎"</span><span>title</span>=<span>"10歳"</span><span>/&gt;</span></pre>
<pre><span>&lt;img</span><span>src</span>=<span>"saburo.gif"</span><span>alt</span>=<span>"三郎"</span><span>title</span>=<span>"8歳"</span><span>/&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>'img'</span>).<span>attr</span>(<span>"title"</span>,<span>function</span> (<span>index</span>,<span>attr</span>) {</pre>
<pre><span>return</span><span>"["</span> +<span>index</span> +<span>"]"</span> +<span>attr</span> +<span>this</span>.<span>alt</span>;</pre>
<pre>});</pre></div>
<p>上記を実行すると、img要素は次のように書き換えられます。
title属性が書き換えられている所に注目して下さい。</p>
<div>
<pre><span>&lt;img</span><span>src</span>=<span>"taro.gif"</span><span>alt</span>=<span>"太郎"</span><span>title</span>=<span>"[0]15歳太郎"</span><span>/&gt;</span></pre>
<pre><span>&lt;img</span><span>src</span>=<span>"jiro.gif"</span><span>alt</span>=<span>"次郎"</span><span>title</span>=<span>"[1]10歳次郎"</span><span>/&gt;</span></pre>
<pre><span>&lt;img</span><span>src</span>=<span>"saburo.gif"</span><span>alt</span>=<span>"三郎"</span><span>title</span>=<span>"[2]8歳三郎"</span><span>/&gt;</span></pre></div>
<p>また、もし関数が何も返さない場合やundefinedを返した場合は、その要素の属性値は変更されません。</p>
<p>実は、属性やCSSを設定するjQueryのメソッドのほぼ全てで、上記のような関数を指定する形で設定を行うことができますが、本書は入門者対象ということもあり、以後、この形は省略していきます。</p>
<h3 id="calibre_link-95"><b>.removeAttr(name)</b></h3>
<p>指定した属性を削除します。</p>
<div>
<pre><span>// title属性を削除します。</span></pre>
<pre><span>$</span>(<span>'img'</span>).<span>removeAttr</span>(<span>"title"</span>);</pre></div>


</div>
<div id="calibre_link-348">
<h2 id="calibre_link-96">クラス操作</h2>
<p>先程見た.attr()を使ってクラス属性を操作することも可能ではありますが、特にクラスは、1つの要素にスペース区切りで複数割り当てられます。そうすると、とあるクラスだけ足したり消したりするのを.attr() で操作するのは、なかなか大変なことです。1つ足そうと思ったら、既に存在するクラスを上書きして消してしまいかねません。そこで以下のクラス操作専用のメソッドが用意されています。</p>


<ul>
	<li><a href="#calibre_link-97">.addClass()</a></li>
	<li><a href="#calibre_link-98">.removeClass()</a></li>
	<li><a href="#calibre_link-99">.toggleClass()</a></li>
	<li><a href="#calibre_link-100">.hasClass()</a></li>
</ul>
<h3 id="calibre_link-97"><b>.addClass(name)</b></h3>
<p>指定されたクラス名をマッチした要素全てに付け足します。半角スペースで繋いで、複数のクラス名を指定することもできます。 例えば、</p>
<div>
<pre><span>&lt;style</span><span>type</span>=<span>"text/css"</span><span>&gt;</span></pre>
<pre><span>.woman</span> {</pre>
<pre><span>background-color</span><span>:</span><span>pink</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"hanako"</span><span>&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#hanako"</span>).<span>addClass</span>(<span>"woman"</span>);</pre></div>
<p>このようにすると、次の結果になります。</p>
<p><img src="images/000040.gif" /></p>
<h3 id="calibre_link-98"><b>.removeClass([name])</b></h3>
<p>指定されたクラス名をマッチした要素全てから削除します。クラス名を省略した場合は、全てのクラスが削除されます。</p>
<div>
<pre><span>$</span>(<span>"#hanako"</span>).<span>removeClass</span>(<span>"woman"</span>);</pre></div>


<h3 id="calibre_link-99"><b>.toggleClass()</b></h3>
<p>以下、.toggleClass()の2つの形式を見ていきます。</p>


<h4><b>.toggleClass(name)</b></h4>
<p>既に該当のクラス名があれば削除し、無ければ追加します。マッチした全ての要素に対して個々に行われます。<br />
以下の例は、クリックする度ごとに太字になったり、元に戻ったりします。（イベントについては、後の章で詳しく見ます）</p>
<div>
<pre><span>&lt;style</span><span>type</span>=<span>"text/css"</span><span>&gt;</span></pre>
<pre><span>.boldme</span> {</pre>
<pre><span>font-weight</span><span>:</span><span>bold</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;span</span><span>id</span>=<span>"clickme"</span><span>&gt;</span>【ここをクリックしてみて！】<span>&lt;/span&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#clickme"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// ↓クリックする度に、ここの処理が呼ばれます</span></pre>
<pre><span>$</span>(<span>"#clickme"</span>).<span>toggleClass</span>(<span>"boldme"</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/css_toggleClass.php">実際のサンプル</a></p>
<p>クラス名は、半角スペースで区切って複数指定することもできます。</p>
<h4><b>.toggleClass(name, switch)</b></h4>
<p>switchが、true, falseのどちらに評価されるかにより、クラス名を追加するか又は削除するかを決定します。<br />
  （trueの場合は追加、falseの場合は削除）<br /></p>
<h3 id="calibre_link-100"><b>.hasClass(name)</b></h3>
<p>マッチした要素が指定したクラス名を持っている場合は、true、そうでない場合は、falseを返します。<br />
例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"hanako"</span><span>class</span>=<span>"woman"</span><span>&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>// retには、trueが格納されます</span></pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"#hanako"</span>).<span>hasClass</span>(<span>"woman"</span>);</pre></div>
<p>もし複数の要素がマッチする場合は、その複数の要素の中から1つでも一致するクラスを持つ要素があれば、trueになります。</p>
</div>
<div id="calibre_link-323">
<h2 id="calibre_link-101">CSS操作</h2>
<p>先程見たクラス操作関数を使ってスタイルを変更することはできます。デザイナと連携が密にできる場合は、その方がいいでしょう。 ただ、個別の要素にインライン方式でCSSを設定することもできます。それが、こちらの.css()になります。 また、既に適用されているCSSの値を取得することもできます。</p>
<h3 id="calibre_link-102"><b>.css()</b></h3>
<h4><b>.css(name)</b></h4>
<p>マッチした要素の最初の要素から指定したCSSの値を文字列で取得します。
  値は計算済みの値が取得されます。<br />
具体例を見てみましょう。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre><span>#outside</span> {</pre>
<pre><span>font-size</span><span>:</span><span>10px</span>;</pre>
<pre>}</pre>
<pre><span>#inside</span> {</pre>
<pre><span>font-size</span><span>:</span><span>2em</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"outside"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inside"</span><span>&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>ret1</span> =<span>$</span>(<span>"#outside"</span>).<span>css</span>(<span>"font-size"</span>);</pre>
<pre><span>var</span><span>ret2</span> =<span>$</span>(<span>"#inside"</span>).<span>css</span>(<span>"font-size"</span>);</pre>
<pre><span>var</span><span>ret3</span> =<span>$</span>(<span>"#outside"</span>).<span>css</span>(<span>"width"</span>);<span>// おまけ</span></pre>
<div></div>
<pre><span>// 値を出力します。（Firebugなどで動作します）</span></pre>
<pre><span>console</span>.<span>log</span>(<span>ret1</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret2</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret3</span>);</pre></div>
<p>このようにすると、次の結果になります。</p>
<p><img src="images/000049.gif" /></p>
<p>ret1は、ある意味そのままの10pxが取得されています。一方、ret2は、どうでしょうか？CSSで定義済みの2emではなく、20pxが取得されています。これは、2emのような（あまり役に立たない）データではなく、2emを現在の要素に適用した後の計算済みのデータが返ってきます。ret3のwidthは、どうでしょうか？#outsideには、特にwidthの指定はしていませんが、ブラウザで計算済みの値が返ってきました。ここでは、1134pxとなっていますが、ブラウザの横幅を変えればこの値も変わってきます。</p>
<p>なお、単位（px）付きでデータが取得されていることにも留意しておいて下さい。
後に見る<a href="#calibre_link-104">.width()</a>や<a href="#calibre_link-105">.height()</a>では、単位が付きません。</p>
<h4><b>.css(name, value)</b></h4>
<p>CSS名（name）に値（value）を設定します。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"zansho"</span><span>&gt;</span>残暑が厳しいざんしょ。<span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>'#zansho'</span>).<span>css</span>(<span>'background-color'</span>,<span>'pink'</span>);</pre></div>
<p>次の結果になります。</p>
<p><img src="images/000028.gif" /></p>
<p>本来ブラウザごとに異なるopacityの設定も、opacityに0.0～1.0（1.0が全部表示）の値を設定するだけで済みます。（-moz-opacityやfilter: alphaは、不要）</p>
<p>また、Ver. 1.6より、相対値を指定することもできます。以下で、現在のpadding-leftの値に、更に15プラスします。</p>
<div>
<pre><span>$</span>(<span>'#name'</span>).<span>css</span>(<span>"padding-left"</span>,<span>"+=15"</span>);</pre></div>


<h4><b>.css(map)</b></h4>
<p>attr(map)の場合と同じく、まとめて設定することができます。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"night"</span><span>&gt;</span>今宵も暑い夏の夜<span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>'#night'</span>).<span>css</span>({</pre>
<pre><span>'background-color'</span>:<span>'pink'</span>,</pre>
<pre><span>'font-weight'</span>:<span>'bold'</span>,</pre>
<pre><span>color</span>:<span>'blue'</span></pre>
<pre>});</pre></div>
<p>次の結果になります。</p>
<p><img src="images/000016.gif" /></p>
<p>'background-color'のようにCSSの名前にハイフンがあるため、''で括っていますが、camel caseと呼ばれる形式で書けば、''を省略できます。ハイフン（-）を取って、その後のワードを大文字にします。 上記を書き換えると、次のようになります。</p>
<div>
<pre><span>$</span>(<span>'#night'</span>).<span>css</span>({</pre>
<pre><span>backgroundColor</span>:<span>'pink'</span>,</pre>
<pre><span>fontWeight</span>:<span>'bold'</span>,</pre>
<pre><span>color</span>:<span>'blue'</span></pre>
<pre>});</pre></div>
<p>どちらの記述でも大丈夫です。</p>
</div>
<div id="calibre_link-333">
<h2 id="calibre_link-103">幅、高さ操作</h2>
<p>直前で見た<a href="#calibre_link-102">.css()</a>を使っても幅や高さを取得することは可能ですが、より便利な.width()と.height()が用意されています。</p>


<ul>
	<li><a href="#calibre_link-104">.width()</a></li>
	<li><a href="#calibre_link-105">.height()</a></li>
	<li><a href="#calibre_link-106">innerWidth()、.innerHeight()</a></li>
	<li><a href="#calibre_link-107">outerWidth()、.innerHeight()</a></li>
</ul>
<h3 id="calibre_link-104"><b>.width()</b></h3>
<h4><b>.width()</b></h4>
<p>マッチした要素の最初の要素の幅を整数値（単位はpx）で取得します。値は計算済みの値が取得されますので、例えば、50%などが要素に指定されていた場合は、それをpx単位で計算した値が返されます。<br />
  .css("width")との違いは、.css("width")は、単位付きの文字列を返すのに対し、.width()は、単位を除いた整数値で返します。その為、計算ですぐに使うことができます。<br />
具体例を見てみましょう。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre><span>#outside</span> {</pre>
<pre><span>width</span><span>:</span><span>100px</span>;</pre>
<pre>}</pre>
<pre><span>#inside</span> {</pre>
<pre><span>width</span><span>:</span><span>50%</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"outside"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inside"</span><span>&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"alone"</span><span>&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>ret1</span> =<span>$</span>(<span>"#outside"</span>).<span>width</span>();</pre>
<pre><span>var</span><span>ret2</span> =<span>$</span>(<span>"#inside"</span>).<span>width</span>();</pre>
<pre><span>var</span><span>ret3</span> =<span>$</span>(<span>"#alone"</span>).<span>width</span>();</pre>
<div></div>
<pre><span>// 値を出力します。（Firebugなどで動作します）</span></pre>
<pre><span>console</span>.<span>log</span>(<span>ret1</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret2</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret3</span>);</pre></div>
<p>このようにすると、次の結果になります。</p>
<p><img src="images/000060.gif" /></p>
<p>ret3は、特にCSSでは幅を指定していませんが、その都度計算された値を返しています。（ここではたまたま、1115になっています）<br /></p>
<p>width()は、CSS3 box-sizingの値に関わらず、content width（paddingよりも更に内側の表示領域）の値を返します。 また、次のような使い方もできます。</p>
<div>
<pre><span>$</span>(<span>window</span>).<span>width</span>();<span>// ブラウザの横幅</span></pre>
<pre><span>$</span>(<span>document</span>).<span>width</span>();<span>// HTMLドキュメントの横幅</span></pre>
<div></div>
<pre><span>$</span>(<span>window</span>).<span>height</span>();<span>// ブラウザの高さ</span></pre></div>
<p>横にスクロールバーが出る状態の時は、HTMLドキュメントの方が、ブラウザの横幅よりも大きくなりますね。</p>
<p>なお、Ver.3.0未満では、必ず値を整数で返していましたが、Ver.3.0からは状況によっては小数点で返してくる事もあります。この点においては、下記の.height()や.css("width")、.css("height") も同様になります。</p>



<h4><b>.width(value)</b></h4>
<p>幅をvalueに設定します。valueを150などのように単位を省略した場合は、pxが自動で設定されます。'50%'などのように単位付きの文字列で指定することもできます。<br />
例）</p>
<div>
<pre><span>$</span>(<span>"#outside"</span>).<span>width</span>(<span>500</span>);</pre></div>
<p>少し込み入った話ですが、モダンブラウザでは、CSSのwidthは、デフォルトでは、padding、border、marginを含みません（content-box） 。しかし、CSS3の{box-sizing: border-box;}とすることで、paddingとborderを含むようにすることができます。jQueryでは、{box-sizing: border-box;}の時は、content widthの幅ではなく、outerWidthの幅を設定（変更）します。</p>
<h3 id="calibre_link-105"><b>.height()</b></h3>
<p>width()の縦バージョンです。<a href="#calibre_link-104">width()</a>を参照して下さい。</p>
<h3 id="calibre_link-106"><b>.innerWidth()、.innerHeight()</b></h3>
<p>上記の .width()は、borderやpadding幅も含まないのに対して、.innerWidth()は、paddingの幅は含みます。（borderは含みません）<br />
.innerHeight()も同様です。</p>
<h3 id="calibre_link-107"><b>.outerWidth()、.outerHeight()</b></h3>
<h4><b>.outerWidth([includeMargin])、.outerHeight([includeMargin])</b></h4>
<p>もし引数が省略されているかfalseの場合は、borderとpadding幅も含んだ横幅を返します。引数にtrueを指定した場合は、更にmargin幅も含みます。<br />
.outerHeight()も同様です。</p>
</div>
<div id="calibre_link-345">
<h2 id="calibre_link-108">スクロール操作</h2>
<h3 id="calibre_link-109"><b>.scrollTop()</b></h3>
<h4><b>.scrollTop()</b></h4>
<p>マッチした最初の要素のスクロールバーの縦位置（整数値）を取得します。スクロールバーが表示されない状態の時は、0になります。ブラウザの一番右にあるバーだけがスクロールバーとは限らず、例えばDIV要素でoverflowした場合でも、スクロールバーが出ることはあります。</p>
<div>
<pre><span>// スクロールバーの位置を取得します。</span></pre>
<pre><span>var</span><span>top</span> =<span>$</span>(<span>window</span>).<span>scrollTop</span>();</pre>
<pre><span>var</span><span>top</span> =<span>$</span>(<span>"#info_box"</span>).<span>scrollTop</span>();</pre></div>


<h4><b>.scrollTop(value)</b></h4>
<p>マッチした要素全てに対し、valueで指定した値にスクロールバーの縦位置を移動します。</p>
<div>
<pre><span>// スクロールバーの位置を指定します。</span></pre>
<pre><span>$</span>(<span>window</span>).<span>scrollTop</span>(<span>50</span>);</pre></div>


<h3 id="calibre_link-110"><b>.scrollLeft()</b></h3>
<p>マッチした要素の最初の要素のスクロールバーの横（水平）位置を取得します。（左側から起算） 他は、.scrollTop()と同様です。</p>
</div>
<div id="calibre_link-2">
<h2 id="calibre_link-111">座標位置</h2>
<p>.offset()と.position()を見てみます。.offset()は、簡単です。.position()は、少し曲者です。しかし、この2つのメソッド、日本人の私が言うのも何ですが、直感的にはメソッド名を逆にした方が良かったでしょう...。</p>


<ul>
	<li><a href="#calibre_link-3">.offset()</a></li>
	<li><a href="#calibre_link-4">.position()</a></li>
</ul>
<h3 id="calibre_link-3"><b>.offset()</b></h3>
<h4><b>.offset()</b></h4>
<p>マッチした要素の最初の要素の<strong><b>HTMLドキュメントに対する相対位置</b></strong>を返します。leftとtopをプロパティに持つオブジェクト形式で返ります。</p>
<p>（ドキュメント上での左上からの位置であり、ブラウザウインドウ（viewport）の左上からの位置とは区別しておきましょう。 つまり縦長のサイトで、ずーと下にスクロールしてようやく出てきた要素は、その分の高さがtopに加わっています）</p>
<p>次のサンプルでご確認下さい。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre>* {</pre>
<pre><span>margin</span><span>:</span><span>0</span>;</pre>
<pre><span>border</span><span>:</span><span>0</span>;</pre>
<pre><span>padding</span><span>:</span><span>0</span>;</pre>
<pre>}</pre>
<pre><span>#outside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>beige</span>;</pre>
<pre><span>margin</span><span>:</span><span>50px</span>;</pre>
<pre><span>padding</span><span>:</span><span>20px</span>;</pre>
<pre>}</pre>
<pre><span>#inside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>gold</span>;</pre>
<pre><span>margin</span><span>:</span><span>10px</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"outside"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inside"</span><span>&gt;</span></pre>
<pre> あ</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>HTMLイメージ<br /><img src="images/000069.gif" /></p>
<div>
<pre><span>var</span><span>xy</span>;</pre>
<pre><span>xy</span> =<span>$</span>(<span>"#outside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre>
<div></div>
<pre><span>xy</span> =<span>$</span>(<span>"#inside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/css_offset.php">実際のサンプル</a></p>
<p>Firebugなどで確認すると、次の結果になります。</p>
<p><img src="images/000072.gif" /></p>
<p>上記の場合、xy.top、xy.leftなどとして、値を取り出せます。</p>
<h4><b>.offset(coordinates)</b></h4>
<p>下で出てくるposition()と異なり、.offset()は位置の設定に使うこともできます。topとleftをプロパティに持つオブジェクトを引数に指定します。</p>
<div>
<pre><span>$</span>(<span>"#outside"</span>).<span>offset</span>({<span>top</span>:<span>100</span>,<span>left</span>:<span>200</span>});</pre></div>
<p>もし指定した要素のCSSのpositionの値がstaticの場合は、座標位置を変更するために、relativeに変更されます。</p>
<h3 id="calibre_link-4"><b>.position()<span><b>やや中級</b></span></b></h3>
<p>CSSのposition系の知識を必要とするため、やや中級者向けかも知れません。 .offset()が、HTMLドキュメントからの相対位置を返すのに対し、.position()は、<strong><b>offset parentからの相対位置</b></strong>を返します。offset parentと聞きなれない言葉が出てきましたが、これは、jQueryでは、CSSのpositionでstatic以外（＝relative, absolute, fixed）に設定されている直近の先祖要素を指します。もし、relativeなどを一切使っていなければ、HTMLドキュメントからの相対位置を返すため、.offset()と同じか又は似たような値になります。（offset()とは、マージンの扱いに違いあり）</p>
<p>この.position()では、時折「親要素からの相対位置」という解説を見かけますが、これでは説明不足で、誤解を招きます。更にメソッド名が紛らわしいせいか、.offset()と取り違えて覚えている方もいます。</p>
<p>具定例を見てみましょう。.offset()の例もついでに見てみます。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre>* {</pre>
<pre><span>margin</span><span>:</span><span>0</span>;</pre>
<pre><span>border</span><span>:</span><span>0</span>;</pre>
<pre><span>padding</span><span>:</span><span>0</span>;</pre>
<pre>}</pre>
<pre><span>#outside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>beige</span>;</pre>
<pre><span>position</span><span>:</span><span>absolute</span>;</pre>
<pre><span>top</span><span>:</span><span>100px</span>;</pre>
<pre><span>left</span><span>:</span><span>100px</span>;</pre>
<pre><span>width</span><span>:</span><span>100px</span>;</pre>
<pre><span>height</span><span>:</span><span>100px</span>;</pre>
<pre>}</pre>
<pre><span>#inside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>gold</span>;</pre>
<pre><span>position</span><span>:</span><span>relative</span>;</pre>
<pre><span>top</span><span>:</span><span>30px</span>;</pre>
<pre><span>left</span><span>:</span><span>30px</span>;</pre>
<pre><span>width</span><span>:</span><span>30px</span>;</pre>
<pre><span>height</span><span>:</span><span>30px</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"outside"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inside"</span><span>&gt;</span></pre>
<pre> か</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>HTMLイメージ<br /><img src="images/000038.gif" /></p>
<div>
<pre><span>var</span><span>xy</span>;</pre>
<pre><span>xy</span> =<span>$</span>(<span>"#outside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>)</pre>
<div></div>
<pre><span>xy</span> =<span>$</span>(<span>"#outside"</span>).<span>position</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>)</pre>
<div></div>
<pre><span>xy</span> =<span>$</span>(<span>"#inside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>)</pre>
<div></div>
<pre><span>xy</span> =<span>$</span>(<span>"#inside"</span>).<span>position</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>)</pre></div>
<p><a href="http://jquery-master.net/examples/css_position1.php">実際のサンプル</a></p>
<p>Firebugなどのコンソール画面で確認すると、次の結果になります。</p>
<p><img src="images/000050.gif" /></p>
<p>CSSで親要素をposition: absolute;にして子要素をposition: relative;にすると、子要素は、親要素からの相対位置で配置されます。 最初の2つは同じ結果になっています。3つ目は、100pxと30pxが足されて、130pxになっています。そして一番のポイントは、一番最後の.position()です。insideのoffset parentは、outsideなので、outsideからの相対位置が取得されます。</p>
<p>もしまだ余裕のある方は、もう一例見てみましょう。入門者の方は、飛ばして下さい。.offset()と.position()のマージンの取り扱いの違いを見てみます。HTMLとCSSは、.offset()で使ったものと同じです。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre>* {</pre>
<pre><span>margin</span><span>:</span><span>0</span>;</pre>
<pre><span>border</span><span>:</span><span>0</span>;</pre>
<pre><span>padding</span><span>:</span><span>0</span>;</pre>
<pre>}</pre>
<pre><span>#outside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>beige</span>;</pre>
<pre><span>margin</span><span>:</span><span>50px</span>;</pre>
<pre><span>padding</span><span>:</span><span>20px</span>;</pre>
<pre>}</pre>
<pre><span>#inside</span> {</pre>
<pre><span>background-color</span><span>:</span><span>gold</span>;</pre>
<pre><span>margin</span><span>:</span><span>10px</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"outside"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inside"</span><span>&gt;</span></pre>
<pre> あ</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>xy</span>;</pre>
<pre><span>xy</span> =<span>$</span>(<span>"#outside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre>
<pre></pre>
<pre><span>xy</span> =<span>$</span>(<span>"#outside"</span>).<span>position</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre>
<pre></pre>
<pre><span>xy</span> =<span>$</span>(<span>"#inside"</span>).<span>offset</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre>
<pre></pre>
<pre><span>xy</span> =<span>$</span>(<span>"#inside"</span>).<span>position</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>xy</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/css_position2.php">実際のサンプル</a></p>
<p>Firebugなどのコンソール画面で確認すると、次の結果になります。</p>
<p><img src="images/000067.gif" /></p>
<p>今度は、position: relative;などを使っていないため、.offset()と.position()は、同じ結果になると思いたいところでしたが、違う結果になりました。 よくよく見てみると、マージン分に差があります。つまり、.offset()の場合は、マージンを含まない箇所を基点として計算しているの対し、.position()の場合は、マージンを含めた箇所を基点として計算しています。（マージンを含む・含まないは、その要素から見て、です）</p>
<p><img src="images/000017.gif" /></p>


</div>
<div id="calibre_link-282">
<h1 id="calibre_link-364">4章　HTML、テキスト、フォーム値の取得＆設定</h1>
<p>この章で登場するメソッド一覧です。</p>


<ul>
	<li><a href="#calibre_link-114">.html()、.text()</a></li>
	<li><a href="#calibre_link-7">.val()</a></li>
	
	<li><a href="#calibre_link-116">.append()、.prepend()、.before()、.after()</a></li>
	<li><a href="#calibre_link-117">.appendTo()、.prependTo()、.insertBefore()、.insertAfter()</a></li>

	<li><a href="#calibre_link-119">.wrap()</a></li>
	<li><a href="#calibre_link-120">.wrapAll()</a></li>
	<li><a href="#calibre_link-121">.wrapInner()</a></li>
	<li><a href="#calibre_link-122">.unwrap()</a></li>
	<li><a href="#calibre_link-123">.replaceWith()</a></li>
	<li><a href="#calibre_link-124">.replaceAll()</a></li>

	<li><a href="#calibre_link-126">.remove()</a></li>
	<li><a href="#calibre_link-127">.empty()</a></li>
	<li><a href="#calibre_link-128">.clone()</a></li>
</ul>
</div>
<div id="calibre_link-293">
<h2 id="calibre_link-113">HTML、テキスト、フォーム値の取得＆設定</h2>
<p>ここではHTML、テキスト、フォーム値の取得＆設定について見て行きます。</p>
<ul>
	<li><a href="#calibre_link-114">.html()、.text()</a></li>
	<li><a href="#calibre_link-7">.val()</a></li>
</ul>
<h3 id="calibre_link-114"><b>.html()、.text()</b></h3>
<p>.html()と.text()は、HTMLやテキストを取得／設定する際に利用します。似ているので、まとめて見てしまいましょう。 共に引数の数が0個の時は取得し、1つの時は設定します。</p>
<h4><b>.html()、.text()</b></h4>
<p>まずは、取得の場合を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;&lt;span&gt;</span>太郎<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;&lt;span&gt;</span>次郎<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;&lt;span&gt;</span>花子<span>&lt;/span&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>ret1</span> =<span>$</span>(<span>"li"</span>).<span>html</span>();</pre>
<pre><span>var</span><span>ret2</span> =<span>$</span>(<span>"li"</span>).<span>text</span>();</pre>
<pre><span>alert</span>(<span>ret1</span>);</pre>
<pre><span>alert</span>(<span>ret2</span>);</pre></div>
<p>このようにすると、次の表示結果になります。</p>
<p><img src="images/000034.gif" /></p>
<p><img src="images/000006.gif" /></p>
<p>.html()の方は、マッチした要素の内の1番最初の要素のHTMLの中身を取得します。span要素も一緒に取得されているのに注目して下さい。
一方、.text()の方は、マッチした要素全てからテキストだけを抽出し、それらを連結したデータで返します。span要素はカットされています。</p>
<h4><b>.html(html)、.text(text)</b></h4>
<p>次に、設定の場合を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"jiro"</span><span>&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#taro"</span>).<span>html</span>(<span>"&lt;span style='color:red'&gt;のび太&lt;/span&gt;"</span>);</pre>
<pre><span>$</span>(<span>"#jiro"</span>).<span>text</span>(<span>"&lt;span style='color:blue'&gt;スネ夫&lt;/span&gt;"</span>);</pre></div>
<p>このようにすると、次の表示結果になります。</p>
<p><img src="images/000052.gif" /></p>
<p>.html()の方は、HTMLとしてデータが置き換えられているのが分かります。一方、.text()の方は、HTML部分がエスケープされて、タグがそのままの形で表示されるように置き換えられています。 どちらも既存のデータと置き換えられる点にも注目して下さい。</p>
<h3 id="calibre_link-7"><b>.val()</b></h3>
<p>フォーム要素の値を取得又は設定します。設定には、チェックボックスなどを選択状態にする機能もあります。</p>
<h4><b>.val() （取得）</b></h4>
<p>フォーム要素のvalueの値を取得します。1行（又は複数行）の入力ボックスの場合は、その入力ボックスに書かれた内容が取得されます。 セレクトボックス（プルダウン）では、選択されているvalueの値が取得されます。 もし、multiple="multiple"が設定されている場合は、選択されているvalueの値が配列で返されます。</p>
<p>それでは、<strong><b>セレクトボックス（プルダウン）</b></strong>の例で見てみましょう。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;select</span><span>id</span>=<span>"myselect"</span><span>&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>""</span><span>&gt;</span>下から選択して下さい<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"jiro"</span><span>&gt;</span>次郎<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"hanako"</span><span>&gt;</span>花子<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;/select&gt;</span></pre>
<div></div>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"valueを取得"</span><span>id</span>=<span>"get_val"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"textを取得"</span><span>id</span>=<span>"get_text"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>// 選択しているセレクトボックスの値を取得</span></pre>
<pre><span>$</span>(<span>"#get_val"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"#myselect"</span>).<span>val</span>();</pre>
<pre><span>alert</span>(<span>ret</span>);</pre>
<pre>});</pre>
<div></div>
<pre><span>// 選択しているセレクトボックスのテキストを取得（おまけ）</span></pre>
<pre><span>$</span>(<span>"#get_text"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"#myselect option:selected"</span>).<span>text</span>();</pre>
<pre><span>alert</span>(<span>ret</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/manipulation_val.php">実際のサンプル</a></p>
<p>さて、次は、<strong><b>ラジオボタンとチェックボックスですが、こちらは少し厄介です。</b></strong>.val()は、マッチした要素の内の1番最初の要素を対象にします。しかし、ラジオボタンやチェックボックスは、同じ名前のものが複数存在し得ます。その複数個ある内、どれがチェックされるか分かりません。更にそもそも.val()は、ラジオボタンやチェックボックスがチェックされているか<strong><b>否かに関わらず</b></strong>に値を取得します。</p>
<p><strong><b>ラジオボタン</b></strong>は、チェックされるものは1つだけなので、:checkedでデータをフィルタしてやれば、解決できます。 以下のようになります。</p>
<div>
<pre><span>// name="rdo" のラジオボタンのチェックされている値を取得します。</span></pre>
<pre><span>// 何もチェックされていなければ、undefinedが返ります。</span></pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>"input[type=radio][name=rdo]:checked"</span>).<span>val</span>();</pre></div>
<p>厄介なのが、<strong><b>チェックボックス</b></strong>です。複数個チェックされる可能性があります。細かい解説は省略するとして、以下のコードで配列で取得できます。</p>
<div>
<pre><span>// これで選択されているチェックボックスの値が、配列でarr_chkに格納されます。</span></pre>
<pre><span>// セレクター部分は、適宜書き換えて下さい。</span></pre>
<pre><span>var</span><span>arr_chk</span> =<span>$</span>(<span>"input[type=checkbox][name=chk]:checked"</span>).<span>map</span>(</pre>
<pre><span>function</span> () {<span>return</span><span>$</span>(<span>this</span>).<span>val</span>(); }</pre>
<pre>).<span>toArray</span>();</pre></div>
<p><a href="#calibre_link-144">.map()</a>、<a href="#calibre_link-143">.toArray()</a>については、別の章で登場します。</p>



<h4><b>.val(value) （設定）</b></h4>
<p>こちらは、設定です。1行（又は複数行）の入力ボックスの場合は、その入力ボックスにvalueの値が設定されます。これは直感的に分かります。 では、セレクトボックス、ラジオボタン、チェックボックスではどうなるのでしょうか？直感的には、valueの値が書き換えられてしまいそうな気がしますが、そうではなく、valueで指定した値を選択されている状態にします。 具体例で見てみましょう。</p>
<div>
<pre><span>&lt;input</span><span>type</span>=<span>"text"</span><span>id</span>=<span>"name"</span><span>&gt;</span></pre>
<div></div>
<pre><span>&lt;textarea</span><span>id</span>=<span>"naiyo"</span><span>rows</span>=<span>"5"</span><span>&gt;&lt;/textarea&gt;</span></pre>
<div></div>
<pre><span>&lt;select</span><span>id</span>=<span>"select_one"</span><span>&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>""</span><span>&gt;</span>下から選択して下さい<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"aa"</span><span>&gt;</span>ああ<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"bb"</span><span>&gt;</span>いい<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"cc"</span><span>&gt;</span>うう<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;/select&gt;</span></pre>
<div></div>
<pre><span>&lt;select</span><span>id</span>=<span>"select_multi"</span><span>multiple</span>=<span>"multiple"</span><span>&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>""</span><span>&gt;</span>下から選択して下さい<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"xx"</span><span>&gt;</span>かか<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"yy"</span><span>&gt;</span>きき<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;option</span><span>value</span>=<span>"zz"</span><span>&gt;</span>くく<span>&lt;/option&gt;</span></pre>
<pre><span>&lt;/select&gt;</span></pre>
<div></div>
<pre><span>&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"rdo"</span><span>value</span>=<span>"あ"</span><span>&gt;</span>あ</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"rdo"</span><span>value</span>=<span>"い"</span><span>&gt;</span>い</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"rdo"</span><span>value</span>=<span>"う"</span><span>&gt;</span>う</pre>
<div></div>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"chk"</span><span>value</span>=<span>"か"</span><span>&gt;</span>か</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"chk"</span><span>value</span>=<span>"き"</span><span>&gt;</span>き</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"chk"</span><span>value</span>=<span>"く"</span><span>&gt;</span>く</pre></div>
<div>
<pre><span>$</span>(<span>"#name"</span>).<span>val</span>(<span>"太郎です"</span>);</pre>
<pre><span>$</span>(<span>"#naiyo"</span>).<span>val</span>(<span>"内容です"</span>);</pre>
<pre><span>$</span>(<span>"#select_one"</span>).<span>val</span>(<span>"cc"</span>);</pre>
<pre><span>$</span>(<span>"#select_multi"</span>).<span>val</span>([<span>"yy"</span>,<span>"zz"</span>]);</pre>
<pre><span>$</span>(<span>"input[type=radio][name=rdo]"</span>).<span>val</span>([<span>"い"</span>]);</pre>
<pre><span>$</span>(<span>"input[type=checkbox][name=chk]"</span>).<span>val</span>([<span>"か"</span>,<span>"き"</span>]);</pre></div>
<p>次の表示結果になります。</p>
<p><img src="images/000005.gif" /></p>
</div>
<div id="calibre_link-331">
<h2 id="calibre_link-115">要素の追加等</h2>
<p>要素を動的に追加する場合を見ていきましょう。</p>


<ul>
	<li><a href="#calibre_link-116">.append()、.prepend()、.before()、.after()</a></li>
	<li><a href="#calibre_link-117">.appendTo()、.prependTo()、.insertBefore()、.insertAfter()</a></li>
</ul>
<h3 id="calibre_link-116"><b>.append()、.prepend()、.before()、.after()</b></h3>
<p>どれも似ているのでまとめて見てしまいましょう。 これらは、<strong><b>新規に生成した要素を特定の位置に挿入</b></strong>したり、又は<strong><b>既存の要素を特定の位置に移動</b></strong>したりします（通常は、前者を使うことの方が多いでしょう）。</p>
<p>具体例で見てみましょう。 使うメソッドにより挿入先の位置が異なります。まずは、新規に生成した要素を特定の位置に挿入する場合です。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"ul"</span>).<span>prepend</span>(<span>$</span>(<span>"&lt;li&gt;太郎&lt;/li&gt;"</span>));</pre>
<pre><span>$</span>(<span>"ul"</span>).<span>append</span>(<span>$</span>(<span>"&lt;li&gt;花子&lt;/li&gt;"</span>));</pre>
<pre><span>$</span>(<span>"ul"</span>).<span>before</span>(<span>$</span>(<span>"&lt;p&gt;子供の名前&lt;/p&gt;"</span>));</pre>
<pre><span>$</span>(<span>"ul"</span>).<span>after</span>(<span>$</span>(<span>"&lt;p&gt;生年月日&lt;/p&gt;"</span>));</pre></div>
<p>このようにすると、次のHTMLと表示結果になります。<br />
HTML</p>
<div>
<pre><span>&lt;p&gt;</span>子供の名前<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<pre><span>&lt;p&gt;</span>生年月日<span>&lt;/p&gt;</span></pre></div>
<p>表示結果</p>
<p><img src="images/000024.gif" /></p>
<p>それぞれの意味は、<br />
  $(A).prepend(B); →Aでマッチした要素の先頭にBを挿入<br />
  $(A).append(B); →Aでマッチした要素の最後にBを挿入<br />
  $(A).before(B); →Aでマッチした要素の直前にBを挿入<br />
  $(A).after(B); →Aでマッチした要素の直後にBを挿入<br />
という意味になります。</p>
<p>上記の$("&lt;li&gt;太郎&lt;/li&gt;") の使い方は覚えているでしょうか？jQueryの基本で出てきた<a href="#calibre_link-57">$()の使い方の1つ</a>ですが、このように記述することにより、HTMLの要素を生成することができます。その要素をここでは挿入している訳です。</p>
<p>次に移動の場合を見てみましょう。.append()の場合で見てみます。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"ul"</span>).<span>append</span>(<span>$</span>(<span>"#taro"</span>));</pre></div>
<p>次の表示結果になります</p>
<p><img src="images/000004.gif" /></p>
<p>$(A).append(B); で、Bに既に存在する要素を指定した場合、それは「移動」になります。ですので、1番目にあった&lt;li id="taro"&gt;太郎&lt;/li&gt;が3番目に移動しました。</p>
<p>ちなみに、ここで、$("ul"). と書きましたが、もし複数のUL要素がマッチした場合はどうなるでしょうか？その場合は、実はその複数分のUL要素に対して、&lt;li id="taro"&gt;太郎&lt;/li&gt;が挿入（append）されます。そうなるともはや、単に「移動」というより「移動＆分身コピー」という感じになります。</p>
<h3 id="calibre_link-117"><b>.appendTo()、.prependTo()、.insertBefore()、.insertAfter()</b></h3>
<p>.append()、.prepend()、.before()、.after()と同じ目的で使えますが、.append()などとは前後の指定が入れ替わったバージョンです。つまり、<br />
  $(A).append(B);<br />
  と<br />
  $(B).appendTo(A);<br />
は、同じ事になります。その時々で、しっくり来る方を使えば良いでしょう。</p>


</div>
<div id="calibre_link-342">
<h2 id="calibre_link-118">包み込み、置換</h2>
<p>ここではマッチした要素を包み込んだり、置換するケースを見て行きます。</p>


<ul>
	<li><a href="#calibre_link-119">.wrap()</a></li>
	<li><a href="#calibre_link-120">.wrapAll()</a></li>
	<li><a href="#calibre_link-121">.wrapInner()</a></li>
	<li><a href="#calibre_link-122">.unwrap()</a></li>
	<li><a href="#calibre_link-123">.replaceWith()</a></li>
	<li><a href="#calibre_link-124">.replaceAll()</a></li>
</ul>
<h3 id="calibre_link-119"><b>.wrap()</b></h3>
<p>マッチした要素を指定した要素で包み込みます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"span"</span>).<span>wrap</span>(<span>"&lt;div&gt;&lt;/div&gt;"</span>);</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;div&gt;&lt;span&gt;</span>太郎<span>&lt;/span&gt;&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;&lt;span&gt;</span>次郎<span>&lt;/span&gt;&lt;/div&gt;</span></pre></div>
<p>各要素が、指定した要素で包み込まれました。上記の場合は、引数で指定した"&lt;div&gt;&lt;/div&gt;"をその場で生成し、その生成した要素で括っています。</p>
<p>既存の要素を引数で指定することもできます。この場合は、引数で指定した要素のコピーで要素が包み込まれます。<br />
例）</p>
<div>
<pre><span>$</span>(<span>"span"</span>).<span>wrap</span>(<span>".template .mydiv"</span>);</pre></div>


<h3 id="calibre_link-120"><b>.wrapAll()</b></h3>
<p>マッチした要素を一括りで包み込みます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"span"</span>).<span>wrapAll</span>(<span>"&lt;div&gt;&lt;/div&gt;"</span>);</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>もし太郎と次郎の間に他の要素、例えば、&lt;strong&gt;花子&lt;/strong&gt;という要素が入っていた場合は、それらは押し出されます。<br />
（変更前）</p>
<div>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;strong&gt;</span>花子<span>&lt;/strong&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre></div>
<p>（変更後）</p>
<div>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;strong&gt;</span>花子<span>&lt;/strong&gt;</span></pre></div>


<h3 id="calibre_link-121"><b>.wrapInner()</b></h3>
<p>マッチした要素の中身（内側）を指定した要素で包み込みます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"span"</span>).<span>wrapInner</span>(<span>"&lt;strong&gt;&lt;/strong&gt;"</span>);</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;span&gt;&lt;strong&gt;</span>太郎<span>&lt;/strong&gt;&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;&lt;strong&gt;</span>次郎<span>&lt;/strong&gt;&lt;/span&gt;</span></pre></div>


<h3 id="calibre_link-122"><b>.unwrap()</b></h3>
<p>マッチした要素からその親要素を取り除きます。
.wrap()又は.wrapAll()の逆の動作と言えます。</p>
<div>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;div&gt;&lt;span&gt;</span>のび太<span>&lt;/span&gt;&lt;/div&gt;</span></pre>
<pre><span>&lt;div&gt;&lt;span&gt;</span>スネ夫<span>&lt;/span&gt;&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"span"</span>).<span>unwrap</span>();</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;span&gt;</span>太郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>次郎<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>のび太<span>&lt;/span&gt;</span></pre>
<pre><span>&lt;span&gt;</span>スネ夫<span>&lt;/span&gt;</span></pre></div>
<p>.unwrap()の場合は、引数には何も指定しません。しかし、Ver.3.0からは引数にセレクターを指定して、セレクターにマッチする親要素のみを取り除くということができます。</p>
<h3 id="calibre_link-123"><b>.replaceWith()</b></h3>
<p>マッチした要素を指定した要素で置き換えます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"container"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner first"</span><span>&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner second"</span><span>&gt;</span>次郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner third"</span><span>&gt;</span>三郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>'div.second'</span>).<span>replaceWith</span>(<span>'&lt;h2&gt;与太郎&lt;/h2&gt;'</span>);</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"container"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner first"</span><span>&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>与太郎<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner third"</span><span>&gt;</span>三郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>div.second部分が、&lt;h2&gt;与太郎&lt;/h2&gt;で置き換えられたのが分かります。</p>
<p>マッチする要素が複数の場合は、それら全てが置き換えられます。<br />
元のHTMLはそのままとして、次のJSを実行するとします。</p>
<div>
<pre><span>$</span>(<span>'div.inner'</span>).<span>replaceWith</span>(<span>'&lt;h2&gt;与太郎&lt;/h2&gt;'</span>);</pre></div>
<p>すると、次のようなHTMLになります。</p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"container"</span><span>&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>与太郎<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>与太郎<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;h2&gt;</span>与太郎<span>&lt;/h2&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>既存の要素を引数に指定することもできます。その場合は、その要素は「移動」されます。<br />
元のHTMLはそのままとして、次のJSを実行するとします。</p>
<div>
<pre><span>$</span>(<span>'div.third'</span>).<span>replaceWith</span>(<span>$</span>(<span>'.first'</span>));</pre></div>
<p>すると、次のようなHTMLになります。</p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"container"</span><span>&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner second"</span><span>&gt;</span>次郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;div</span><span>class</span>=<span>"inner first"</span><span>&gt;</span>太郎<span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<p>「太郎」が、「三郎」の位置に来て、置き換えられたことが分かります。</p>
<p>ちなみに、ここで置き換えられて追い出された「三郎」は、どこへ行ってしまったのでしょうか？どこか行ってしまいました。 もはやこの三郎を呼び戻すことはできないのでしょうか？実は、.replaceWith()では、追い出された要素をjQueyオブジェクトとして返すため、引き続き何かの操作に使用することもできます。</p>
<div>
<pre><span>var</span><span>saburo</span> =<span>$</span>(<span>'div.third'</span>).<span>replaceWith</span>(<span>$</span>(<span>'.first'</span>));</pre>
<pre><span>alert</span>(<span>saburo</span>.<span>text</span>());<span>// 「三郎」と出力</span></pre></div>


<h3 id="calibre_link-124"><b>.replaceAll()</b></h3>
<p>.append()に前後の順番が入れ替わった.appendTo()があるように、.replaceWith()にも同様にあります。それが、.replaceAll()です。 つまり、<br />
  A.replaceWith(B);<br />
  と<br />
  B.replaceAll(A);<br />
は、同じことになります。</p>
</div>
<div id="calibre_link-356">
<h2 id="calibre_link-125">削除、クローン（コピー）</h2>
<p>要素の削除やクローン（コピー）について見てみましょう。</p>


<ul>
	<li><a href="#calibre_link-126">.remove()</a></li>
	<li><a href="#calibre_link-127">.empty()</a></li>
	<li><a href="#calibre_link-128">.clone()</a></li>
</ul>
<h3 id="calibre_link-126"><b>.remove()</b></h3>
<p>マッチした要素を中身も含めて丸ごと削除します。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>".first"</span>).<span>remove</span>();</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>なお、本家ドキュメントに記載はありませんが、削除しても返されるjQueryオブジェクトは変化しません。
.remove()前と同じjQueryオブジェクトが返されます。</p>
<h3 id="calibre_link-127"><b>.empty()</b></h3>
<p>.remove()と似ていますが、.empty()は、自分自身は削除せずに、自分の中身を全て一掃します。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>".first"</span>).<span>empty</span>();</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>.remove()のように引数を指定することはできません。<br />なお、フィルターの<a href="#calibre_link-85">:empty</a>もあります。</p>
<h3 id="calibre_link-128"><b>.clone()</b></h3>
<p>マッチした要素のクローン（コピー）を作成し、jQueryオブジェクトの形で返します。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>".apple"</span>).<span>clone</span>().<span>appendTo</span>(<span>"ul"</span>);</pre></div>
<p>上記を実行すると、HTMLは以下のようになります。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>4番目に表示された「リンゴ」が、1番目の「リンゴ」のクローンです。</p>
<p>おまけに、この状態でもう一度先の.clone()を実行するとどうなるか分かりますか？
こうなります。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"apple"</span><span>&gt;</span>リンゴ<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<p>1回目で、class="apple"が、2つになったので、2回目では、その2つ分のクローンが作られて、後ろに追加されています。<br /></p>
<p>ところで、.clone()する要素にid属性が指定されていると、クローンにもそのid属性が付き、idが重複するため、.removeAttr("id")などしてクローンからid属性を削除する必要があります。その点、class属性で要素を指定すれば重複自体は問題ありませんが、上記のように複数回呼び出す際は問題となり得るため、必要に応じてクローンから不要なクラスを削除するなりしましょう。（クラスの指定方法を工夫すれば、避けられたりもします）</p>


</div>
<div id="calibre_link-337">
<h1 id="calibre_link-365">5章　横断（Traversing）</h1>
<p>この章で登場するメソッド一覧です。</p>


<ul>
	<li><a href="#calibre_link-131">.first()</a></li>
	<li><a href="#calibre_link-132">.last()</a></li>
	<li><a href="#calibre_link-133">.eq()</a></li>
	<li><a href="#calibre_link-134">.filter()</a></li>
	<li><a href="#calibre_link-135">.not()</a></li>
	<li><a href="#calibre_link-136">.find()</a></li>
	<li><a href="#calibre_link-137">.prev() ～ .siblings()</a></li>
	<li><a href="#calibre_link-138">.end()、.andSelf()（.addBack()）</a></li>
</ul>
</div>
<div id="calibre_link-288">
<h2 id="calibre_link-130">横断（Traversing）</h2>
<p>横断とは、セレクターによって選択した要素を都合により変更したい場合に使用します。あっちこっち行ったりするため、「横断」と呼んでいます。 この横断によって、jQueryに現在選択されている要素は、<strong><b>「変化」</b></strong>します。それは、何かの操作対象が、その変化後の要素になるということです。1つ1つ見て行きましょう。</p>


  
<h3 id="calibre_link-131"><b>.first()</b></h3>
<p>マッチ（選択）した要素の中から、最初の要素だけに対象を絞ります。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>css</span>(<span>"font-weight"</span>,<span>"bold"</span>).<span>first</span>().<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000057.gif" /></p>
<p>.first()の手前まではいつも通りの操作です。LI要素全てを太文字に設定しています。そしてその後に、.first()とあり、ここでマッチした要素が、LI全てではなく、その最初の先頭の要素だけに変更されます。つまりここでは太郎のLIのみが選択された状態になり、続く処理は、それに対して行われます。よって、太郎のみが赤文字になりました。</p>
<p>もし最初から太郎だけが操作対象なら、セレクターの章で見たように、:firstフィルターが使えます。</p>
<div>
<pre><span>$</span>(<span>"li:first"</span>).<span>css</span>(<span>"font-weight"</span>,<span>"bold"</span>).<span>css</span>(<span>"color"</span>,<span>"red"</span>);</pre></div>


<h3 id="calibre_link-132"><b>.last()</b></h3>
<p>先ほどの.first()が、最初の先頭が選択されるのに対し、こちらは最後の要素が選択されます。</p>
<h3 id="calibre_link-133"><b>.eq()</b></h3>
<p>.first()や.last()は、先頭と最後に限定でしたが、.eq(n)の形で、任意の位置を指定することができます。プログラミングらしく、0からスタートします。 先ほどの.first()と同じHTMLを使って見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>eq</span>(<span>0</span>);<span>// 太郎のLI要素が選択される</span></pre>
<pre><span>$</span>(<span>"li"</span>).<span>eq</span>(<span>2</span>);<span>// 三郎のLI要素が選択される</span></pre>
<pre><span>$</span>(<span>"li"</span>).<span>eq</span>(<span>-1</span>);<span>// マイナスを使うと後ろから数える。つまり三郎のLI要素が選択される</span></pre></div>


<h3 id="calibre_link-134"><b>.filter()</b></h3>
<p>.filter(selector) の形で、対象をセレクターで絞り込むことができます。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>filter</span>(<span>".first"</span>);<span>// 太郎のLI要素が選択される</span></pre></div>
<p>上記の例だとフィルターを使っている意味がありませんが、（最初から、$("li.first")と書けば良いため）使い方はお分かりいただけるかと思います。</p>
<h3 id="calibre_link-135"><b>.not()</b></h3>
<p>.not(selector) の形で、selectorにマッチしない要素だけに絞り込むことができます。（.filter()と逆の動作）</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>not</span>(<span>".first"</span>);<span>// 太郎以外（次郎と三郎）のLI要素が選択される</span></pre></div>
<p>selectorの代わりに、要素（1つ又は配列）又はjQueryオブジェクトを渡し、それらにマッチしない要素だけに絞り込むこともできます。<br />また、フィルターの<a href="#calibre_link-80">:not()</a>もあります。</p>
<h3 id="calibre_link-136"><b>.find()</b></h3>
<p>.find(selector) の形で、元のマッチした要素の子孫要素を対象に更にセレクターで絞込み、選択を行います。<br />具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"first"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<div></div>
<pre><span>&lt;!-- こっちは、DIV使用 --&gt;</span></pre>
<pre><span>&lt;div&gt;</span></pre>
<pre><span>&lt;p</span><span>class</span>=<span>"first"</span><span>&gt;</span>いちご<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;p&gt;</span>みかん<span>&lt;/p&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>// 太郎のLI要素が選択される。DIV側は、対象外。</span></pre>
<pre><span>$</span>(<span>"ul"</span>).<span>find</span>(<span>".first"</span>);</pre></div>
<p>最初の先頭が、LIではなく、ULになっています。つまり、ULの子孫要素を対象に、.find()で更に絞込み、選択を行います。 先に見た<a href="#calibre_link-134">.filter()</a>の場合は、元のマッチした要素が対象になりフィルターされますが、.find()は、子孫要素が対象になります。</p>
<p>セレクターの章の「<a href="#calibre_link-65">検索する対象（範囲）を指定する書き方</a>」で見ましたが、$()の第2引数を使い、検索範囲を絞り込めるのを覚えているでしょうか？上記はこのようにも書けます。</p>
<div>
<pre><span>$</span>(<span>".first"</span>,<span>"ul"</span>);</pre></div>
<p>実はこの書き方は、jQueryの内部で.find()を使って実装されています。</p>
<h3 id="calibre_link-137"><b>.prev() ～ .siblings()</b></h3>
<p>階層構造に基づき要素を移動するメソッドをまとめて見てみましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>メソッド</b></th>
<th><b>意味</b></th>
</tr>
<tr>
<td>.prev([selector])</td>
<td>選択（マッチ）した各要素の直前の兄を選択します。引数にselectorを指定することにより、更に兄を絞り込む事ができます。</td>
</tr>
<tr>
<td>.prevAll([selector])</td>
<td>選択した各要素の全ての兄を選択します。引数にselectorを指定することにより、更に兄を絞り込む事ができます。</td>
</tr>
<tr>
<td>.next([selector])</td>
<td>選択した各要素の直後の弟を選択します。引数にselectorを指定することにより、更に弟を絞り込む事ができます。</td>
</tr>
<tr>
<td>.nextAll([selector])</td>
<td>選択した各要素の全ての弟を選択します。引数にselectorを指定することにより、更に弟を絞り込む事ができます。</td>
</tr>
<tr>
<td>.parent([selector])</td>
<td>選択した各要素の<strong><b>（直近の）親要素</b></strong>を選択します。引数にselectorを指定することにより、更に親を絞り込む事ができます。</td>
</tr>
<tr>
<td>.parents([selector])</td>
<td>選択した各要素の<strong><b>（全ての）先祖要素</b></strong>を選択します。引数にselectorを指定することにより、更に先祖を絞り込む事ができます。</td>
</tr>
<tr>
<td>.children([selector])</td>
<td>選択した各要素の<strong><b>（1階層だけ下の）全ての子供</b></strong>を選択します。（孫レベルは選択しません）引数にselectorを指定することにより、更に子供を絞り込む事ができます。<br /><span>反対語と思われる.parents()が先祖を遡るのに対し、こちらは1階層だけしか下に行かないのでご注意下さい。何階層も下に下がるのは、.find(selector)です。</span></td>
</tr>
<tr>
<td>.siblings([selector])</td>
<td>選択した各要素の全ての兄弟を選択。引数にselectorを指定することにより、更に兄弟を絞り込む事ができます。</td>
</tr>
<tr>
<td>.closest(selector)</td>
<td>選択した各要素の、selectorにマッチする最も近い先祖要素を選択します。（但し、自分自身から始まり先祖要素を遡って検索するため、自分自身がマッチする場合もあります）<br /><span>closest（もっとも近い）という英単語自体には、「先祖」という意味が含まれていませんが、先祖を辿ります。（叔父とかは対象外ですね）</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><a href="http://jquery-master.net/examples/traversing_prev.php">確認用のサンプル</a></p>
<p>なお、フィルターの<a href="#calibre_link-85">:parent</a>というのもあります。</p>
<h3 id="calibre_link-138"><b>.end()<br /><b></b>
.addBack() （Ver. 1.8～）（.andSelf()（旧））</b></h3>
<p>要素を横断（移動）した後、再度前の要素に戻りたいことがあります。
  実はjQueryでは、横断する前のjQueryオブジェクトを記憶していて、前の要素（jQueryオブジェクト）に戻ることができるようになっています。
  .end()を使用することで、1つ前の選択状態に戻ることができます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"saburo"</span><span>&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#saburo"</span>).<span>prev</span>().<span>css</span>(<span>"color"</span>,<span>"red"</span>)</pre>
<pre> .<span>prev</span>().<span>css</span>(<span>"color"</span>,<span>"blue"</span>)</pre>
<pre> .<span>end</span>().<span>css</span>(<span>"font-size"</span>,<span>"2em"</span>)</pre>
<pre> .<span>end</span>().<span>css</span>(<span>"font-style"</span>,<span>"italic"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000075.gif" /></p>
<p>1行目 ... 「三郎」から直前の兄の「次郎」に移動し、文字色を赤にしています。<br />
  2行目 ... 更に直前の兄の「太郎」に移動し、文字色を青にしています。<br />
  3行目 ...1歩戻って（「次郎」に戻る）、大きな文字にしています。<br />
4行目 ... また1歩戻って（「三郎」に戻る）、イタリックにしています。</p>
<p>ついでに、.addBack()も見てみましょう。こちらは、直前に選択していた要素を今の要素に付け加えて、新しく要素を選択し直します。 .end()は、1歩前に戻りますが、.addBack()は、更に前進していくイメージです。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"saburo"</span><span>&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#saburo"</span>).<span>prev</span>().<span>css</span>(<span>"color"</span>,<span>"red"</span>)</pre>
<pre> .<span>prev</span>().<span>css</span>(<span>"color"</span>,<span>"blue"</span>)</pre>
<pre> .<span>addBack</span>().<span>css</span>(<span>"font-size"</span>,<span>"2em"</span>)</pre>
<pre> .<span>end</span>().<span>css</span>(<span>"font-style"</span>,<span>"italic"</span>);</pre></div>
<p>この結果は、以下のようになります。</p>
<p><img src="images/000011.gif" /></p>
<p>1行目 ... 「三郎」から直前の兄の「次郎」に移動し、文字色を赤にしています。<br />
  2行目 ... 更に直前の兄の「太郎」に移動し、文字色を青にしています。<br />
  3行目 ... 更に先の「次郎」を加えて、「太郎」と「次郎」を選択し直し、大きな文字にしています。<br />
4行目 ...end()なので、1歩前に戻り、「太郎」をイタリックにしています。</p>
<p>jQueryでは選択している要素を次のようなイメージで管理しています。
  一番上にあるのが、現在選択されている要素を表しています。
.end()以外では、常に選択要素の管理が溜まっていくイメージです。</p>
<p><img src="images/000031.gif" /></p>
<p>なお、このメソッド名は、名前がややこしいという理由で、Ver. 1.8で、.andSelf()から.addBack()に名前が変更されています。まだ暫くは、.andSelf()も使うことはできそうですが、いずれ削除される予定なので、addBack()へ移行しておきましょう。<br />
更に付け加えておきますと、.addBack()の方では、第1引数にセレクターを指定して、選択要素をフィルタリングすることもできます。</p>


</div>
<div id="calibre_link-303">
<h1 id="calibre_link-366">6章　jQueryオブジェクト操作</h1>
<p>この章で登場するメソッドやプロパティ一覧です。</p>


<ul>
	<li><a href="#calibre_link-141">.length</a></li>
	<li><a href="#calibre_link-15">.each()</a></li>
	<li><a href="#calibre_link-142">.get()</a></li>
	<li><a href="#calibre_link-143">.toArray()</a></li>
	<li><a href="#calibre_link-144">.map()</a></li>
	<li><a href="#calibre_link-145">.index()</a></li>
</ul>
</div>
<div id="calibre_link-315">
<h2 id="calibre_link-140">jQueryオブジェクト操作</h2>
<p>jQueryオブジェクトが選択している要素の数を取得したり、生のDOM要素を取り出したい場合を見てみます。必ずしも「jQueryオブジェクト操作」というカテゴリ名とうまくマッチしないものもありますが、予めご了承下さい。</p>




<h3 id="calibre_link-141"><b>.length</b></h3>
<p>現在選択されている（マッチしている）要素の数を返します。.lengthは、プロパティの為、()を付けません。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>// numは、3になります。</span></pre>
<pre><span>var</span><span>num</span> =<span>$</span>(<span>"li"</span>).<span>length</span>;</pre></div>
<p>なお、同じ機能のある.size()メソッドというのもありますが、こちらは近い将来削除予定ですので、使わないようにしましょう。</p>


<h3 id="calibre_link-15"><b>.each(function (index, element))<span><b>中級</b></span></b></h3>
<p>.each()は、マッチした要素全ての1つ1つに対して、引数に指定した関数を実行していきます。
  その関数が受け取る第1引数（index）は、要素のインデックス番号（0からスタート）、第2引数（element）は、処理対象のDOM要素そのものを受け取ります。（関数内でのthisと同じ）</p>
<p>DOM要素そのものということは、jQueryオブジェクトではないので、jQueryのメソッドは使えません。
  もし使いたい場合は、$(element)のようにします。しかし実際のところ、elementとthisは同じなので、$(this)と書く方が一般的です。<br />
具定例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>each</span>(<span>function</span> (<span>index</span>) {</pre>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>this</span>).<span>text</span>();<span>// .text()は、中の文字を抜き出します</span></pre>
<pre></pre>
<pre><span>// 値を出力します。</span></pre>
<pre><span>console</span>.<span>log</span>(<span>index</span> +<span>": "</span> +<span>name</span>);</pre>
<pre>});</pre></div>
<p>次の表示結果になります。</p>
<p><img src="images/000047.gif" /></p>
<p>thisって何？と思われるかも知れません。ここでは、elementと同じ生のDOM要素を指します。「イベント」の章で、また改めて解説します。なお、ユーティリティ関数の<a href="#calibre_link-255">$.each()</a>というのもあり、使い方が異なります。</p>
<p>以上がこのメソッドの基本になります。まだ余裕があり、更に上を目指す方は、以下の追加情報もお読みください。</p>


<h4><b>.each()のreturn;</b></h4>
<p>eachの処理を全てストップ（break）したい時は、関数内で、<strong><b>return false;</b></strong>します。また、現在処理している要素だけを途中でストップして、次の要素の処理に移りたい時（continue）は、<strong><b>return false;以外でreturn;</b></strong>します。（JavaScriptのfor文ではないので、break;やcontinue;は使えません）</p>
<p>具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>四郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>each</span>(<span>function</span> (<span>index</span>) {</pre>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>this</span>).<span>text</span>();</pre>
<pre></pre>
<pre><span>if</span> (<span>index</span> ===<span>1</span>) {</pre>
<pre><span>// 次郎の時は、以降の処理はスキップ</span></pre>
<pre><span>return</span>;</pre>
<pre> }</pre>
<pre><span>if</span> (<span>index</span> ===<span>3</span>) {</pre>
<pre><span>// 四郎の時は、each自体をストップ</span></pre>
<pre><span>return</span><span>false</span>;</pre>
<pre> }</pre>
<pre><span>console</span>.<span>log</span>(<span>index</span> +<span>": "</span> +<span>name</span>);</pre>
<pre>});</pre></div>
<p>次の表示結果になります。</p>
<p><img src="images/000064.gif" /></p>
<p>次郎の回の時は、return;しているので、残りの処理はスキップされ、次郎は出力されずに次の要素の処理に移りました。<br />
また、四郎の回の時にreturn false;して、全てのeach処理がストップしたため、四郎と花子は出力されませんでした。</p>
<p>以上になります。ちなみに、「<strong><b>return false;以外でreturn;</b></strong>」の部分を「return true;」する、という解説を見かけることもありますが、trueである必要はありません。「return;」「return true;」「return null;」「return 0;」「return 'hoge';」どれでも大丈夫です）</p>



<h4><b>必要のない.each()</b></h4>
<p>長くなりますが、もう1つだけ追加情報を見てみましょう。 .each()は、便利なメソッドですが、なぜか使う必要の無い場面で使われてしまっているケースが多いので、それには気をつけましょう。 分かりやすい例を示しましょう。</p>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>each</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// 何かの処理</span></pre>
<pre> });</pre>
<pre>});</pre></div>
<p>上記の.each()、無駄に使われていると分かりますよね？本来、次のように書けばOKです。</p>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// 何かの処理</span></pre>
<pre>});</pre></div>
<p>こうやって見ると当たり前ですが、少し込み入ったことをやった後で、上記のような事をやってしまう人が多いので気をつけましょう。（まぁ、無駄な記述が増えるだけで、害はありませんが）</p>



<h3 id="calibre_link-142"><b>.get(n)、.get()</b></h3>
<p>「横断」で見た<a href="#calibre_link-133">.eq()</a>は、特定の位置を指定して、その位置の要素のjQueryオブジェクトを取得（選択）しました。 少し上達してくると、jQueryオブジェクトではなく、DOM（HTML）要素そのもの（生の要素）を取得したい場合もあります。DOM要素そのものとは、jQueryの色々なメソッドを備えていない要素になります。ですので、jQueryの便利なメソッドを使用することはできません。</p>
<p>何はともあれ、具体例で見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>element</span> =<span>$</span>(<span>"li"</span>).<span>get</span>(<span>0</span>);</pre>
<div></div>
<pre><span>// 値を出力します。</span></pre>
<pre><span>console</span>.<span>log</span>(<span>element</span>.<span>id</span>);</pre></div>
<p>このようにすると、次の表示結果になります。</p>
<p><img src="images/000022.gif" /></p>
<p>.get(n)の引数のnに、取得したい要素の番号を指定します。プログラミングらしく、0からスタートします。.eq(0)としたので、マッチしたLI要素全ての中から、最初の太郎の要素を取得します。.eq()と異なりこちらは生の要素が返されるため、element.idと本来のJavaScriptの書き方を使用して、idを取得しています。 .get()は、.eq()と同じくマイナスの数字を指定することもできます。その場合は、後ろから数えます。 また、話が込み入りますが、この.get(0)部分は実は、[0]と書くこともできます。jQueryオブジェクトが、配列かの如く扱えることを示しています。</p>
<div>
<pre><span>// これらは同じ事</span></pre>
<pre><span>var</span><span>element</span> =<span>$</span>(<span>"li"</span>).<span>get</span>(<span>0</span>);</pre>
<pre><span>var</span><span>element</span> =<span>$</span>(<span>"li"</span>)[<span>0</span>];<span>// でもこちらの場合、マイナスは使えない</span></pre></div>
<p>更に.get()にはもう1つ使い方があります。それは、引数を指定しない使い方です。引数を指定しない場合、マッチしたDOM（HTML）要素が通常の配列形式で返ります。</p>
<div>
<pre><span>var</span><span>elements</span> =<span>$</span>(<span>"li"</span>).<span>get</span>();</pre>
<div></div>
<pre><span>// 値を出力します。</span></pre>
<pre><span>console</span>.<span>log</span>(<span>elements</span>);</pre></div>
<p>次の表示結果になります。</p>
<p><img src="images/000045.gif" /></p>
<p>しかし、この使い方はやや直感的に分かりにくい所がありますね。そこで次に見る.toArray()というメソッドがあります。</p>
<h3 id="calibre_link-143"><b>.toArray()</b></h3>
<p>上記の.get()の引数を付けない時と同じで、マッチしたDOM要素が通常の配列形式で返ります。.get()の時と同じサンプルですが、以下のようになります。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>id</span>=<span>"taro"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>elements</span> =<span>$</span>(<span>"li"</span>).<span>toArray</span>();</pre>
<div></div>
<pre><span>// 値を出力します。</span></pre>
<pre><span>console</span>.<span>log</span>(<span>elements</span>);</pre></div>
<p>次の表示結果になります。</p>
<p><img src="images/000045.gif" /></p>
<h3 id="calibre_link-144"><b>.map(function (index, element))<span><b>中級</b></span></b></h3>
<p>中級レベルの為、入門者の方は、読み飛ばして下さい。.map()の引数や関数内のthisは、<a href="#calibre_link-15">既出の.each()</a>と全く同じです。詳しくは、.each()をご覧ください。</p>
<p>ということで、.map()ですが、まずは少し予備知識を付けましょう。jQueryオブジェクトは、通常、DOM要素を含んでいます。しかし、jQueryオブジェクトが含むことができるのは、DOM要素だけに限られません。普段使いませんが、以下のように配列を指定して、その個々の値を含むこともできます。</p>
<div>
<pre><span>var</span><span>arr0</span> =<span>$</span>([<span>"taro"</span>,<span>"jiro"</span>,<span>"saburo"</span>]);</pre>
<pre><span>console</span>.<span>log</span>(<span>arr0</span>);</pre></div>
<p>Firebugでの、arr0のイメージ結果。</p>
<p><img src="images/000039.gif" /></p>
<p>さて、では、以下のようにしたらどうなるでしょうか？</p>
<div>
<pre><span>var</span><span>arr1</span> =<span>$</span>([<span>"taro"</span>,<span>"jiro"</span>,<span>"saburo"</span>]).<span>get</span>();</pre>
<pre><span>var</span><span>arr2</span> =<span>arr1</span>.<span>join</span>(<span>"-"</span>);<span>// おまけ</span></pre></div>
<p><a href="#calibre_link-142">.get()</a>は、すぐ上で見たばかりです。jQueryオブジェクトが含む要素を通常のJavaScriptの配列で返します。<a href="#calibre_link-143">.toArray()</a>を使った方が分かりやすいかも知れません。ここでは、DOM要素ではないので、結果、上記のarr1は、通常の ["taro", "jiro", "saburo"] の配列となります。（結局、元の配列に戻ってます...） そして、.join("-");は、おまけですが、こうすることで、配列を「-」区切りの文字で結合します。（ちなみにjoinは、jQueryではなくJavaScriptに備わる関数です）つまりここでは、arr2は、"taro-jiro-saburo"となります。</p>
<p>さて、予備知識は、ここまでです。.map()について見て行きましょう。引数周りは、.each()と同じです。 .map()は更に、引数に指定した関数内からreturnしたデータを新しいjQueryオブジェクトとした形で返します。nullやundefinedを返した場合は、その回のデータは含まれません。（＝何もreturnしなければ含まれない）</p>
<p>具定例で見てみましょう。 以下は、taro、jiro、saburoにチェックが入っていますが、</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"taro"</span><span>checked</span><span>&gt;</span> 太郎</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"jiro"</span><span>checked</span><span>&gt;</span> 次郎</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"saburo"</span><span>checked</span><span>&gt;</span> 三郎</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"yotarou"</span><span>&gt;</span> 与太郎</pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>var</span><span>arr0</span> =<span>$</span>(<span>"input:checked"</span>).<span>map</span>(<span>function</span> () {</pre>
<pre><span>return</span><span>this</span>.<span>id</span>;</pre>
<pre> });</pre></div>
<p>1行目で、チェックの入ったフォーム要素（jQueryオブジェクト）を対象に、mapメソッドを実行します。 つまり、taro、jiro、saburoのチェックボックスが対象になります。</p>
<p>2行目で、その個々の要素に対して処理を実行しますが、ここでは、その個々の要素のidの値を返しています。</p>
<p>これで、arr0は、上記の予備知識で見たarr0と同じになります。つまり、["taro", "jiro", "saburo"]を含むjQueryオブジェクトです。ただ、よくあるパターンとしては、更に.get()で通常の配列に戻して、ダメ押しで.join()なども加えたりして、次のような形を取ったりします。</p>
<div>
<pre><span>var</span><span>arr</span> =<span>$</span>(<span>"input:checked"</span>).<span>map</span>(<span>function</span> () {</pre>
<pre><span>return</span><span>this</span>.<span>id</span>;</pre>
<pre> }).<span>get</span>().<span>join</span>(<span>"-"</span>);</pre></div>
<p>これで、arrは、"taro-jiro-saburo"になります。</p>
<p>以上、.map()でした。</p>
<p>今回は、元のデータ（id値）をそのまま返しましたが、例えばそのデータを加工したり、はてまたreturnするデータを限定してフィルタリングすることなども可能です。このように取得したデータを、例えば、HTML5のローカルストレージに保存したり、はてまたAJAX通信用のデータとして利用したり等、色々使えそうです。</p>
<p>補足情報として、.each()との違いですが、.each()は、個々の要素に対して何か処理する所にポイントがあり、 .map()の場合は、returnして収集したデータで何かする所にポイントがあります。また、ユーティリティ関数の<a href="#calibre_link-256">$.map()</a>もあります。</p>





<h3 id="calibre_link-145"><b>.index()</b></h3>
<p>.index()について見ていきます。ここでは、「イベント」が登場してきますが、イベント関係は次の章での説明になりますので、イベントについて全く始めての場合は、イベントを読み終えてからこちらをご覧ください。</p>
<p>.index()は、構文的には3つあります。どれも、指定の要素がどこ（何番目）にあるかを返しますが、構文によって使い方が全く異なりますのでご注意下さい。
どれも0から数えます。また要素が見つからない場合は、-1を返します。では構文を見ていきます。</p>


<h4><b>主語.index(element)</b></h4>
<p>elementは、DOM要素又はjQueryオブジェクトを指定します。jQueryオブジェクトで複数マッチする時は、最初の要素が対象になります。<br />
主語は、jQueryオブジェクトですが、そのjQueryオブジェクトで選択されている要素中、elementが何番目にあるかを返します。例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<div></div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>りんご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>li</span> =<span>$</span>(<span>"li"</span>);</pre>
<div></div>
<pre><span>li</span>.<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>idx</span> =<span>li</span>.<span>index</span>(<span>this</span>);</pre>
<div></div>
<pre><span>console</span>.<span>log</span>(<span>idx</span>);</pre>
<pre>});</pre></div>
<p>各LI要素に対してイベントを仕掛けています。クリック時に、そのクリックされた要素が、LI要素全体で何番目に占めているかを返します。つまりこの場合、太郎のクリックで0、次郎...1、三郎...2、いちご...3、みかん...4、りんご...5と出力されます。</p>



<h4><b>主語.index(selector)</b></h4>
<p>selectorは、セレクタの"文字列"です。selectorでマッチする要素を全体として、その全体中に、主語のjQueryオブジェクト（複数マッチする場合は、最初の要素）が、何番目にあるかを返します。例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<div></div>
<pre><span>&lt;ul</span><span>id</span>=<span>"fruit"</span><span>&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>りんご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>li</span> =<span>$</span>(<span>"li"</span>);</pre>
<div></div>
<pre><span>li</span>.<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>idx</span> =<span>$</span>(<span>this</span>).<span>index</span>(<span>"#fruit li"</span>);</pre>
<div></div>
<pre><span>console</span>.<span>log</span>(<span>idx</span>);</pre>
<pre>});</pre></div>
<p>今度は、HTMLの2つ目のUL要素にid="fruit"が付いています。JS側では、先ほど同様、各LI要素に対してイベントを仕掛けています。クリック時に、そのクリックされた要素が、"#fruit li"全体中に何番目に占めているかを返すようにしてます。つまり、太郎、次郎、三郎は、"#fruit li"中には存在しないので、どれも-1を出力します。一方、いちご、みかん、りんごの場合は、それぞれ0、1、2と出力します。</p>



<h4><b>主語.index()</b></h4>
<p>今度は、引数に何も取らないタイプです。主語のjQueryオブジェクト（複数マッチする場合は、最初の要素）が、その兄弟（その親の子供）を全体として、何番目となるかを返します。例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>三郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre>
<div></div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>いちご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>みかん<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>りんご<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>var</span><span>li</span> =<span>$</span>(<span>"li"</span>);</pre>
<div></div>
<pre><span>li</span>.<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>idx</span> =<span>$</span>(<span>this</span>).<span>index</span>();</pre>
<div></div>
<pre><span>console</span>.<span>log</span>(<span>idx</span>);</pre>
<pre>});</pre></div>
<p>HTMLは最初のパターンに戻りました。JS側では、今まで同様、各LI要素に対してイベントを仕掛けています。クリック時に、そのクリックされた要素が、その兄弟を全体として、何番目かを返します。例えば、いちごをクリックした場合、その兄弟全体は、いちご、みかん、りんご、ですので、0となります。まとめると、太郎、いちご...0、次郎、みかん...1、三郎、りんご...2となります。<br /><br />確認がてら、下も見ておきましょう。</p>
<div>
<pre><span>&lt;h1&gt;</span>こんにちは<span>&lt;/h1&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"main"</span><span>&gt;</span></pre>
<pre>メインです</pre>
<pre><span>&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;div</span><span>id</span>=<span>"footer"</span><span>&gt;</span></pre>
<pre>フッターです</pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>idx</span> =<span>$</span>(<span>"#main"</span>).<span>index</span>();</pre>
<div></div>
<pre><span>console</span>.<span>log</span>(<span>idx</span>);</pre></div>
<p>この場合は、1を出力します。親がbodyとすると、h1が0、id="main"が1、id="footer"が2となります。</p>
<p>以上、.index()についてでした。3つ構文がありますので、その時に適したのを使うようにしましょう。</p>


</div>
<div id="calibre_link-327">
<h1 id="calibre_link-367">7章　イベント</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-147">イベントの基本</a></li>
	<li><a href="#calibre_link-148">色々なイベント（ショートカット用イベント）</a></li>
	<li><a href="#calibre_link-150">thisキーワード</a></li>
	<li><a href="#calibre_link-152">バブリング（bubbling）とは</a></li>
	<li><a href="#calibre_link-153">イベントオブジェクト</a></li>

	<li><a href="#calibre_link-160">マウス関係のイベント</a></li>
	
	<li><a href="#calibre_link-166">沢山の要素にイベントを付与したい時や動動的に追加した要素もイベントの対象にしたい時</a></li>
	<li><a href="#calibre_link-167">イベント委譲（Event Delegation）の流れ</a></li>

	<li><a href="#calibre_link-168">.on()のまとめ</a></li>

	<li><a href="#calibre_link-172">.one()</a></li>
	<li><a href="#calibre_link-173">.off()</a></li>
	<li><a href="#calibre_link-174">.trigger()</a></li>
	<li><a href="#calibre_link-175">.triggerHandler()</a></li>
<li><a href="#calibre_link-176">画像などの読み込みが完了してから処理を実行する</a></li>
    

	<li><a href="#calibre_link-178">.bind()</a></li>
	<li><a href="#calibre_link-179">.live()</a></li>
	<li><a href="#calibre_link-180">.delegate()</a></li>
<li><a href="#calibre_link-181">従来のイベント付与とjQuery流イベント付与</a></li>
</ul>
</div>
<div id="calibre_link-338">
<h2 id="calibre_link-147">イベントの基本</h2>
<p>イベントとは、ユーザーがクリックした、マウスオーバーした、ページの読み込みが完了した、などの何かしらの事象のことを言います。 そして、そのイベントに応じて何かの動作を起こすことをイベント処理と言います。<br />
まずはごく簡単なサンプルで見てみましょう。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"click_me"</span><span>value</span>=<span>"クリックしてね"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#click_me"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>alert</span>(<span>"お呼びしましたか？"</span>);</pre>
<pre>});</pre></div>
<p>#click_meの要素（ここでは、ボタン）に対して、クリックイベントを仕掛けました。これでユーザーがボタンをクリックすると、「お呼びしましたか？」とアラートを表示します。 上記は、以下のように説明できます。</p>
<p><strong><b>$(セレクター).on("イベント名", イベントの処理内容を記した関数);</b></strong></p>
<p>最初のセレクターは、イベントを仕掛けたい要素を指定します。第2引数に関数を記述します。この書き方は非常によく使われるので、上記を構文として覚えておくと良いです。また、<strong><b>イベントの処理内容を記した関数</b></strong>と言うのは長いので、専門用語があり、それは、<strong><b>「イベントハンドラ」</b></strong>と呼びます。</p>
<p>上記では無名関数（関数を直接書く方式。関数に名前が無い為）を記述しましたが、普通に関数を定義して、次のように書くこともできます。<br />
その2</p>
<div>
<pre><span>function</span><span>oyobi</span>() {</pre>
<pre><span>alert</span>(<span>"お呼びしましたか？"</span>);</pre>
<pre>}</pre>
<pre><span>$</span>(<span>"#click_me"</span>).<span>on</span>(<span>"click"</span>,<span>oyobi</span>);</pre></div>
<p>その3</p>
<div>
<pre><span>var</span><span>oyobi</span> =<span>function</span> () {</pre>
<pre><span>alert</span>(<span>"お呼びしましたか？"</span>);</pre>
<pre>};</pre>
<pre><span>$</span>(<span>"#click_me"</span>).<span>on</span>(<span>"click"</span>,<span>oyobi</span>);</pre></div>
<p>oyobiは、任意の名前でOKです。<br />
その2は、よく見る書き方です。また、その3のように、変数に関数を代入することもできます。 どちらの場合も4行目は同じで、関数名を指定します。（指定するだけなので、oyobi()のように()は、付けてはいけません。入門者の方は、よくやってしまう間違いなので、気をつけましょう）</p>
<p>以上、3つほど関数の書き方を見ましたが、その時の状況や自分の好みなどに応じて使い分ければ良いでしょう。但し、その3の書き方は、1～3行目の部分は、4行目よりも先に記述しないといけないので注意して下さい。その2の場合は、後に書いても大丈夫です。</p>
<p>さて、話を戻しましょう。先ほどは、clickイベントを使用しました。では、クリックではなく、ダブルクリックのイベントにしたい場合、どうすれば良いでしょうか？ "click"と書いた部分を、"dblclick"と書けばいいだけです。イベントは、これら以外にも沢山あります。 どのようなイベントがあるかは、この後ざっと見ますが、これらのイベント用の<strong><b>ショートカットの書き方</b></strong>があります。 例えば、最初のサンプルをショートカットを使って書き換えると、次のようになります。</p>
<div>
<pre><span>$</span>(<span>"#click_me"</span>).<span>click</span>(<span>function</span> () {</pre>
<pre><span>alert</span>(<span>"お呼びしましたか？"</span>);</pre>
<pre>});</pre></div>
<p>少しすっきりしました。
  実は、.on()は、Ver. 1.7.0から登場したメソッドで、1.7.0未満では使えません。そもそも今時1.7.0未満を使う事はあまり無いと思いますが、もし1.7.0未満を使わざるを得ない時は、後に見る.bind()を使うか、これらのショートカット用メソッドで代用します。</p>
<p>イベント付与にonを使うか、ショートカットを使うかは、好みもあるかも知れませんが、本書では、.on()の形式を推奨しておきます。（.bind()は、Ver.3.0では将来廃止予定の位置づけの為、Ver.1.7.0未満以外では使わないようにします）</p>



</div>
<div id="calibre_link-353">
<h2 id="calibre_link-148">色々なイベント（ショートカット用イベント）</h2>
<p>イベントには、色々なイベントタイプがあります。 .on()を使えば、どのようなイベントにも対応できますが、代表的なイベントは、ショートカットのメソッドが用意されています。これらショートカットが用意されているイベントタイプを一覧でざっと見てみましょう。</p>


<h3 id="calibre_link-149"><b>ショートカット用イベント</b></h3>
<p>一部分かりにくいイベントもあるかも知れませんが、取りあえず雰囲気だけでも掴んでおきましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>タイプ</b></th>
<th><b>イベント発生のタイミング</b></th>
</tr>
<tr>
<td>.blur()</td>
<td>フォーカスを失った時に発生します。<br />
元々はフォーム要素のinputなどに対してのみ有効でしたが、最近のブラウザでは、それ以外の要素でも可能。</td>
</tr>
<tr>
<td>.change()</td>
<td>&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;型のフォーム要素において、値が変更された時に発生します。<br />
セレクト型、チェックボックス、ラジオボタンなどではユーザーが選択を変更した時点で即座にイベントが発生しますが、テキストを入力するタイプでは、<strong><b>更にフォーカスが離れないと</b></strong>発生しません。</td>
</tr>
<tr>
<td>.click()</td>
<td>クリックした時に発生します。</td>
</tr>
<tr>
<td>.dblclick()</td>
<td>ダブルクリックした時に発生します。</td>
</tr>
<tr>
<td>.error()</td>
<td>画像などが読み込めなかった際に発生します。<span>（Ver.3.0にて削除）</span></td>
</tr>
<tr>
<td>.focus()</td>
<td>フォーカスされた時に発生します。主にフォーム要素やアンカー（&lt;a&gt;）で使用します。</td>
</tr>
<tr>
<td>.focusin()</td>
<td>focusをバブリングするように対応させた版です。<br />focusとfocusinの違いは、focusがバブリングしないのに対し、focusinは、バブリングします。言い換えると、focusは親要素においてバブリングを捕捉できませんが、focusinはできます。<br />（但し、Ver. 1.4.2以降でイベント委譲による場合は、focusを使った場合でも内部的にfocusinを使用し、バブリングするようにして、イベント委譲としての役割を果たすようにしています。）</td>
</tr>
<tr>
<td>.focusout()</td>
<td>blurをバブリングするように対応させた版です。blurとfocusoutの違いについては、focusとfocusinの違いと等価です。上記もご覧ください。</td>
</tr>
<tr>
<td>.keydown()</td>
<td>キーボード（のキー）が下に押された時に発生します。</td>
</tr>
<tr>
<td>.keypress()</td>
<td>キーボードが押された時に発生します。（keydownより後で、keyupより先に発生）<br />
キーボードを押し続けた時は、何度も発生し得る。（keydownの場合は、1度だけ）</td>
</tr>
<tr>
<td>.keyup()</td>
<td>キーボードを上に上げた時に発生します。</td>
</tr>
<tr>
<td>.load()</td>
<td>画像などのコンテンツが読み込まれた際に発生します。<span>（Ver.3.0にて削除）</span><br />
Ajaxの方にある.load()は、引き続き使える予定です。</td>
</tr>
<tr>
<td>.mousedown()</td>
<td>マウスを押した時に発生します。</td>
</tr>
<tr>
<td>.mouseenter()</td>
<td>mouseoverだと、対象要素が入れ子になっていた際に好ましくない挙動になってしまうので、その点を改良した版です。（本来IE独自のイベントをjQueryがどのブラウザでも使えるようにしています）</td>
</tr>
<tr>
<td>.mouseleave()</td>
<td>mouseenterと同様に、mouseoutの好ましくない点を改良した版です。</td>
</tr>
<tr>
<td>.mousemove()</td>
<td>要素上でマウスを動かした際に発生します。</td>
</tr>
<tr>
<td>.mouseout()</td>
<td>マウスのポインターが要素から離れた際に発生します。</td>
</tr>
<tr>
<td>.mouseover()</td>
<td>マウスオーバーした際に発生します。</td>
</tr>
<tr>
<td>.mouseup()</td>
<td>マウスを上に離した時に発生します。</td>
</tr>
<tr>
<td>.ready()</td>
<td>DOMが完全に読み込まれた後に発生します。jQuery(document).ready(functionの形で使われます。<br />（このイベント名に関しては、.on()を使った書き方は、Ver.3.0からは使用できなくなります）</td>
</tr>
<tr>
<td>.resize()</td>
<td>ブラウザのウインドウの大きさを変更した時に発生します。$(window).resize(functionの形で使います。</td>
</tr>
<tr>
<td>.scroll()</td>
<td>ブラウザのスクロール位置を変更した時に発生します。ブラウザの一番右端にあるスクロールやフレーム、overflowしてスクロールする要素などが対象になります。<br />
例、$(window).scroll(function</td>
</tr>
<tr>
<td>.select()</td>
<td>フォームのテキスト入力するタイプ（&lt;input type="text&gt;、&lt;textarea&gt;）で、テキストを選択した時に発生します。</td>
</tr>
<tr>
<td>.submit()</td>
<td>フォームを送信しようとした時に発生します。<br />
例、$("form").submit(function</td>
</tr>
<tr>
<td>.unload()</td>
<td>ユーザーがページを離れる時に発生します。<span>（Ver.3.0にて削除）</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>諸事情（不都合）により3つのショートカットが、Ver.3.0では削除されますが、これら相当の事をする場合は、.on()を使って記述するようにします。（ただ、対象のブラウザで正しく動作するか十分検証して下さい）</p>







</div>
<div id="calibre_link-14">
<h2 id="calibre_link-150">thisキーワード</h2>
<p>thisというキーワードは、JavaScriptに元々存在する予約語で、その時の流れに応じて意味するものが変わります。ここでは、イベントハンドラ内でのthisという前提で話をして行きます。</p>
<p>次のサンプルを用意しました。ボタンをクリックすると、ボタンに書かれた文字をアラート表示するというものです。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"太郎です"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"次郎です"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"三郎です"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"input[type=button]"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>val</span> =<span>$</span>(<span>this</span>).<span>val</span>();</pre>
<pre><span>alert</span>(<span>val</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/event_this.php">実際のサンプル</a></p>
<p>上記では、3つのボタンにまとめてイベントを設定しています。この場合、どのボタンが押されたのか、イベントハンドラ内で知りたくなるものです。そこで登場するのが、thisです。


<strong><b>thisは、イベント処理の対象となる要素自体を指します。thisというキーワードを使うことで、どのボタンが押されたかを特定できます。</b></strong></p>
<p><img src="images/000055.gif" /></p>
<p>また、thisは、<strong><b>jQueryオブジェクトではない生のDOM要素のため、jQueryのメソッドを続けて書くことができません。そこで、jQueryのメソッドを使えるようにする場合は、$(this)とすることで可能になります。</b></strong></p>
<p>thisは、$(this)と書けばjQueryのメソッドを使えますが、必ずしもそうする必要は無く、jQueryに頼らず生のJavaScriptを使う場合は、thisをそのまま使うこともできます。 例えば、先のJavaScriptは、このように書くこともできます。（2行目に注目）</p>
<div>
<pre><span>$</span>(<span>"input[type=button]"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>val</span> =<span>this</span>.<span>value</span>;<span>// jQueryに頼らない書き方</span></pre>
<pre><span>alert</span>(<span>val</span>);</pre>
<pre>});</pre></div>
<p>イベントの設定や起動される仕組みは、他にもパターンがありますので、それらについては改めて見ていきますが、いずれの場合も、thisは、<strong><b>「処理の対象になっている要素」</b></strong>と言えます。これは非常に重要です。</p>


<h3 id="calibre_link-151"><b>thisは、流れに応じて変わる</b></h3>
<p>thisというキーワードは、JavaScriptに元々存在するものです。関数（メソッド）の中ごとに、thisが意味するものは変わります。 今回見たのは、イベントハンドラ（関数）内でのthisでした。関数は、もちろん他にも沢山あります。例えば、jQueryオブジェクト操作用のメソッド（関数）で、<a href="#calibre_link-15">.each()</a>を見ました。この.each()の中で呼ばれるthisは、その.each()に対応した意味を持ちます。 では、もしイベントハンドラの中に、.each() メソッドを書いた場合はどうなるでしょうか？ 結論的には、.each() の中では、.each() 用のthisが有効になり、.each() の外側では、イベントハンドラ用のthisが有効になります。</p>
<div>
<pre><span>$</span>(<span>"xxxxx"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// この中では、thisは、イベントハンドラ用のthisを指す。</span></pre>
<pre><span>// もしeachの中でもこちら側のthisを使いたい場合は、他の変数に割り当てる</span></pre>
<pre><span>var</span><span>that</span> =<span>this</span>;</pre>
<pre></pre>
<pre><span>$</span>(<span>"li"</span>).<span>each</span>(<span>function</span> () {</pre>
<pre><span>// この中では、thisは、each用のthisになる。</span></pre>
<pre><span>// 上で割り当てたthatを使えば、イベントハンドラ用のthisを取得できる</span></pre>
<pre><span>$</span>(<span>that</span>);</pre>
<pre> });</pre>
<pre></pre>
<pre>});</pre></div>
<p>上記では、イベントハンドラ用のthisをthatという変数に格納して待避しています。thatの変数名は、有効な変数名であれば何でも構いません。selfなどもよく使われます。</p>



</div>
<div id="calibre_link-298">
<h2 id="calibre_link-152">バブリング（bubbling）とは</h2>
<p>バブリング（bubbling）とは、 発生したイベントが、発生源からドキュメントの上位の方に向かって順に伝播していくフェーズのことを指します。</p>
<p><img src="images/00073.jpeg" /><br />
バブリングのイメージ図</p>
<p>上記のイメージ図通りのサンプルを用意しました。<a href="http://jquery-master.net/examples/event_bubbling.php">実際のサンプル</a></p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"xxx"</span><span>&gt;</span></pre>
<pre> xxx</pre>
<pre><span>&lt;div</span><span>class</span>=<span>"yyy"</span><span>&gt;</span></pre>
<pre>  yyy</pre>
<pre><span>&lt;div</span><span>class</span>=<span>"zzz"</span><span>&gt;</span></pre>
<pre>   zzz</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"div"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>var</span><span>cls</span> =<span>$</span>(<span>this</span>).<span>attr</span>(<span>"class"</span>);</pre>
<pre><span>alert</span>(<span>cls</span>);</pre>
<pre>});</pre></div>
<p>このサンプルでは、<strong><b>div3つ全てにイベントを割り当て</b></strong>、クリックされたらその要素のクラス名を取り出し、アラート表示しています。<br />
さて、xxx、yyy、zzz、各場所を押し比べてみて下さい。zzzの場所を押すとしましょう。すると、「zzz」「yyy」「xxx」とアラートが3回出てきます。「zzzしかクリックしていないのに？」と思いますが、イベント処理が3回行われているのが分かります。 最初にイベント発生源のzzzの部分でイベント処理が行われ、続けて、yyy、xxxのようにイベントが上に伝播していくのです。これは、泡のように弾ける様子に似ていることから、バブリング（bubbling）と呼ばれています。</p>
<p>さて、zzzをクリックしたら、イベントが3回発生しました。では、それぞれの3回分のthisは何を指しているのでしょうか？という質問も愚問でしたが、そもそも「zzz」「yyy」「xxx」とアラートが表示されましたので、イベント1回目のthisは、zzzのdiv、イベント2回目のthisは、yyyのdiv、イベント3回目のthisは、xxxのdivを指しているのが分かります。<br />
イベントの発生源は、zzzのdivの1つのみですが、thisは、それぞれごとの要素を指しています。 時折、便宜上か、「イベント内のthisは、イベント発生元（発生源）を指す」という説明を見かけますが、バブリングが絡んだ場合は、この限りではないので注意しましょう。</p>
<p><img src="images/000014.gif" /><br />
参考イメージ図</p>
</div>
<div id="calibre_link-300">
<h2 id="calibre_link-153">イベントオブジェクト</h2>
<p>イベントオブジェクトとは、イベントハンドラの第1引数に自動でセットされるオブジェクトで、イベントに関する情報（又は、イベントを制御するメソッド）を含んでいます。 まずは、どのようなイベントオブジェクトがあるかを一覧で見てみましょう。その後、それらの内の幾つかを見ていきます。</p>


<ul>
	<li><a href="#calibre_link-154">イベントオブジェクトの一覧</a></li>
	<li><a href="#calibre_link-155">event.clientX、event.clientY</a></li>
	<li><a href="#calibre_link-156">event.which</a></li>
	<li><a href="#calibre_link-157">event.preventDefault()</a></li>
	<li><a href="#calibre_link-158">event.stopPropagation()</a></li>
	<li><a href="#calibre_link-159">return false</a></li>
</ul>



<h3><b>イベントオブジェクトの一覧</b></h3><table width="100%">
<tbody><tr>
<th><b>タイプ</b></th>
<th><b>イベント発生のタイミング</b></th>
</tr>


<tr>
<td>event.altKey</td>
<td>Altキーが押されていたらtrue、そうでなければfalse</td>
</tr>
<tr>
<td>event.ctrlKey</td>
<td>Ctrlキーが押されていたらtrue、そうでなければfalse</td>
</tr>
<tr>
<td>event.shiftKey</td>
<td>Shiftキーが押されていたらtrue、そうでなければfalse</td>
</tr>
<tr>
<td>event.clientX<br />event.clientY</td>
<td>clientX：マウスイベント時におけるマウスポインタのブラウザ窓上での上端からの位置<br />clientY：同上の左端からの位置<br />（スクロースされていようが関係無し）</td>
</tr>
<tr>
<td>event.pageX<br />event.pageY</td>
<td>pageX：マウスイベント時におけるマウスポインタのドキュメント上での上端からの位置<br />pageY：同上の左端からの位置<br />（スクロースされていれば、その分足される）</td>
</tr>
<tr>
<td>event.screenX<br />event.screenY</td>
<td>screenX：マウスイベント時におけるスクリーン（ディスプレイorモニタ）上での上端からの位置<br />screenY：同上の左端からの位置<br />（デュアルディスプレイなどは、1つとみなされるようです）</td>
</tr>
<tr>
<td>event.data</td>
<td>イベント設定時にdataとして引き渡されたオブジェクト（詳しくは、改めて）</td>
</tr>
<tr>
<td>event.target</td>
<td>イベント発生源の要素</td>
</tr>
<tr>
<td>event.type</td>
<td>イベントのタイプ（"click"など）</td>
</tr>
  	  
<tr>
<td>event.which</td>
<td>キーボードのイベントでは、押されたキーに対応する数字。マウスイベントでは、左ボタンが1、真ん中ボタンが2、右ボタンが3</td>
</tr>
<tr>
<td>event.preventDefault()</td>
<td>デフォルトのアクションを停止する</td>
</tr>
<tr>
<td>event.stopPropagation()</td>
<td>以降のイベント伝播を停止する</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>上記は、入門者用に限定させていただきました。</p>
<p>実は、ブラウザが返す本来のイベントオブジェクトは、ブラウザ間で相違があるため、jQueryでは、それらを標準化した（jQuery用の）イベントオブジェクトを返すようにしています。もしブラウザ本来の値を取得したい場合は、event.originalEventで取得できます。 では、上記の内の幾つかを見て行きましょう。</p>
<h3 id="calibre_link-155"><b>event.clientX、event.clientY</b></h3>
<p>まずは、clientXとclientYを見てみましょう。<br />
  ここでは、ドキュメントをクリックすると、クリックしたドキュメント上の位置を表示します。</p>
<p><a href="http://jquery-master.net/examples/event_clientXY.php">実際のサンプル</a></p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"text"</span><span>id</span>=<span>"clientXY"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>document</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>$</span>(<span>"#clientXY"</span>).<span>val</span>(<span>event</span>.<span>clientX</span> +<span>": "</span> +<span>event</span>.<span>clientY</span>);</pre>
<pre>});</pre></div>
<p>ここではイベントハンドラの引数にeventという変数名を使用していますが、ここは何でもOKですので、例えばただ単にeとしてもOKです。</p>



<h3 id="calibre_link-156"><b>event.which</b></h3>
<p>event.whichは、キーボードのイベントの時は、押されたキーに対応する数字が取得できます。keydown、keypress、keyupのイベントで取得できますが、keypressでは、大文字と小文字を区別するため、例えば、「A」の時は65、「a」の時は97が返されます。 一方、keydownとkeyupの時は、大文字小文字に関わらず、同じ数字が返されます。「A」や「a」でも、65が返されます。もしkeydownとkeyupの時に大文字と小文字を区別したい時は、event.shiftKeyの値をチェックすればOKです。また、マウスイベントの時は、押されたマウスのボタンにより、左ボタンが1、真ん中ボタンが2、右ボタンが3を返します。</p>
<h3 id="calibre_link-157"><b>event.preventDefault()</b></h3>
<p>ブラウザは、デフォルトの動作を持っています。それは、あなたが何かプログラムしなくても勝手に動作するものです。例えば、送信ボタン（submitボタン）を押せば、ブラウザは勝手に送信しますし、アンカーリンク（&lt;a&gt;）をクリックすれば、自動でページ移動したりします。これらのデフォルトのアクションを止めるのが、event.preventDefault()です。 例を見てみましょう。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"text"</span><span>name</span>=<span>"myname"</span><span>id</span>=<span>"myname"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"submit"</span><span>value</span>=<span>"送信"</span><span>/&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"input[type=submit]"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>if</span> (<span>$</span>(<span>"#myname"</span>).<span>val</span>() !==<span>"太郎"</span>) {</pre>
<pre><span>event</span>.<span>preventDefault</span>();</pre>
<pre> }</pre>
<pre>});</pre></div>
<p>上記のサンプルでは、送信ボタンを押しても入力値が「太郎」でない場合、デフォルトの動作（＝送信）が阻止され、送信されません。</p>
<p><a href="http://jquery-master.net/examples/event_preventDefault.php">実際のサンプル</a></p>



<h3 id="calibre_link-158"><b>event.stopPropagation()</b></h3>
<p>先のバブリングのサンプルを覚えているでしょうか？ イベントが伝播する例を見ました。しかし、もしイベントの伝播を止めたい場合はどうすれば良いでしょうか？それが、event.stopPropagation()です。 このメソッドを呼ぶことで、それ以降のイベントの伝播を抑えます。 バブリングの例で見たサンプルを一部だけ改良しました。<a href="http://jquery-master.net/examples/event_bubbling_stop.php">【改良版サンプル】</a></p>
<div>
<pre><span>&lt;div</span><span>class</span>=<span>"xxx"</span><span>&gt;</span></pre>
<pre> xxx</pre>
<pre><span>&lt;div</span><span>class</span>=<span>"yyy"</span><span>&gt;</span></pre>
<pre>  yyy</pre>
<pre><span>&lt;div</span><span>class</span>=<span>"zzz"</span><span>&gt;</span></pre>
<pre>   zzz</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"div"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>var</span><span>cls</span> =<span>$</span>(<span>this</span>).<span>attr</span>(<span>"class"</span>);</pre>
<pre><span>alert</span>(<span>cls</span>);</pre>
<pre><span>event</span>.<span>stopPropagation</span>();<span>// ここを追加しました。</span></pre>
<pre>});</pre></div>
<p>サンプルを試してみて下さい。バブリングの例では、「zzz」をクリックすると「zzz」「yyy」「xxx」と連続して表示されていましたが、今度は、「zzz」しか表示されません。同様に「yyy」のクリックでも、「yyy」しか表示されません。それ以降の伝播がストップされているのが分かります。</p>
<h3 id="calibre_link-159"><b>return false</b></h3>
<p>これはイベントオブジェクトではありませんが、イベントハンドラをreturn false;として抜けることで、event.preventDefault();とevent.stopPropagation();の両方を指定したのと同じ効果が得られます。記述が楽でいいかも知れません。</p>
<div>
<pre><span>$</span>(<span>"input[type=submit]"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>if</span> (<span>$</span>(<span>"#myname"</span>).<span>val</span>() !==<span>"太郎"</span>) {</pre>
<pre><span>return</span><span>false</span>;</pre>
<pre> }</pre>
<pre>});</pre></div>


</div>
<div id="calibre_link-313">
<h2 id="calibre_link-160">マウス関係のイベント</h2>
<p>マウス関係のイベントを見てみましょう。</p>


<ul>
	<li><a href="#calibre_link-161">.mouseenter()、.mouseleave()、hover()</a></li>
	<li><a href="#calibre_link-162">.mouseenter()、.mouseleave() と .mouseover()、.mouseout() の違い</a></li>
	<li><a href="#calibre_link-163">.hover()メソッド と .on() と "hover"擬似イベント</a></li>
	<li><a href="#calibre_link-164">マウスイベント用の.toggle()</a></li>
</ul>
<h3 id="calibre_link-161"><b>.mouseenter()、.mouseleave()、hover()</b></h3>
<p>よく耳にする方の.mouseover()と.mouseout()は、ご存知の方も多いかと思いますが、これらはある要素に「マウスが乗った時」「マウスが離れた時」です。 一方、今回見る.mouseenter()と.mouseleave()もそういう意味では同じですが、要素が入れ子になっていた時に違いが出てきます。 これらの違いは、少し小難しいので、解説は次で行います。<strong><b>要は、mouseover、mouseoutを使うより、mouseenter、mouseleaveを使った方がいい</b></strong>と言えます。</p>
<p>では、早速、.mouseenter()と.mouseleave()の2つを見てみましょう。ここでは、.on()ではなく、ショートカット用メソッドの方を使っていきます。 忍者の画像にマウスを持ってくると、画像が猫に代わり、マウスを離すとまた忍者に戻ります。</p>
<div>
<pre><span>&lt;img</span><span>id</span>=<span>"ninja"</span><span>src</span>=<span>"img/ninja.png"</span><span>&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#ninja"</span>).<span>mouseenter</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>attr</span>(<span>"src"</span>,<span>"img/cat.png"</span>);</pre>
<pre>}).<span>mouseleave</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>attr</span>(<span>"src"</span>,<span>"img/ninja.png"</span>);</pre>
<pre>});</pre></div>
<p><img src="images/00009.jpeg" /></p>
<p><a href="http://jquery-master.net/examples/event_mouse.php">実際のサンプル</a></p>
<p>上記のように、メソッドチェーンを使ってイベントを続けて設定することができます。 ここでは、thisは、各img要素を指していますので、そのsrc属性を変えることで、画像を切り替えています。
実は、この .mouseenter()、.mouseleave() は、よく使われるため、jQueryでは、それ用の特別メソッドの.hover()というメソッドがあります。これを使うと次のように書けます。</p>
<div>
<pre><span>$</span>(<span>"#ninja"</span>).<span>hover</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>attr</span>(<span>"src"</span>,<span>"img/cat.png"</span>);</pre>
<pre>},<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>attr</span>(<span>"src"</span>,<span>"img/ninja.png"</span>);</pre>
<pre>});</pre></div>
<p>第1引数に.mouseenter()用のイベントハンドラ、第2引数に.mouseleave()用のイベントハンドラを指定します。少しすっきりしました。</p>


<h3 id="calibre_link-162"><b>.mouseenter()、.mouseleave() と .mouseover()、.mouseout() の違い</b></h3>
<p>さほど重要でもなく、少し小難しいため、入門者の方は読み飛ばして下さい。気になる方だけ読み進めて下さい。先にも書きましたが、mouseenter、mouseleaveの方を使っておけばOKです。</p>
<p>まずは、.mouseover()と.mouseout()を使ったサンプルから。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"outer"</span><span>&gt;</span></pre>
<pre> outer</pre>
<pre><span>&lt;div</span><span>id</span>=<span>"inner"</span><span>&gt;</span></pre>
<pre>  inner</pre>
<pre><span>&lt;/div&gt;</span></pre>
<pre><span>&lt;/div&gt;</span></pre></div>
<div>
<pre><span>function</span><span>log</span>(<span>event</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>"タイプ："</span> +<span>event</span>.<span>type</span> +<span>" 発生源："</span> +<span>event</span>.<span>target</span>.<span>id</span>)</pre>
<pre>}</pre>
<pre><span>$</span>(<span>"#outer"</span>).<span>on</span>(<span>"mouseover mouseout"</span>,<span>log</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/event_mouseout.php">実際のサンプル</a></p>
<p>このサンプルは、Firebugなどのコンソール画面で見る必要があります。<br />
  このサンプルは、<strong><b>外側の「outer」だけに対して</b></strong>「mouseover」と「mouseout」のイベントを設定している点に注意して下さい。<br />
サンプルを開いたら、Firebugなどのコンソール画面を開いて、マウスを「outer」に持って行き、そして次は、「inner」に移動して下さい。 ここまでの動作で、次のように表示されたと思います。</p>
<p><img src="images/000035.gif" /></p>
<p>「タイプ」は、発生したイベントのタイプを、「発生源」は、イベントが発生した場所を表しています。 さて、まずは1行目ですが、これは想定通りです。そして、その後の2、3行目、これは通常我々の望まない動作です。 では、2行目は何でしょうか？これは、「outer」から「inner」に移動した時も「mouseout」とみなされてしまっているのです。外に抜けた時のみならず、内側の子要素に移動した時もなのです。
そして、3行目は、発生源が「inner」で、タイプが「mouseover」になっています。これはinnerで発生したイベントが伝播（バブリング）して、それをouterが捉えて生じた結果です。</p>
<p>ダメ押しで、「inner」から「outer」に移動した時も見てみましょう。次の2つが追加で表示されます。</p>
<p><img src="images/000035.gif" /></p>
<p>最初が、「inner」から「outer」に抜けた際の「mouseout」をバブリングで捉えています。その次は、「outer」自身にて、「inner」から「outer」の移動を「mouseover」と捉えてしまっています。</p>
<p>小面倒ですね。これらを一気に解決してくれるのが、.mouseenter()、mouseleave()です。</p>
<div>
<pre><span>function</span><span>log</span>(<span>event</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>"タイプ："</span> +<span>event</span>.<span>type</span> +<span>" 発生源："</span> +<span>event</span>.<span>target</span>.<span>id</span>)</pre>
<pre>}</pre>
<pre><span>$</span>(<span>"#outer"</span>).<span>on</span>(<span>"mouseenter mouseleave"</span>,<span>log</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/event_mouseenter.php">実際のサンプル</a></p>
<p>今度はどうでしょうか？「outer」から「inner」に移動しても、余計な処理が発生していません。純粋に「outer」の外枠線の出入りだけで処理が発生します。これぞ我々が望む動作なのです。</p>
<p><img src="images/000062.gif" /></p>
<p>この.mouseenter()、mouseleave()は、元来IEが独自に実装した機能ですが、jQueryでは、どのブラウザでも動作するようにエミュレートしています。</p>
<h3 id="calibre_link-163"><b>.hover()メソッド と .on() と "hover"擬似イベント</b></h3>
<p>少し前で.hover()メソッドを見ましたが、少し補足です。.hover()は、.mouseenter()と.mouseleave()の2つ分を少し簡略化して書けるという便利メソッドです。 あくまで、jQueryが特別に用意したものです。 ところで、この.hover()を.on()を使って書きたい場合はどうすれば良いでしょうか？ そもそもhoverなどというイベントは元々無いのですが、jQueryでは、擬似イベントとして"hover"というのを用意していました。 以下のようにして書けるというものでした。</p>
<div>
<pre><span>$</span>(<span>"___"</span>).<span>on</span>(<span>"hover"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>if</span> (<span>event</span>.<span>type</span> ===<span>"mouseenter"</span>) {</pre>
<pre><span>// mouseenterの処理</span></pre>
<pre> }<span>else</span> {</pre>
<pre><span>// mouseleaveの処理</span></pre>
<pre> }</pre>
<pre>});</pre></div>
<p>しかしこの"hover"という擬似イベントは、Ver.1.9にて<span>削除</span>されました。（.hover()メソッドの方は、引き続き使えます）ですので、今後は、.on()を使う場合は、次のように2つに分けて書くと良いでしょう。</p>
<div>
<pre><span>$</span>(<span>"___"</span>).<span>on</span>({</pre>
<pre><span>mouseenter</span>:<span>function</span> () {</pre>
<pre><span>// mouseenterの処理</span></pre>
<pre> },</pre>
<pre><span>mouseleave</span>:<span>function</span> () {</pre>
<pre><span>// mouseleaveの処理</span></pre>
<pre> }</pre>
<pre>});</pre></div>
<p>.on()の複数まとめてイベントを設定するやり方は、改めてみます。</p>
<p>もしくは、古いプログラムを移行する場合などは、単に"hover"の箇所を、"mouseenter mouseleave"と書き換えてもOKです。</p>
<div>
<pre><span>$</span>(<span>"___"</span>).<span>on</span>(<span>"mouseenter mouseleave"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>if</span> (<span>event</span>.<span>type</span> ===<span>"mouseenter"</span>) {</pre>
<pre><span>// mouseenterの処理</span></pre>
<pre> }<span>else</span> {</pre>
<pre><span>// mouseleaveの処理</span></pre>
<pre> }</pre>
<pre>});</pre></div>


<h3 id="calibre_link-164"><b>マウスイベント用の.toggle()<span><b>（Ver.1.9削除）</b></span></b></h3>
<p>こちらの.toggle()は、Ver.1.9にて<span>削除</span>されました。簡単に紹介だけしておきます。 また、名前が同じですが、アニメーション系の方の<a href="#calibre_link-213">.toggle()</a>は、引き続き使えます。（表示・非表示を操作するメソッドです。改めてみます）<br />
こちらの.toggle()では、マウスをクリックする度に、引数で指定した関数（いくつでも可）を順番に実行していくというものでした。</p>
<div>
<pre><span>$</span>(<span>"#div1"</span>).<span>toggle</span>(</pre>
<pre><span>function</span> () {</pre>
<pre><span>console</span>.<span>log</span>(<span>"1"</span>);</pre>
<pre> },</pre>
<pre><span>function</span> () {</pre>
<pre><span>console</span>.<span>log</span>(<span>"2"</span>);</pre>
<pre> }</pre>
<pre>);</pre></div>
<p>上記は、#div1要素をクリックする度に、1と2を順番に（交互に）出力します。</p>
</div>
<div id="calibre_link-324">
<h2 id="calibre_link-165">.on()とイベント委譲</h2>
<p>.on()メソッドのもっと色んな使い方を見て行きましょう。やや中級者向け部分でもあるため、よく分からなくても気にしなくて大丈夫です。</p>


<ul>
	<li><a href="#calibre_link-166">沢山の要素にイベントを付与したい時や動的に追加した要素もイベントの対象にしたい時</a></li>
	<li><a href="#calibre_link-167">イベント委譲（Event Delegation）の流れ</a></li>
</ul>
<h3 id="calibre_link-166"><b>沢山の要素にイベントを付与したい時や動的に追加した要素もイベントの対象にしたい時</b></h3>
<p>次の例を見てみましょう。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"li"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"yellow"</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"&lt;li&gt;与太郎&lt;/li&gt;"</span>).<span>appendTo</span>(<span>"ul"</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/event_delegate1.php">実際のサンプル</a></p>
<p>まず、1～3行目でLI要素に対してイベントを付与しています。クリックすると、背景を黄色にするというものです。 その後の4行目で、「与太郎」のLI要素を作り、UL要素に追加しています。 実際に名前の部分をクリックしてみて下さい。「与太郎」以外は、クリックすると背景が黄色になります。</p>
<p>さて、ここで上記の場合の問題点が1つ見えてきました。 イベント付与後に新たに要素を追加した場合、それにはイベントは付与されていません。今回の場合、「与太郎」のLI要素がそうです。 「与太郎」もクリックすると、背景が黄色になると期待したい所です。</p>
<p>また、もう1つ目に見えない問題点として、例えば今回の場合は名前が、3～4名で終わっていますが、もし1,000名いたらどうでしょうか？1,000名分（1,000要素）にイベントを付与しなければなりません。そもそもイベントが引き起こされるかも分からないのに（引き起こされたとしても一部かも）、大量のイベントを付与するのはメモリの無駄遣いで、ブラウザの読み込み速度にも影響があり得ます。 そこで、次のように書くと、両者の問題が一気に解決します。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"ul"</span>).<span>on</span>(<span>"click"</span>,<span>"li"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"yellow"</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"&lt;li&gt;与太郎&lt;/li&gt;"</span>).<span>appendTo</span>(<span>"ul"</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/event_delegate2.php">実際のサンプル</a></p>
<p>先ほどと比べて、1行目だけが変更になりました。どこが変わったかと言うと、まず最初の$("li")が$("ul")に変更になりました。そして、第2引数が"li"になり、function () 部分は、第3引数に移動になりました。 これだけで万事OKで、後から追加になった要素にもイベントの処理が可能で、また大量にイベントを割り当てることもありません。 この仕組みがどんな風になっているのかは、すぐ下で見ていきます。</p>
<p>ところで、今回の場合は、イベントハンドラ内のthisは何を指すでしょうか？それは、イベント処理の対象となるLI要素（＝クリックしたLI要素）です。</p>
<h3 id="calibre_link-167"><b>イベント委譲（Event Delegation）の流れ</b></h3>
<p>上記で見たようなものは、イベント委譲と呼ばれています。これは、上記の例では、各LI要素にはイベントを設定しないで、その親（先祖）要素にイベント関連の処理を委譲（依頼）しているからです。 個々の子供にイベントを設定しないで、親に監督役になってもらって面倒見てもらうイメージです。ですので、後から子供がいくら増えようが、イベントの監視等は全て親任せなので、特に関係無いのです。<br />

先の例で見ると、最初のサンプルでは、各LI要素ごとに個別にイベントが設定されます。対して、その後のサンプルでは、ULの親要素だけに対してイベントが設定されます。<br />

そもそも委譲（依頼）と言っても、どうやって委譲しているのでしょうか？実は、ここで「バブリング」の仕組みが使われています。イベントが発生すると、そのイベント発生源からイベントが伝播して、ドキュメントの上の方に上がっていくのでした。ですので、親のUL要素は、その子（子孫）要素で発生したイベントを捉えることができるのです。 次のようなケースで考えてみます。</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"man"</span><span>&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"man"</span><span>&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li</span><span>class</span>=<span>"woman"</span><span>&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"ul"</span>).<span>on</span>(<span>"click"</span>,<span>"li.man"</span>,<span>function</span> () {</pre>
<pre><span>// 何かの処理</span></pre>
<pre>});</pre></div>
<p>UL要素以下にあるmanクラス付きのLI要素をクリックした時のみ、イベントハンドラが実行されます。この時のイベント委譲の仕組みは、図で見ると次のようになります。「太郎」と「花子」のLI要素をクリックした時のイメージです。</p>
<p><img src="images/00000.jpeg" /></p>
<p>なお、今回は、ULとLIという分かりやすい親子関係でした。このイベントを付与する親（先祖）は、なるべく子から見て近くにあるのが理想です。そうでないと、無駄な処理が発生します。しかし実際の所、なかなかいい親役が見つからないケースもまれにあります。そんな時は、最悪、最上位の$(document)を親役としてやります。</p>
<div>
<pre><span>$</span>(<span>document</span>).<span>on</span>(<span>"click"</span>,<span>"xxx"</span>,<span>function</span> () {</pre>
<pre><span>// 何かの処理</span></pre>
<pre>});</pre></div>


</div>
<div id="calibre_link-335">
<h2 id="calibre_link-168">.on()のまとめ</h2>
<p>.on()は、今までも見てきましたが、大きく2つの構文に分けることができます。</p>


<ul>
	<li><a href="#calibre_link-169">.on( events [, selector] [, data] , handler )</a></li>
	<li><a href="#calibre_link-170">.on( events-map [, selector] [, data] )</a></li>
</ul>
<h3 id="calibre_link-169"><b>.on( events [, selector] [, data] , handler )</b></h3>
<p>括弧[]は、省略できることを表しています。こちらのタイプは、最大4つまで引数を取ることができます。eventsとhandler（イベントハンドラ）のみを指定するやり方は、一番最初に見たやり方です。その後に、selectorを指定するやり方をイベント委譲の所で見ました。復習がてら見てみましょう。</p>
<h4><b>.on( events, handler )</b></h4>
<p>個々の要素に対してイベントを設定するやり方です。一番基本的な形で、一番よく使われるかも知れません。eventsには、イベントタイプを指定します。"click"などです。複数のイベントタイプを半角スペース繋ぎで指定することもできます。例）"mouseenter mouseleave"。</p>
<h4><b>.on( events, selector, handler )</b></h4>
<p>こちらでは、イベント委譲ということで、沢山の要素や動的に追加された要素にも対応できる版でした。</p>
<h4><b>.on( events, [, selector] [, data] handler )<span><b>中級</b></span></b></h4>
<p>では、dataを指定するやり方を見てみましょう。上記の2タイプに、dataが加わった版です。dataを指定すると、イベントハンドラ（handler）に任意のデータ（情報）を渡すことができます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"taro"</span><span>value</span>=<span>"TARO"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"jiro"</span><span>value</span>=<span>"JIRO"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>function</span><span>greet</span>(<span>event</span>) {</pre>
<pre><span>alert</span>(<span>event</span>.<span>data</span>.<span>name</span> +<span>"です。"</span> +<span>event</span>.<span>data</span>.<span>birth</span> +<span>"出身です。"</span>);</pre>
<pre>}</pre>
<pre><span>$</span>(<span>"#taro"</span>).<span>on</span>(<span>"click"</span>, {<span>name</span>:<span>"太郎"</span>,<span>birth</span>:<span>"東京"</span>},<span>greet</span>);</pre>
<pre><span>$</span>(<span>"#jiro"</span>).<span>on</span>(<span>"click"</span>, {<span>name</span>:<span>"次郎"</span>,<span>birth</span>:<span>"埼玉"</span>},<span>greet</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/event_on_data.php">実際のサンプル</a></p>
<p>イベントを設定する際に、オブジェクト形式でデータを渡しています。そしてイベントハンドラ内では、渡されたデータは、イベントオブジェクトのevent.dataを使用して取り出すことができます。</p>
<p>この例では、オブジェクト形式でデータを渡しましたが、実際は何の形式でも構いません。ただ、もし引数の[selector]部分が不要な場合で、[data]部分に文字列のデータを渡す場合は、[data]部分が[selector]部分と間違えられないように、[selector]部分にはnullを指定して下さい。</p>
<p>余談ですが、上記のような場合は、個別の要素に情報を付加した方がすっきりするでしょう。HTML5のカスタム属性を利用すると、次のように書けます。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"TARO"</span><span>data-name</span>=<span>"太郎"</span><span>data-birth</span>=<span>"東京"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>value</span>=<span>"JIRO"</span><span>data-name</span>=<span>"次郎"</span><span>data-birth</span>=<span>"埼玉"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>function</span><span>greet</span>() {</pre>
<pre><span>var</span><span>me</span> =<span>$</span>(<span>this</span>);</pre>
<pre><span>alert</span>(<span>me</span>.<span>attr</span>(<span>"data-name"</span>) +<span>"です。"</span> +<span>me</span>.<span>attr</span>(<span>"data-birth"</span>) +<span>"出身です。"</span>);</pre>
<pre>}</pre>
<pre><span>$</span>(<span>"input[type=button]"</span>).<span>on</span>(<span>"click"</span>,<span>greet</span>);</pre></div>


<h3 id="calibre_link-170"><b>.on( events-map [, selector] [, data] )</b></h3>
<p>events-mapの箇所に、イベントタイプがキーで、イベントハンドラが値になった対をセットにしたオブジェクトを渡すことで、複数のイベントをまとめて設定することができます。.mouseenter()の説明でも見ましたが、次のような形です。</p>
<div>
<pre><span>$</span>(<span>"xxx"</span>).<span>on</span>({</pre>
<pre><span>mouseenter</span>:<span>function</span> () {</pre>
<pre><span>// mouseenterの処理</span></pre>
<pre> },</pre>
<pre><span>mouseleave</span>:<span>function</span> () {</pre>
<pre><span>// mouseleaveの処理</span></pre>
<pre> }</pre>
<pre>});</pre></div>


</div>
<div id="calibre_link-340">
<h2 id="calibre_link-171">.one()、off()、.trigger()、.triggerHandler()</h2>
<p>他のイベント関連のメソッドを見てみましょう。</p>


<ul>
	<li><a href="#calibre_link-172">.one()</a></li>
	<li><a href="#calibre_link-173">.off()</a></li>
	<li><a href="#calibre_link-174">.trigger()</a></li>
	<li><a href="#calibre_link-175">.triggerHandler()</a></li>
</ul>
<h3 id="calibre_link-172"><b>.one()</b></h3>
<p>このメソッドは、各要素につきイベント処理が1回のみ行われ、2回以上は行われないという関数です。1回実行されると、下記で見る.off()が自動で呼ばれるのと同じです。 構文（使い方）は、Ver. 1.7以降は、.on()の時と同じです。Ver. 1.7未満では、.on()から引数のselector部分が無い形と同じです。</p>
<h3 id="calibre_link-173"><b>.off()</b></h3>
<h4><b>.off( events [, selector] [, handler(eventObject)] )</b></h4>
<h4><b>.off( events-map [, selector] )</b></h4>
<p>.on()と同時に登場したメソッドで、付与されたイベントハンドラを削除します。 .on()の引数から、dataを除いた形の引数が指定できます。 引数を複数指定した場合、その複数分にマッチした分のみ、イベントハンドラが削除されます。</p>
<h3 id="calibre_link-174"><b>.trigger()</b></h3>
<p>ユーザーの動作に頼らずに、プログラム的にイベントを発生させることができます。<br />
下記の例で見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>style</span>=<span>"background-color: pink; width:100px; height:100px"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"taro"</span><span>value</span>=<span>"太郎"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#taro"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>alert</span>(<span>$</span>(<span>this</span>).<span>val</span>() +<span>"です"</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"div"</span>).<span>on</span>(<span>"mouseenter"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>$</span>(<span>"#taro"</span>).<span>trigger</span>(<span>"click"</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/event_trigger.php">実際のサンプル</a></p>
<p>このサンプルでは、JSの1～3行目で、#taroボタンをクリックした際のイベントを設定しています。<br />
そして、4～6行目では、ピンクのdiv要素にマウスオーバーした際に、#taroボタンをクリックした時と同じ動作を引き起こしています。5行目が肝心の箇所です。</p>
<p>実際にはユーザーがクリックした訳ではなくエミュレートされています。その為、イベントハンドラ内で取得できるイベントオブジェクトには、キーボード情報やマウス情報など、多くの情報はカットされています。</p>
<p>また、jQueryでは、通常のイベントタイプの他に、自分専用の<strong><b>カスタムイベント</b></strong>というのを設定することができます。上記の例では、"click"を指定しましたが、これを例えば、"mytaro"などと書き換える事ができます。</p>
<div>
<pre><span>$</span>(<span>"#taro"</span>).<span>on</span>(<span>"mytaro"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>alert</span>(<span>$</span>(<span>this</span>).<span>val</span>() +<span>"です"</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"div"</span>).<span>on</span>(<span>"mouseenter"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>$</span>(<span>"#taro"</span>).<span>trigger</span>(<span>"mytaro"</span>);</pre>
<pre>});</pre></div>
<p>"click"が、"mytaro"に書き換わったので、もはやユーザーがボタンをクリックしても何も起こりません。しかし、ピンクのdiv要素にマウスオーバーした際に、この"mytaro"イベントが引き起こされることになります。</p>
<h3 id="calibre_link-175"><b>.triggerHandler()</b></h3>
<p>.trigger()と似ているのですが、 .trigger()は、イベントそのものを引き起こすのに対して、.triggerHandler()は、イベントハンドラだけの処理をします。 言い換えると、.trigger()は、ユーザーが動作したのを極力真似るのに対し、.triggerHandler()は、その名前の通り、イベントハンドラだけを処理します。</p>
<p>上記を含めて、具体的には次のような違いがあります。</p>


<ul>
	<li>.triggerHandler()は、バブリングしません。</li>
	<li>.triggerHandler()は、ブラウザのデフォルトの動作をしません。（event.preventDefault()で止める動作）</li>
	<li>.trigger()は、マッチした全ての要素に動作するのに対し、.triggerHandler()は、最初のマッチした要素のみ動作</li>
	<li>.trigger()は、jQueryオブジェクトを返すが、.triggerHandler()は、実行した最後のイベントハンドラが返した値を返す。</li>
	
</ul>
</div>
<div id="calibre_link-8">
<h2 id="calibre_link-176">画像などの読み込みが完了してから処理を実行する</h2>
<p>「$ 又はjQueryの基本的な使い方」の章で、<a href="#calibre_link-9">「ドキュメント構築後に処理したい作業の登録用としてのjQuery()」</a>を見ました。軽く復習しておきますと、次のようになります。</p>
<div>
<pre><span>// 最もオススメパターン</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre>
<div></div>
<pre><span>// パターン2</span></pre>
<pre><span>$</span>(<span>document</span>).<span>ready</span>(<span>function</span>(<span>$</span>){</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre>
<div></div>
<pre><span>// パターン3</span></pre>
<pre><span>$</span>(<span>function</span>(<span>$</span>){</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre></div>
<p>軽く復習しておきますと、上記のようになります。最もオススメパターンを使い、function ($) の $ を書いておけば、他のライブラリとの$のバッティングを恐れずに、$を使うことができます。</p>
<p>さて、「画像などの読み込みが完了してから処理を実行したい」というケースもあると書きました。例えば、imgタグなどに高さが記述されていない場合、画像の読み込みが終わるまで、画像の高さが分かりません。そのような際に、jQueryでリストなどの高さを合わせるのは、画像の読み込みが全て終わってからになります。そこで、そのような場合は、代わりに以下のように書けばOKです。</p>
<div>
<pre><span>jQuery</span>(<span>window</span>).<span>on</span>(<span>"load"</span>,<span>function</span>() {</pre>
<pre><span>// 処理をここに書く</span></pre>
<pre>});</pre></div>
<p>これでOKではあるのですが、この場合、loadイベントを使っているので、先のjQuery(function ($) {の時のように、関数の引数で、$（=jQuery）を受け取ることができません。イベントなので、代わりにイベントオブジェクトを受け取ってしまいます。</p>
<p>そこで安全性も考慮すると、先ほどのjQuery()と組み合わせて、以下のようにすればよろしいでしょう。</p>
<div>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<div></div>
<pre><span>// その他の処理</span></pre>
<div></div>
<pre><span>$</span>(<span>window</span>).<span>on</span>(<span>"load"</span>,<span>function</span>() {</pre>
<pre><span>// 画像等全て読み終えた時の処理</span></pre>
<pre> });</pre>
<pre>});</pre></div>




</div>
<div id="calibre_link-285">
<h2 id="calibre_link-177">古いイベントメソッド</h2>
<p>Ver. 1.7より.on()メソッドが登場したため、以下で紹介するメソッドは古くなりました。これらは全て.on()を使って書くことができます。 しかし、Ver. 1.7未満のjQueryに対応する場合は、これらを使う事があるでしょう。<br />
それでは、これらのメソッドをjQueryに登場した順に軽く見てみます。</p>


<ul>
	<li><a href="#calibre_link-178">.bind()</a></li>
	<li><a href="#calibre_link-179">.live()</a><span>（Ver.1.9で削除済）</span></li>
	<li><a href="#calibre_link-180">.delegate()</a></li>
</ul>
<p>なお、Ver.3.0では、.bind()、.delegate()も「将来廃止予定」と位置づけられました。</p>



<h3 id="calibre_link-178"><b>.bind()</b></h3>
<h4><b>.bind( eventType [, eventData] , handler )</b></h4>
<p>上記の形式でイベントを設定します。引数が何を意味するかは、.on()のまとめの説明をご覧ください。<br />
  この.bind()を使ったタイプでは、イベント委譲はできません。<br />
  .bind()の反対のメソッドは、.unbind()です。<br />
例）</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"click_me"</span><span>value</span>=<span>"クリックしてね"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#click_me"</span>).<span>bind</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>alert</span>(<span>"お呼びしましたか？"</span>);</pre>
<pre>});</pre></div>


<h3 id="calibre_link-179"><b>.live()<span><b>（Ver.1.9で削除済）</b></span></b></h3>
<h4><b>.live( events [, eventData] , handler(eventObject) )</b></h4>
<p>.bind()だと、イベント設定後に動的に増えた要素に対応できないので、それに対応すべくできたのが.live()です。 もはや、削除済みなので、使うのは辞めましょう。.live()の反対のメソッドは、.die()です。</p>
<h3 id="calibre_link-180"><b>.delegate()</b></h3>
<h4><b>.delegate( selector, eventType, handler )　Ver. 1.4.2～</b></h4>
<h4><b>.delegate( selector, eventType, eventData, handler )　Ver. 1.4.3～</b></h4>
<h4><b>.delegate( selector, events )　Ver. 1.4.3～</b></h4>
<p>上記の形式でイベントを設定します。引数が何を意味するかは、.on()のまとめの説明をご覧ください。<br />
  こちらはイベント委譲に対応して、.live()の効率の悪さを解消したバージョンです。<br />
  .delegate()の反対のメソッドは、.undelegate()です。<br />
例）</p>
<div>
<pre><span>&lt;ul&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>花子<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"ul"</span>).<span>delegate</span>(<span>"li"</span>,<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"yellow"</span>);</pre>
<pre>});</pre></div>


</div>
<div id="calibre_link-297">
<h2 id="calibre_link-181">従来のイベント付与とjQuery流イベント付与</h2>
<p>jQueryのようなライブラリが流行る前は、下記のようなやり方でイベントを付与することが多かったです。（もちろん今でも可能ではあります）</p>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>function</span><span>doFunc</span>() {</pre>
<pre><span>// 何か処理する</span></pre>
<pre>}</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>onclick</span>=<span>"doFunc()"</span><span>value</span>=<span>"ボタン"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<p>一見すると直感的で、ある意味分かりやすいのですが、HTMLの構造にJavaScriptの振る舞い（behavior）が、混ざった書き方になってしまっています（インラインで、onclick="..."などと書いています）。その昔、CSSが無い時代に、HTMLで構造と装飾の両方を書いていたのに似ています。</p>
<p>上記のような書き方だと、沢山の要素にイベントを付与するのは大変ですし、そもそも構造と振る舞いが混ざっていて、メンテナンス性も落ちてきます。そこで、構造と振る舞いを分けるという考え方が生まれてきました。そして、この考え方は、Unobtrusive JavaScript（控えめなJavaScript）と呼ばれる考え方の中核を成すものでもあります。</p>
<p>実は、jQueryを使えば、自然とこの考え方に基いてイベントの付与もできます。上記をjQueryで書き換えると、例えば、以下のようになります。</p>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"#btn1"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// 何か処理する</span></pre>
<pre> });</pre>
<pre>});</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn1"</span><span>value</span>=<span>"ボタン"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<p>IDやクラスなどのセレクターを利用し、このように書くことで、HTMLの構造、JavaScriptの振る舞い（それと、CSSの装飾の3つ）を切り分けることができます。もはやクラス名などは、CSSの為だけに存在するものではないのです。</p>
<p>少し話は発展しますが、従来のやり方では、関数呼び出し時に、引数を渡すこともできましたが、jQuery流の場合、どのようにしたら良いでしょうか？これは、後の章で見ますが、カスタム属性というのを使えば容易に実現できます。</p>
<p>従来</p>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>function</span><span>doFunc</span>(<span>myname</span>) {</pre>
<pre><span>alert</span>(<span>"こんにちは、"</span> +<span>myname</span> +<span>"さん"</span>);</pre>
<pre>}</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>onclick</span>=<span>"doFunc('太郎')"</span><span>value</span>=<span>"ボタン"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<p>jQuery流</p>
<div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>jQuery</span>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>(<span>"#btn1"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>var</span><span>myname</span> =<span>$</span>(<span>this</span>).<span>data</span>(<span>"myname"</span>);</pre>
<pre><span>alert</span>(<span>"こんにちは、"</span> +<span>myname</span> +<span>"さん"</span>);</pre>
<pre> });</pre>
<pre>});</pre>
<pre><span>&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn1"</span><span>data-myname</span>=<span>"太郎"</span><span>value</span>=<span>"ボタン"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>


</div>
<div id="calibre_link-312">
<h1 id="calibre_link-368">8章　AJAX</h1>
<p>この章で登場するメソッド等の一覧です。</p>


<ul>
	<li><a href="#calibre_link-190">$.ajax()</a></li>

	<li><a href="#calibre_link-193">$.get()</a></li>
	<li><a href="#calibre_link-194">$.post()</a></li>
	<li><a href="#calibre_link-195">$.load()</a></li>

	<li><a href="#calibre_link-198">$.getJSON()</a></li>
	<li><a href="#calibre_link-199">$.getScript()</a></li>

	<li><a href="#calibre_link-201">.serialize()</a></li>
	<li><a href="#calibre_link-202">.serializeArray()</a></li>
	<li><a href="#calibre_link-203">$.param()</a></li>

	<li><a href="#calibre_link-204">$.ajaxSetup()（AJAX通信のデフォルト設定）</a></li>
	<li><a href="#calibre_link-206">AJAX関係のイベント</a></li>
<li><a href="#calibre_link-208">新・コールバック関数の指定方法</a></li>
    
</ul>
</div>
<div id="calibre_link-301">
<h2 id="calibre_link-183">AJAXとは？</h2>
<h3 id="calibre_link-184"><b>AJAXとは？</b></h3>
<p>Ajaxとは、ページのリフレッシュを伴わずに、JavaScriptによりデータ交換する技術を言います。 従来の方法では、新しいコンテンツを取得するために、ページ全体をリフレッシュしていたために、無駄な部分もありました。 しかし、AJAXでは、必要な部分のみ取得すれば済みます。そして、通常、その取得したデータを元にページの一部を更新します。 これらのテクニック全体総称して、AJAXとも呼ばれます。</p>
<p>また、AJAXの特徴の1つに、非同期というものがあります。非同期の処理は、その動作中、ブラウザの他の動作をブロックしないため、ブラウザが固まるという現象を防ぐことができます。</p>
<p>また、AJAXでは、見ているページと同じドメイン（同じプロトコル、ポート、ホスト）のサーバと通信しなければならないという決まりがあります。 そうでないとエラーになってしまいます。これは、セキュリティ上による制限です。（但し、最新の技術を使った場合は除く）</p>
<p>ちなみに、AJAXは、「Asynchronous JavaScript and XML」の頭文字を取ったものですが、ここでXMLとありますが、データのやり取りにXMLが必須ではありません。 あくまで任意です。現在では、データのやり取りには、XMLよりもJSONを使うことが多いでしょう。 この用語ができた当時、XMLが流行語になっていたので、そのまま付いてしまった名残です。</p>
<h3 id="calibre_link-185"><b>jQueryのAJAX</b></h3>
<p>jQueryを使わないで、AJAXの処理を記述しようとすると、結構煩雑なものになります。しかし、jQueryのAJAX用の関数（$.ajax()）を使うことで、シンプルで直感的に書くことができます。 更にjQueryでは、この $.ajax() をも更に簡単に使えるようにしたショートカット用の関数もあります。<br />
まとめると、次のようになります。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>タイプ</b></th>
<th><b>関数（orメソッド）</b></th>
</tr>


<tr>
<td>オールラウンド</td>
<td>$.ajax()</td>
</tr>
<tr>
<td>ショートカット</td>
<td>.load()<br />$.get()<br />$.post()<br />$.getJSON()<br />$.getScript()</td>
</tr>
<tr>
<td>その他ヘルパー</td>
<td>$.param()<br />.serialize()<br />.serializeArray()</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>その他ヘルパーは、直接AJAXとは関係ないかも知れませんが、AJAXを使う際の補助的な関数になります。</p>
<p>通常、jQueryの解説書では、より簡単に使いこなせるショートカット用の関数から解説に入ることが多いですが、本書ではAJAXの本質を見失わないよう、オールラウンドタイプの $.ajax() から解説に入ります。 最初は少し苦労して、後で楽しましょう。</p>
</div>
<div id="calibre_link-334">
<h2 id="calibre_link-186">AJAX前置き</h2>
<h3 id="calibre_link-187"><b>AJAX前置き</b></h3>
<p>まず、ajaxは、サーバにデータを「送信（要求）」して、そしてサーバからデータを「受け取る（応答）」処理の2つがあります。</p>
<p>データを送信する際には、その送信方式によりGETとPOSTがあります。 また、URLを指定します。また、サーバとやり取りするためのデータを指定します。 データを受信する際には、サーバから受信結果を示すステータスコードや必要なデータが送られてきます。</p>
<p>イメージ図</p>
<p><img src="images/00002.jpeg" /></p>
<p>送信方式のGETとPOSTについては、下の囲みをご覧ください。上記の図では、送信時の「データ」が、別物として描いてありますが、GETの場合は、そもそもURLにくっ付いて送信されます。 ステータスコードとは、よく見る 「404 Not Found」などの事です。</p>
<div>GETとPOSTの違い<br />
<br />
（AJAXに限った話ではなく）データの送信方式には、GETとPOSTがあります（規格上は他にもあります）。GETは、普通にページを閲覧（リクエスト）する際に使用します。
その事によりサーバ内へのデータへの影響（副作用）が無いものです。

例えば、ネットサーフィンをしている際に、あっちこっち見たりしますが、それらは通常、GETの方式です。

一方、POSTは、問い合わせフォームやデータ（例、ブログ）の登録、削除、変更などを伴うリクエストの際に使用します。

何かサーバ内のデータに副作用を及ぼすものです。なのでよくブラウザでページを更新しようとすると「このページを再表示するには、以前送信した情報を再送信する必要があります」などの確認ダイアログが表示されたりします。POSTの結果は、ブラウザにキャッシュされるべきものではありません。<br />
<br />
データの受送信という意味ではどちらも同じですが、GETは、サーバからデータを取ってくる（GET）事に主眼があり、POSTは、サーバにデータを投げて（投稿して）（POST）、サーバに何か処理してもらう事に主眼があります。

GETとPOSTを混同して使っても、実害は少ないかも知れませんが、そのような意図を理解した上で、然るべき方を使いましょう。
<br /><br />
なお、GETの場合はデータ（パラメータ）はURLに埋め込まれる、POSTの結果はブラウザにキャッシュされない（されるべきものではない）、などの特徴の違いもあります。</div>


</div>
<div id="calibre_link-346">
<h2 id="calibre_link-188">$.ajax() 簡単なサンプル</h2>
<h3 id="calibre_link-189"><b>$.ajax() 簡単なサンプル</b></h3>
<p>$.ajax() の詳しい解説は改めて見るとして、まずはどんな感じかをサンプルで掴んでおきましょう。</p>
<h4><b>サンプル1、テキストデータを取得して、コンソール画面に表示する</b></h4>
<p>ここでは、ボタンを押すとAJAXでsample.txtを取得して、その中身をconsole.log() で表示するものを作ってみます。sample.txtの中身は、UTF-8で、「やせ蛙　負けるな一茶　これにあり」と記載してあります。（基本的にAJAXでは、UTF-8を使用します）<br />
以下のようになります。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"sample1"</span><span>value</span>=<span>"サンプル1"</span><span>&gt;</span></pre>
<pre><span>&lt;form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#sample1"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'sample1.txt'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>dataType</span>:<span>"text"</span>,</pre>
<pre><span>success</span>:<span>function</span> (<span>data</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>data</span>);</pre>
<pre>  }</pre>
<pre> });</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/ajax_sample1.php">実際のサンプル</a></p>


<h4><b>サンプル2、JSONデータを取得し、コンソール画面に表示する</b></h4>
<p>JSONというJavaScriptにおけるオブジェクトの表記法があります。これを利用することでサーバとのデータのやり取りがXMLよりも軽く行えます。 ここでは、ボタンを押すとAJAXでsample2.jsonを取得して、その中身を利用してconsole.log() で表示するものを作ってみます。<br />
以下のようになります。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"sample2"</span><span>value</span>=<span>"サンプル2"</span><span>&gt;</span></pre>
<pre><span>&lt;form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#sample2"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'sample2.json'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>dataType</span>:<span>"json"</span>,</pre>
<pre><span>success</span>:<span>function</span> (<span>data</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>"こんにちは、"</span> +<span>data</span>.<span>sei</span> +<span>"　"</span> +<span>data</span>.<span>mei</span> +<span>" さん"</span>);</pre>
<pre>  }</pre>
<pre> });</pre>
<pre>});</pre></div>
<p>sample2.jsonの中身。</p>
<div>
<pre>{<span>"sei"</span>:<span>"Yamada"</span>,<span>"mei"</span>:<span>"Tarou"</span>}</pre></div>
<p><a href="http://jquery-master.net/examples/ajax_sample2.php">実際のサンプル</a></p>



<h4><b>サンプル3、サーバにデータを送受信</b></h4>
<p>少し小難しくなりますが、最後にサーバとデータをやり取りする例を見てみましょう。
  サーバ側（PHP）に詳しくない方は、雰囲気だけ掴んで下さい。
ボタンを押すと、{myname: 'yamada', mypass: 'abcde'} というデータがサーバ側に飛びます。このデータをサーバ側で受け取り、ログインもどきの処理をして、結果を返すサンプルです。 ここでは、mynameとmypassは、固定の値となっていますが、実務では、フォームからの入力値などを利用したりします。</p>
<div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"sample3"</span><span>value</span>=<span>"サンプル3"</span><span>&gt;</span></pre>
<pre><span>&lt;form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#sample3"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'sample3.php'</span>,</pre>
<pre><span>type</span>:<span>"POST"</span>,</pre>
<pre><span>dataType</span>:<span>"json"</span>,</pre>
<pre><span>data</span>: {</pre>
<pre><span>"myname"</span>:<span>'yamada'</span>,</pre>
<pre><span>"mypass"</span>:<span>'abcde'</span></pre>
<pre>  },</pre>
<pre><span>success</span>:<span>function</span> (<span>data</span>) {</pre>
<pre><span>if</span> (<span>data</span>.<span>result</span> ===<span>"OK"</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>data</span>.<span>message</span>);</pre>
<pre>   }<span>else</span> {</pre>
<pre><span>console</span>.<span>log</span>(<span>"ログイン失敗"</span>);</pre>
<pre>   }</pre>
<pre>  }</pre>
<pre> });</pre>
<pre>});</pre></div>
<p>PHP↓</p>
<div>
<pre><span>$ret</span> =<span>array</span>();</pre>
<pre><span>$ret</span>[<span>'result'</span>] =<span>"NG"</span>;</pre>
<div></div>
<pre><span>// ログインもどき</span></pre>
<pre><span>if</span> (<span>$_POST</span>[<span>'myname'</span>] ==<span>"yamada"</span><span>and</span><span>$_POST</span>[<span>'mypass'</span>] ==<span>"abcde"</span>) {</pre>
<pre><span>$ret</span>[<span>'result'</span>] =<span>"OK"</span>;</pre>
<pre><span>$ret</span>[<span>'message'</span>] =<span>"ようこそ"</span> .<span>$_POST</span>[<span>'myname'</span>] .<span>"さん"</span>;</pre>
<pre>}</pre>
<div></div>
<pre><span>header</span>(<span>"Content-Type: application/json; charset=utf-8"</span>);</pre>
<pre><span>echo</span><span>json_encode</span>(<span>$ret</span>);</pre></div>
<p><a href="http://jquery-master.net/examples/ajax_sample3.php">実際のサンプル</a></p>



</div>
<div id="calibre_link-5">
<h2 id="calibre_link-190">$.ajax() 解説</h2>
<p>$.ajax() はjQueryのAJAXの根幹を成すものです。それらのショートカット関数として、$.load()、$.get()、$.post() などがあります。</p>
<h3 id="calibre_link-191"><b>$.ajax() 解説</b></h3>
<h4><b>jQuery.ajax( url [, settings ] )　Ver. 1.5～<br /><b></b>
jQuery.ajax( [settings ] )　Ver. 1.0～</b></h4>
<p>まず、2つの構文があります。1つ目は、urlを第1引数に直接指定するタイプで、2つ目は、urlをsettingsの中に含めてしまうタイプです。</p>
<p>呼び出し方は、普段のメソッド形式ではなく、jQueryのユーティリティ関数として作られています。つまり、何かのjQueryオブジェクトに対してメソッドを呼び出すものではなく、汎用的な関数になります。（ユーティリティ関数については、また見ます）</p>
<p>$.ajax() と書くと一瞬戸惑うかも知れませんが、jQuery.ajax() と書くと、しっくり来るでしょうか。（2つは同じものです。本書では、$.ajax() の方を使います）</p>
<p>settingsには、オブジェクト形式でオプションを設定します。オプションは、全て非必須ですが、実用的に使用するには、幾らか指定します。実はこのオプションは、非常に多くあるのですが、 それらを全て紹介していると圧倒されてしまいますので、本当に大事なもののみ紹介します。（ここで紹介しないものは、中上級レベルのプログラマが更に細かく制御したい時に使う位です）</p>
<p>以下がオプションになります。便宜上、送信向けのオプションと受信向けオプションで色分けしています。<br />
（上が送信、下が受信）</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>プロパティ</b></th>
<th><b>簡単な意味</b></th>
</tr>
<tr>
<td>url</td>
<td>通信するURL（デフォルト、現在開いているURL）</td>
</tr>
<tr>
<td>type</td>
<td>'GET' か 'POST' か（デフォルト、'GET'）<br />（typeと言われても下記のdataTypeと紛らわしいですね。Ver. 1.9～からは、より明確なmethodという名前も使用できます）</td>
</tr>
<tr>
<td>data</td>
<td>サーバに送信するデータ。文字列（クエリ文字列）やオブジェクト形式で指定可能</td>
</tr>
<tr>
<td>dataType</td>
<td>受信時に期待するデータのタイプ。以下から指定可能。<br />'text', 'html', 'xml', 'json', 'jsonp', 'script'<br />省略時は、jQueryによる最適な値を自動検出。</td>
</tr>
<tr>
<td>beforeSend</td>
<td>AJAX通信開始前に呼ばれるコールバック関数を指定</td>
</tr>
<tr>
<td>success</td>
<td>成功時に呼ばれるコールバック関数を指定</td>
</tr>
<tr>
<td>error</td>
<td>エラー時に呼ばれるコールバック関数を指定</td>
</tr>
<tr>
<td>complete</td>
<td>AJAX終了時に呼ばれるコールバック関数を指定。<br />AJAXがsuccess又はerrorで終わっても、いずれにせよこれらのコールバックよりも後に呼ばれる。</td>
</tr>
<tr>
<td>timeout</td>
<td>タイムアウトしてエラーとして処理されるまでの時間（ミリ秒）。デフォルトは、0（＝制限無し）</td>
</tr>
<tr>
<td>cache</td>
<td>GET方式の際に、falseにすることで、毎回最新のデータを取りに行く（キャッシュしない）。デフォルト、true（キャッシュする）</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>普通、関数では戻り値で結果を受け取りますが、AJAXでは、非同期という性質上、<strong><b>サーバから受信するデータを戻り値として取得することができません。その為、コールバック関数というものを使い、サーバから受け取ったデータを処理します。</b></strong></p>
<p>少し砕いて言えば、AJAXの非同期はサーバに問いかけしても、そのサーバからの返答を待たずして次の処理へ移動してしまう為、例えば、var data = $.ajax(...); のような形でサーバからの返答を受け取る事はできません。代わりに返答が返ってきた時点で処理を実行する関数を引数で指定しておく、という事になります。</p>
<p>そのサーバから返ってきたデータを何のデータ形式と見なしたいかを上記のdataTypeで指定します。 もしあなたが、単なるテキストを受信する予定なら、'text' でOKです。もし、JSON形式のデータを受信予定なら、'json' と指定することで、受信したデータをJSONオブジェクトとして取得できます。<br />
ということで、dataTypeをまとめてみましょう。（色々出てきますが、'text'、'html'、'json'辺りだけ覚えておけば大丈夫です）</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>dataTypeの値</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>text</td>
<td>サーバからのデータをplain textのまま返す</td>
</tr>
<tr>
<td>html</td>
<td>HTMLデータをplain textのまま返す。内包するscriptタグは、DOMに挿入される時に評価される。<br />（後述するload() は、このタイプを使用）</td>
</tr>
<tr>
<td>xml</td>
<td>サーバから送られるデータがXMLデータの時に指定。コールバック関数の第1引数に渡されるデータは、ドキュメントオブジェクトになる。</td>
</tr>
<tr>
<td>json</td>
<td>サーバから送られるデータがJSONタイプの時に指定。コールバック関数の第1引数に渡されるデータは、JSON解析後のオブジェクトになる。（自分で$.parseJSON()等する必要無し）<br />後述する $.getJSON() は、このタイプを使用</td>
</tr>
<tr>
<td>jsonp</td>
<td>JSONP使用時に指定。詳細は、本書では略。</td>
</tr>
<tr>
<td>script</td>
<td>指定したURLは、JSスクリプトとみなされ、コールバック呼び出し前に実行されます。<br />（後述する $.getScript() は、このタイプを使用）<br />（このタイプは、通常のAJAX（XMLHttpRequest）ではなく、scriptタグを利用するため、同一ドメインの制限を回避できます）</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>dataTypeは、指定しなくても自動でjQueryが判断するよう努めますが、できうる限り自分で指定しましょう。</p>
<p>さて、それではコールバック関数を見て行きましょう。</p>



<h4><b>beforeSend(jqXHR, settings)</b></h4>
<p>便宜上載せていますが、中級以上向けプロパティです。 これで設定するコールバック関数を使うとカスタムヘッダーなどを設定したり、また通信前の前処理も行えます。return false;することで、AJAX通信自体をキャンセルすることができます。<br />
引数もさらっと見ておきましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>引数</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>jqXHR</td>
<td>XMLHttpRequestを拡張したjQuery用jqXHR（Ver. 1.4系以下は、XMLHttpRequest）

</td>
</tr>
<tr>
<td>settings</td>
<td>オプションで指定したオブジェクト</td>
</tr>
</tbody>
</table>


<h4><b>success(data, textStatus, jqXHR)</b></h4>
<p>以下の意味になります。一番重要なのは、第1引数で、他は記憶の隅に置いておきましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>引数</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>data</td>
<td>サーバから受信したデータ。<br />データの形式は、先述したようにdataTypeの指定（指定がない時は、jQueryの自動検出機能）に依存します。<br /><br />
	dataTypeが、'xml' の時は、ドキュメントオブジェクト<br />
	'json' や 'jsonp' の時は、JSONの解析結果によるオブジェクト<br />
	'script' の時は、読み込まれたscriptの内容（テキスト）。（スクリプトは既に実行済み）<br />
	それら以外は、取得したそのままの内容（テキスト）<br />
</td>
</tr>
<tr>
<td>textStatus</td>
<td>jQuery独自のステータスコード。通常は、'success'<br />（notmodifiedを指定した時は、これに限らず）</td>
</tr>
<tr>
<td>jqXHR</td>
<td>XMLHttpRequestを拡張したjQuery用jqXHR（Ver. 1.4系以下は、XMLHttpRequest）</td>
</tr>
</tbody>
</table>


<h4><b>error(jqXHR, textStatus, errorThrown)</b></h4>
<p>以下の意味になります。さらっと見ておきましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>引数</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>jqXHR</td>
<td>XMLHttpRequestを拡張したjQuery用jqXHR（Ver. 1.4系以下は、XMLHttpRequest）

</td>
</tr>
<tr>
<td>textStatus</td>
<td>jQuery独自のステータスコード。候補は、'timeout', 'error', 'abort', 'parsererror'<br />'parsererror' は、JSONやXMLを指定した際の解析エラー時に発生。<br />ちなみに、'parseerror' ではなく、'parsererror'</td>
</tr>
<tr>
<td>errorThrown</td>
<td>投げられたエラー。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>dataTypeに 'script' を指定した際の構文エラーなどは黙殺され、errorではなく、successコールバックが呼ばれます。</p>



<h4><b>complete(jqXHR, textStatus)</b></h4>
<p>こちらもさらっと見ておきましょう。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>引数</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>jqXHR</td>
<td>XMLHttpRequestを拡張したjQuery用jqXHR（Ver. 1.4系以下は、XMLHttpRequest）

</td>
</tr>
<tr>
<td>textStatus</td>
<td>jQuery独自のステータスコード。<br />候補は、'success', 'notmodified', 'timeout', 'error', 'abort', 'parsererror'</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>以上が$.ajax()の解説になります。上記を踏まえて上で、再度先のサンプルを確認してみて下さい。</p>




</div>
<div id="calibre_link-283">
<h2 id="calibre_link-192">$.get()、$.post()</h2>
<p>$.ajax() が分かってしまえば、こちらは簡単です。
$.ajax() の簡易版（ショートカット）として存在します。</p>


<ul>
	<li><a href="#calibre_link-193">$.get()</a></li>
	<li><a href="#calibre_link-194">$.post()</a></li>
</ul>
<h3 id="calibre_link-193"><b>$.get()</b></h3>
<h4><b>$.get( url [, data] [, success(data, textStatus, jqXHR)] [, dataType] )</b></h4>
<p>$.get() は、$.ajax() の簡易版で、GET方式で送信（リクエスト）します。$.ajax() との比較を下の図に示しました。</p>
<p><img src="images/000036.gif" /></p>
<p>第2～第4引数は、省略可能です。例えば、3番目のsuccessコールバックだけを使用することもできます。</p>
<p>簡単なサンプルです。hoge/test.htmlのURLで取得したデータを、$('.result') にHTMLとして入れ込みます。下記では、urlとsuccessのみを使用する為、successが2番目の引数に配置されています。</p>
<div>
<pre><span>$</span>.<span>get</span>(<span>'hoge/test.html'</span>,<span>function</span>(<span>data</span>) {</pre>
<pre><span>$</span>(<span>'.result'</span>).<span>html</span>(<span>data</span>);</pre>
<pre>});</pre></div>



<h4><b>$.get( [settings ] )　Ver. 1.12 / 2.2～</b></h4>
<p>$.get()は従来、$.ajax()とは異なる形式で引数を受け取っていましたが、「それではややこしい」という事で、Ver.1.12 / 2.2からは、$.ajax()と同様に第1引数でオブジェクト形式のオプションも受け取ることができるようになりました。指定方法は、$.ajax()と同様です。urlだけは必須となります。</p>




<h3 id="calibre_link-194"><b>$.post()</b></h3>
<h4><b>$.post( url [, data] [, success(data, textStatus, jqXHR)] [, dataType] )</b></h4>
<p>上記の.get()が、POST方式になった版で、他は一緒です。</p>


<h4><b>$.post( [settings ] )　Ver. 1.12 / 2.2～</b></h4>
<p>こちらも同様です。</p>




</div>
<div id="calibre_link-294">
<h2 id="calibre_link-195">.load()</h2>
<h3 id="calibre_link-196"><b>.load()</b></h3>
<p>.load()は、指定したURLからコンテンツをAJAXにて取得し、その取得したコンテンツをHTMLとして、各マッチした要素内に入れ込む（置換）するメソッドです。<br />
データが置換されるのは、成功時のみです。構文は、以下の通りです。</p>
<h4><b>.load( url [, data] [, complete(responseText, textStatus, XMLHttpRequest)] )</b></h4>
<p>第1引数だけでも十分役立ちますが、第2、第3も指定できます。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>引数</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>url</td>
<td>取得したいコンテンツのURLを指定します。もしコンテンツの特定部分のみを置換対象にしたい場合は、URLの後に半角スペースを空けてセレクターを書くと、そのセレクターにマッチする部分のみに限定できます。</td>
</tr>
<tr>
<td>data</td>
<td>サーバに送信するデータを指定することができます。query string形式の文字列か、普通の{キー: 値} 形式のオブジェクトを渡せます。文字列（又は未指定）で渡した時は、GET方式、オブジェクト形式で渡した時は、POST方式で送信されます。</td>
</tr>
<tr>
<td>complete</td>
<td>各マッチした要素ごとに、HTMLの置換後に呼び出されるコールバック関数です。（リクエストが失敗した場合も呼び出される）。関数内でthisは、各要素になります。</td>
</tr>


</tbody>
</table>
<p>&nbsp;</p>
<p>簡単なサンプルを見てみましょう。</p>
<div>
<pre><span>//'hoge/test.html' のデータを '#result' 部分に入れ込みます。（置換）</span></pre>
<pre><span>$</span>(<span>'#result'</span>).<span>load</span>(<span>'hoge/test.html'</span>);</pre>
<div></div>
<pre><span>// 'hoge/test.html' のデータの内、#containerにマッチする部分を</span></pre>
<pre><span>// '#result' 部分に入れ込みます。（置換）</span></pre>
<pre><span>$</span>(<span>'#result'</span>).<span>load</span>(<span>'hoge/test.html #container'</span>);</pre></div>
<p>以下、補足情報です</p>
<p>【補足情報1、スクリプトの実行】<br />
取得したコンテンツにスクリプトを含む場合、url部分にセレクターも指定している場合は、スクリプトは実行されず、一方、セレクターは指定しないでURLのみの時は、スクリプトは実行されます。</p>
<p>【補足情報2】<br />
jQueryが、取得したドキュメントを解析する際に、ブラウザがhtml, title, headの要素などをカットしてしまうことがあるので、必ずしも実際のドキュメントと同一とは限りません。</p>
<p>【補足情報3】<br />
AJAXではなくイベント関係の<a href="#calibre_link-149">.load()</a>も存在しますが、そちらはVer.3.0にて削除となります。</p>


</div>
<div id="calibre_link-317">
<h2 id="calibre_link-197">$.getJSON()、$.getScript()</h2>
<p>続けて、以下の2つも見て行きましょう。</p>


<ul>
	<li><a href="#calibre_link-198">$.getJSON()</a></li>
	<li><a href="#calibre_link-199">$.getScript()</a></li>
</ul>
<h3 id="calibre_link-198"><b>$.getJSON()</b></h3>
<h4><b>$.getJSON( url [, data] [, success(data, textStatus, jqXHR)] )</b></h4>
<p>$.getJSON()は、<a href="#calibre_link-193">$.get()</a>で、第4引数のdataTypeを 'json'にした場合と同じです。ショートカット用の関数です。</p>
<p>サンプル</p>
<div>
<pre><span>$</span>.<span>getJSON</span>(<span>'hoge/test.html'</span>,<span>function</span>(<span>data</span>) {</pre>
<pre><span>// dataは、JSON解析済みのデータ</span></pre>
<pre><span>console</span>.<span>log</span>(<span>"こんにちは、"</span> +<span>data</span>.<span>sei</span> +<span>"　"</span> +<span>data</span>.<span>mei</span> +<span>" さん"</span>);</pre>
<pre>});</pre></div>
<p>コールバック関数の第1引数で受け取るデータは、JSON解析済みデータになることに留意してください。</p>
<p>JSONは、JavaScriptよりも構文が厳しめです。構文エラーがある場合は黙って終了します。<br />
  そのため、手動でJSONデータの編集を行う際は、注意しましょう。<br />
JSONでは、</p>


<ul>
	<li>シングルクォーテーション（'）は使えません。ダブルクオーテーション（"）を使います。</li>
	<li>キーもダブルクオーテーション（"）で囲む必要があります。</li>
	<li>コメントも書けません。</li>
</ul>
<div>
<pre><span>// OK</span></pre>
<pre>{<span>"sei"</span>:<span>"Yamada"</span>,<span>"mei"</span>:<span>"Tarou"</span>}</pre>
<div></div>
<pre><span>// NG</span></pre>
<pre>{<span>sei</span>:<span>"Yamada"</span>,<span>mei</span>:<span>"Tarou"</span>}</pre>
<div></div>
<pre><span>// NG</span></pre>
<pre>{<span>'sei'</span>:<span>'Yamada'</span>,<span>'mei'</span>:<span>'Tarou'</span>}</pre>
<div></div>
<pre><span>// NG</span></pre>
<pre>{<span>"sei"</span>:<span>"Yamada"</span>,<span>"mei"</span>:<span>"Tarou"</span>}<span>//コメント</span></pre></div>
<p>手動編集する際は、<a href="http://jsonlint.com/">JSONLint</a>なども役に立ちます。</p>
<h3 id="calibre_link-199"><b>$.getScript()</b></h3>
<h4><b>$.getScript( url [, success(script, textStatus, jqXHR)] )</b></h4>
<p>指定したURLから動的にスクリプトを取得して、実行します。（グローバル領域で実行されます）<br />
  第2引数に、成功時のコールバック関数を指定できます。スクリプト実行後に呼び出されます。<br />
AJAX以外の技術も利用するため、URLは、同じドメインに制限されません。</p>
<div>
<pre><span>$</span>.<span>getScript</span>(<span>"http://example.com/script.js"</span>);</pre></div>


</div>
<div id="calibre_link-321">
<h2 id="calibre_link-200">.serialize()、.serializeArray()、$.param()<span>中級</span></h2>
<p>ここで見る .serialize() と .serializeArray() は、直接AJAXとは関係ありませんが、AJAXを使用する際に役立ちます。具体的には、フォームでユーザーからの入力を受け付けた際、それらの情報をAJAXで送信するためのデータを収集してくれます。</p>


<ul>
	<li><a href="#calibre_link-201">.serialize()</a></li>
	<li><a href="#calibre_link-202">.serializeArray()</a></li>
	<li><a href="#calibre_link-203">$.param()</a></li>
</ul>
<h3 id="calibre_link-201"><b>.serialize()<span><b>中級</b></span></b></h3>
<p>フォームの要素からクエリ文字列を生成します。URLエンコードもされます。 "successful controls"とみなされた要素のみ対象となります。例えば、選択されていないチェックボックスやラジオボタン、disabledに設定された要素などは、対象になりません。また、ファイル選択ボックスも対象にはなりません。データの収集には、name属性が使用されますので、忘れずに設定して下さい。</p>
<p>サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;form</span><span>id</span>=<span>"seri_form"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"text"</span><span>name</span>=<span>"mytext"</span><span>/&gt;</span></pre>
<div></div>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"mychk"</span><span>value</span>=<span>"strawberry"</span><span>/&gt;</span>いちご<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"mychk"</span><span>value</span>=<span>"orange"</span><span>/&gt;</span>みかん<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"checkbox"</span><span>name</span>=<span>"mychk"</span><span>value</span>=<span>"apple"</span><span>/&gt;</span>りんご<span>&lt;/label&gt;</span></pre>
<div></div>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"myrdo"</span><span>id</span>=<span>"radio"</span><span>value</span>=<span>"taro"</span><span>/&gt;</span>太郎<span>&lt;/label&gt;</span></pre>
<pre><span>&lt;label&gt;&lt;input</span><span>type</span>=<span>"radio"</span><span>name</span>=<span>"myrdo"</span><span>id</span>=<span>"radio2"</span><span>value</span>=<span>"jiro"</span><span>/&gt;</span>次郎<span>&lt;/label&gt;</span></pre>
<div></div>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"seri_btn"</span><span>value</span>=<span>"表示"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#seri_btn"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> (<span>event</span>) {</pre>
<pre><span>var</span><span>data</span> =<span>$</span>(<span>"#seri_form"</span>).<span>serialize</span>();</pre>
<pre><span>alert</span>(<span>data</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/ajax_serialize.php">実際のサンプル</a></p>
<p><strong><b>そして重要なことですが、</b></strong>このデータは、$.ajax() のdataプロパティ又は $.get()、$.post()、$.load() などのdata引数に直接渡すことができます。</p>
<p>また、使用頻度低そうですが、フォーム要素の一部分のみを .serialize() することも可能です。<br />例）</p>
<div>
<pre><span>$</span>(<span>"input, textarea, select"</span>).<span>serialize</span>();</pre></div>


<h3 id="calibre_link-202"><b>.serializeArray()<span><b>中級</b></span></b></h3>
<p>使い方は、上記の.serialize()と同じです。但しこちらは、URLエンコードは行いません。.serializeArray()の場合、返されるデータが文字列ではなく、オブジェクトの配列形式で返されます。 以下のような形式の配列が返ります。</p>
<div>
<pre>[</pre>
<pre>{<span>name</span>:<span>"sei"</span>,<span>value</span>:<span>"Yamada"</span>},</pre>
<pre>{<span>name</span>:<span>"mei"</span>,<span>value</span>:<span>"Taro"</span>}</pre>
<pre>]</pre></div>
<p>以下のような単純なオブジェクト形式<strong><b>ではない</b></strong>ことに注意して下さい。</p>
<div>
<pre><span>// こういう形式ではない</span></pre>
<pre>{</pre>
<pre><span>sei</span>:<span>"Yamada"</span>,</pre>
<pre><span>mei</span>:<span>"Taro"</span></pre>
<pre>}</pre></div>
<p>そもそも何故単純なオブジェクト形式ではなく、少しややこしいタイプなのか疑問に思うかも知れませんが、これは、チェックボックスなどでは同じ名前で複数存在し得るため、それに対応させるべくこのような構造になっています。</p>
<p>.serializeArray() で収集したデータに後出しで情報を付け足したい場合は、例えば次のようにします。</p>
<div>
<pre><span>data</span> =<span>$</span>(<span>"#myform"</span>).<span>serializeArray</span>();</pre>
<pre><span>data</span>.<span>push</span>({<span>name</span>:<span>"mode"</span>,<span>value</span>:<span>"update"</span>});</pre></div>
<p><strong><b>そして重要なことですが、</b></strong>.serialize() と同様、このデータ形式は、$.ajax() のdataプロパティ又は $.get()、$.post()、$.load() などのdata引数に直接渡すことができます。</p>
<div>
<pre><span>var</span><span>data</span> =<span>$</span>(<span>"#myform"</span>).<span>serializeArray</span>();</pre>
<div></div>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>"abc.php"</span>,</pre>
<pre><span>type</span>:<span>"POST"</span>,</pre>
<pre><span>data</span>:<span>data</span>,<span>// ここ</span></pre>
<pre><span>dataType</span>:<span>"text"</span></pre>
<pre>});</pre></div>
<p>（補足1）<br />
.serializeArray() 自体は、URLエンコードは行いませんが、この形式をAJAXのdataプロパティに引き渡すと、jQueryが内部でURLエンコードを行なって送信するため、URLエンコードを意識しないで済みます。</p>
<p>（補足2）<br />
本家ドキュメントでは、dataに引き渡せるのは、クエリ文字列又は単純なオブジェクト形式のみが書かれており、.serializeArray() で取得した形式については記述がありませんが、実際の所、そのまま引き渡せます。</p>
<h3 id="calibre_link-203"><b>$.param()<span><b>中級</b></span></b></h3>
<h4><b>$.param(obj [, traditional])</b></h4>
<p>$.param()は、第1引数に渡されたデータをURLエンコードして、クエリ文字列を生成して返します。 上記で見た2つ（serialize、serializeArray）は、フォームの要素を指定してクエリ文字列を生成する時に使いました。一方、$.param()は、フォーム以外の何かしらの方法で取得したデータをAJAXのデータとして渡したい時に役立ちます。</p>
<p>traditionalという引数も指定できますが、それは一旦さておき、第1引数には、オブジェクト形式か配列形式を指定できます。キーと値からなる単純なオブジェクトに限らず、深い階層構造を持つオブジェクトも指定できます。配列については、上記で見た .serializeArray() が返す配列形式を指定できます。</p>
<p>下記のサンプルを見ればすぐに分かります。</p>
<div>
<pre><span>var</span><span>obj</span> = {</pre>
<pre><span>firstName</span>:<span>"Taro"</span>,</pre>
<pre><span>lastName</span>:<span>"Yamada"</span></pre>
<pre>};</pre>
<pre><span>var</span><span>mydata</span> =<span>$</span>.<span>param</span>(<span>obj</span>);</pre>
<pre><span>alert</span>(<span>mydata</span>);<span>//「firstName=Taro&amp;lastName=Yamada」と出力します</span></pre>
<div></div>
<pre><span>// このデータをAJAXのdataに渡すことができます。</span></pre>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>data</span>:<span>mydata</span></pre>
<pre> ...</pre>
<pre>});</pre></div>
<p>以上、$.param() についてでした。</p>
<p>traditionalの引数については、サーバサイド側プログラマでもない限り、気にする必要はありません。なので普通の方は、以下は飛ばして次に行ってください。ということで、ややマニアックなtraditionalについてです。</p>
<p>クエリ文字列は、本来階層構造を含める共通のデータ形式はありません。しかし、PHPなど幾つかのプログラミング言語では、階層構造を[ ]（角括弧（＝かくかっこ））で表現することで、それらが階層構造を持つものとして、データを受け取るようになっています。</p>
<p>Ver. 1.4以降では、デフォルトで深い階層のオブジェクトでも、階層構造を[ ]で表現してくれます。しかし、Ver. 1.3以下ではそのような処理はせず、ほとんど役に立たないデータ形式で返してきます。</p>
<div>
<pre><span>var</span><span>obj</span> = {</pre>
<pre><span>name</span>: {</pre>
<pre><span>firstName</span>:<span>"Taro"</span>,</pre>
<pre><span>lastName</span>:<span>"Yamada"</span></pre>
<pre> },</pre>
<pre><span>age</span>:<span>35</span></pre>
<pre>};</pre>
<pre><span>var</span><span>mydata</span> =<span>$</span>.<span>param</span>(<span>obj</span>);</pre>
<div></div>
<pre><span>// mydataは、「name[firstName]=Taro&amp;name[lastName]=Yamada&amp;age=35」となります。</span></pre>
<pre><span>//と、書きたいところですが、実際は、[] は、URLエンコードの対象になるため、</span></pre>
<pre><span>// [ → %5、 ] → %5D と変換され、</span></pre>
<pre><span>// 「name%5BfirstName%5D=Taro&amp;name%5BlastName%5D=Yamada&amp;age=35」</span></pre>
<pre><span>// となります。</span></pre>
<div></div>
<div></div>
<pre><span>// もし、traditionalにtrueを指定した場合、若しくは、Ver. 1.3以下だった場合</span></pre>
<pre><span>var</span><span>mydata</span> =<span>$</span>.<span>param</span>(<span>obj</span>,<span>true</span>);</pre>
<div></div>
<pre><span>// mydataは、「name=[object+Object]&amp;age=35」となる。</span></pre>
<pre><span>// しかし、本当の所はURLエンコードされるので、「name=%5Bobject+Object%5D&amp;age=35」</span></pre></div>
<p>以上、$.param() の traditionalについてでした。あまり複雑なデータ構造であれば、JSONを使うのが推奨される所でしょう。</p>
<p>ここで、1つ問題ですが、複数のチェックボックスを配列としてサーバ側に送りたい時はどうすれば良いでしょうか？PHPであれば、各フォームのコントロールに、例えば、hobby[] などのように、[]を付けることでしょう。しかし言語によっては、ただ単にhobbyなどと書くことでしょう。いずれにしてもフォームからのデータを収集してサーバに送信するのであれば、.serialize()したデータを$.ajax() のdataプロパティに引き渡せばOKです。ここで問題として、フォームからのデータではなく、変数として配列データを持っている時はどうするのがいいでしょうか？もちろん手動でクエリ文字列を組み立てるもの1つの手ですが、以下のような方法もあります。</p>
<div>
<pre><span>var</span><span>hobby</span> = [<span>1</span>,<span>3</span>,<span>5</span>];</pre>
<div></div>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>data</span>:<span>hobby</span>.</pre>
<pre> ...</pre>
<pre>});</pre></div>
<p>Ver. 1.4以上を使っていて、PHPユーザーであれば、上記でOKです。これで、hobby[]=1&amp;hobby[]=3&amp;hobby[]=5の形式で送られます。しかし、Ver. 1.4以上で、hobby[]ではなく、hobbyの名前でほしいPerlユーザーの場合、これでは困ります。そこで、次のようにすればOKです。</p>
<div>
<pre><span>var</span><span>hobby</span> = [<span>1</span>,<span>3</span>,<span>5</span>];</pre>
<div></div>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>data</span>:<span>hobby</span></pre>
<pre><span>traditional</span>:<span>true</span>,</pre>
<pre> ...</pre>
<pre>});</pre></div>
<p>ここでは、$.param()は直接登場していませんが、$.ajax()のオプションで、traditional: trueを指定しています。これで、hobby=1&amp;hobby=3&amp;hobby=5の形式で送ることができます。</p>












</div>
<div id="calibre_link-349">
<h2 id="calibre_link-204">$.ajaxSetup()（AJAX通信のデフォルト設定）</h2>
<h3 id="calibre_link-205"><b>$.ajaxSetup(options)</b></h3>
<p>$.ajax()に渡すオプションのデフォルト値を設定します。（元々デフォルト値は存在しますが、そのデフォルト値を自分で設定するという事です）$.ajax()の派生のショートカットのメソッド、例えば、$.get()などにも適用可能です。（ですが、流石に、$.get()の送信方式を"POST"に変更する事などはできません） $.ajaxSetup()を呼び出した後の$.ajax()などのメソッドに対して有効になります。個別で $.ajax()に同名のオプションを渡せば、そちらが優先されます。</p>
<div>
<pre><span>$</span>.<span>ajaxSetup</span>({</pre>
<pre><span>url</span>:<span>'someurl.php'</span>,</pre>
<pre><span>timeout</span>:<span>5000</span>,</pre>
<pre><span>dataType</span>:<span>'json'</span></pre>
<pre>});</pre>
<div></div>
<pre><span>// この後に呼ばれる $.ajax() などは、上記をデフォルト値として使う</span></pre></div>
<p>これは、複数のAJAX通信を書く際に、何度も同じ設定を書く必要がなく便利です。 ですが、本家サイトでは、<strong><b>この関数の使用を推奨していません。</b></strong>「何故！？」と思いますが、jQueryのプラグインなどでAJAXのデフォルト設定に依存しているものがある場合、デフォルト設定が上書きされてしまうと、正常に動作しなくなることがあるからです。 なので、本家サイトでは、「個別にオプションを指定するか又はそれ用のプラグインを作って対応せよ」という風に書いてあります。 ですので、完全に自分だけでプログラミングする事が分かっている場合のみに限定した方が良いでしょう。</p>
<p>AJAX通信を多用する場合、エラー処理（errorコールバック関数）などは、1つで共通に済ませたい場合などがよくあります。その場合はこちらの$.ajaxSetup()ではなく、次で見る「AJAX関係のイベント」を使うようにします。</p>



</div>
<div id="calibre_link-344">
<h2 id="calibre_link-206">AJAX関係のイベント<span>中級</span></h2>
<h3 id="calibre_link-207"><b>AJAX関係のイベント</b></h3>
<p>（ここは、さほど重要度は高くないので、後日暇な時に読めばOKです）</p>
<p>jQueryでは、AJAX関係のイベントを「ローカルイベント」と「グローバルイベント」の2つに分類しています。 今までプロパティに設定するコールバック関数を見てきましたが、それらは、ローカルイベントに対応します。一方、ここで新たに見ていくイベントがグローバルイベントに分類されます。 グローバルイベントは、イベント関係のページで見たカスタムイベントに相当します。 つまり、AJAX通信中、要所要所に置いて、jQueryがカスタムイベントを発生（trigger）します。それをjQueryのAJAXでは、グローバルイベントと呼んでいます。 ですので、これらは、.on()を使ってイベントハンドラを設定することができます。 また更に、直接イベントハンドラを設定できるようショートカット用の関数も設けられています。 下記が、それらをまとめた表です。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>コールバック関数用プロパティ<br /><b></b>（ローカルイベント）</b></th>
<th><b>イベントタイプ<br /><b></b>（グローバルイベント）</b></th>
<th><b>ショートカット用メソッド<br /><b></b>（グローバルイベント）</b></th>
</tr>
<tr>
<td>beforeSend</td>
<td>"ajaxSend"</td>
<td>.ajaxSend()</td>
</tr>
<tr>
<td>success</td>
<td>"ajaxSuccess"</td>
<td>.ajaxSuccess()</td>
</tr>
<tr>
<td>error</td>
<td>"ajaxError"</td>
<td>.ajaxError()</td>
</tr>
<tr>
<td>complete</td>
<td>"ajaxComplete"</td>
<td>.ajaxComplete()</td>
</tr>
<tr>
<td></td>
<td>"ajaxStart"</td>
<td>.ajaxStart()</td>
</tr>
<tr>
<td></td>
<td>"ajaxStop"</td>
<td>.ajaxStop()</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>ajaxSend、ajaxSuccess、ajaxError、ajaxCompleteについては、今まで見てきたローカルイベントと等価なものです。ajaxStartとajaxStopについては、等価なものはありません。ajaxStartは、一連のAJAX通信の開始時に一度だけ発生します。そして、ajaxStopはその逆で、一連のAJAX通信の終了時に一度だけ発生します。図で示すと、以下のようになります。</p>
<p><img src="images/000012.gif" /></p>
<p>ajaxSendとajaxCompleteは、各通信において個別に発生します。（図では、ajaxSuccessとajaxErrorを省いていますが、AJAXの結果に応じたどちらかが個別に発生します） 一連のAJAX通信が終わった後に、また別のAJAX通信が走れば、またajaxStartから繰り返します。（一連としていますが、1つだけの場合も同じです）</p>
<p>具体例を見てみましょう。一連のAJAXが開始されると、loading_icon（ローディングアイコン）を表示し、一連のAJAX処理が終了すると、loading_iconを非表示にするという例です。</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre><span>#loading_icon</span> {</pre>
<pre><span>display</span><span>:</span><span>none</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre>
<div></div>
<pre><span>&lt;p&gt;</span></pre>
<pre><span>&lt;img</span><span>src</span>=<span>"loading.gif"</span><span>id</span>=<span>"loading_icon"</span><span>&gt;</span></pre>
<pre><span>&lt;/p&gt;</span></pre>
<div></div></div>
<div>
<pre><span>// ローディングアイコンの処理</span></pre>
<pre><span>// 対象のAJAX処理より先に仕掛けます</span></pre>
<pre><span>$</span>(<span>document</span>).<span>on</span>({</pre>
<pre><span>ajaxStart</span>:<span>function</span>() {</pre>
<pre><span>$</span>(<span>"#loading_icon"</span>).<span>show</span>();</pre>
<pre> },</pre>
<pre><span>ajaxStop</span>:<span>function</span>() {</pre>
<pre><span>$</span>(<span>"#loading_icon"</span>).<span>hide</span>();</pre>
<pre> }</pre>
<pre>});</pre>
<div></div>
<pre><span>// その後、複数のAJAXを呼び出します。</span></pre>
<pre><span>// コードは、略</span></pre></div>
<p>AJAXが開始されると、loading_iconが現れ、終了すると消えます。実は、Ver. 1.9より前までは、$(document)の部分は、documentに限らず、何の要素でも指定可能でした。例えば、$("#loading_icon")などです。しかし、Ver. 1.9以降、documentにしか設定できなくなりましたので気をつけましょう。</p>
<p>ちなみに、ローカルイベントとグローバルイベントで等価のイベントについては、ローカルイベントの方が先に実行されます。</p>
<h4><b>グローバルイベントの受け取る引数</b></h4>
<p>グローバルイベントのコールバック関数は、以下の引数を受け取ります。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>イベントタイプ</b></th>
<th><b>コールバック関数が受け取る引数</b></th>
</tr>
<tr>
<td>"ajaxSend"</td>
<td rowspan="4">
第1引数 ... イベントオブジェクト<br />
第2引数 ...jqXHR（Ver. 1.5未満はXMLHttpRequest）<br />
第3引数 ... $.ajax()等に個別に設定した情報<br />
<br />
更に、ajaxErrorは、第4引数にエラーオブジェクトというものを受け取ります。
</td>
</tr>
<tr>
<td>"ajaxSuccess"</td>
</tr>
<tr>
<td>"ajaxError"</td>
</tr>
<tr>
<td>"ajaxComplete"</td>
</tr>
<tr>
<td>"ajaxStart"</td>
<td>引数無し</td>
</tr>
<tr>
<td>"ajaxStop"</td>
<td>引数無し</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>ローカルイベントと等価なグローバルイベントでも、ローカルイベントのコールバック関数が受け取る引数は異なる点に留意しましょう。（特に、ステータスコードは受け取りません）</p>
<h4><b>globalオプション</b></h4>
<p>$.ajax()系メソッドでは、globalというオプションがあります。このglobalをfalseに設定すると（デフォルトはtrue）、その指定したAJAX通信に関しては、グローバルイベントを発生（trigger）しなくなります。<br />例）</p>
<div>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>"abc.php"</span>,</pre>
<pre><span>type</span>:<span>"POST"</span>,</pre>
<pre><span>data</span>:<span>data</span>,</pre>
<pre><span>global</span>:<span>false</span>,<span>// ここ</span></pre>
<pre><span>dataType</span>:<span>"text"</span></pre>
<pre>});</pre></div>


</div>
<div id="calibre_link-0">
<h2 id="calibre_link-208">新・コールバック関数の指定方法</h2>
<p>Ver. 1.5以上のjQueryでは、新しい書き方でコールバック関数を指定することができます。
（やや応用的な内容の為、本書では簡単な使い方の紹介に留めます）</p>
<h3 id="calibre_link-209"><b>新・コールバック関数の指定方法</b></h3>
<p>今までのコールバック関数は、例えば以下のように書いていました。 （無名関数を直接書くやり方もありますが、いずれにせよプロパティに関数を指定することに変わりはありません）</p>
<div>
<pre><span>function</span><span>onSuccess</span>() {</pre>
<pre><span>console</span>.<span>log</span>(<span>"成功！"</span>);</pre>
<pre>}</pre>
<pre><span>function</span><span>onFailure</span>() {</pre>
<pre><span>console</span>.<span>log</span>(<span>"失敗しました。"</span>);</pre>
<pre>}</pre>
<div></div>
<pre><span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>dataType</span>:<span>"json"</span>,</pre>
<pre><span>// ↓今までのコールバック関数の指定</span></pre>
<pre><span>success</span>:<span>onSuccess</span>,</pre>
<pre><span>error</span>:<span>onFailure</span></pre>
<pre>});</pre></div>
<p>これを、Ver. 1.5以上では、例えば下のように書けます。（関数の定義は上と同じとする）</p>
<div>
<pre><span>var</span><span>promise</span> =<span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>dataType</span>:<span>"json"</span>,</pre>
<pre>});</pre>
<div></div>
<pre><span>promise</span>.<span>done</span>(<span>onSuccess</span>);</pre>
<pre><span>promise</span>.<span>fail</span>(<span>onFailure</span>);</pre></div>
<p>変数名（promise）は、もちろん任意です。今までの success が done に、error が fail という名前に変わり、$.ajax() 関数の返り値（promise）に対して、それぞれのメソッドでコールバック関数を指定します（もちろん、無名関数を直接書いても構いません）。また、上記では、一旦変数を介してメソッドを指定しましたが、変数を介さずメソッドチェーンで直接繋いでもOKです。</p>
<p>この新しい書き方の場合、コールバック関数をいくつも指定することができます。例えば以下のようになります。</p>
<div>
<pre><span>var</span><span>promise</span> =<span>$</span>.<span>ajax</span>({</pre>
<pre><span>url</span>:<span>'xxx.php'</span>,</pre>
<pre><span>type</span>:<span>"GET"</span>,</pre>
<pre><span>dataType</span>:<span>"json"</span>,</pre>
<pre>});</pre>
<div></div>
<pre><span>promise</span>.<span>done</span>(<span>onSuccess1</span>);</pre>
<pre><span>promise</span>.<span>done</span>(<span>onSuccess2</span>);</pre>
<pre><span>promise</span>.<span>done</span>(<span>onSuccess3</span>);</pre></div>
<p>これであれば、ajax通信が終わった後に、あの処理、この処理、その処理をさせたい、という時などにすっきり書くことができます。</p>
<p>この例だけでは、この新しいコールバック関数の指定方法の良さは、正直ほとんど伝わりませんが、より複雑に絡んだコールバック関数を扱うようになった時に、この書き方の恩恵が伝わってきます。 このような新しい指定方法がありますが、今までのコールバック関数の指定方法が無くなる事はまず無いでしょうから、その点は安心して良いと思います。</p>
<p>ちなみにこの新しいコールバックの記述方法は、Deferred（やPromise）などと呼ばれる技術分野で、jQueryの中でも奥が深く、プログラマ向けの領域です。このDeferred/Promiseを使えば、例えば、「AJAX通信1とAJAX通信2の両方が終了したら、AJAX通信3を実行させる」などという事も簡単にできるようになります。</p>


</div>
<div id="calibre_link-280">
<h1 id="calibre_link-369">9章　エフェクト・アニメーション</h1>
<p>この章で登場するメソッド・プロパティ一覧です。</p>


<ul>
	<li><a href="#calibre_link-212">.show()、.hide()</a></li>
	<li><a href="#calibre_link-213">.toggle()</a></li>

	<li><a href="#calibre_link-215">.fadeIn()、.fadeOut()</a></li>
	<li><a href="#calibre_link-216">.fadeToggle()</a></li>
	<li><a href="#calibre_link-217">.fadeTo()</a></li>

	<li><a href="#calibre_link-219">.animate()</a></li>

	<li><a href="#calibre_link-222">キューの取得・追加 .queue()</a></li>
	<li><a href="#calibre_link-223">キューの取り出し＆実行 .dequeue()</a></li>
	<li><a href="#calibre_link-224">キューのクリア .clearQueue()</a></li>
	<li><a href="#calibre_link-225">キュー処理の遅延 .delay()</a></li>

	<li><a href="#calibre_link-33">アニメーションの停止 .stop()</a></li>
	<li><a href="#calibre_link-34">アニメーションの完了 .finish()</a></li>
	<li><a href="#calibre_link-35">アニメーションを全体的に無効にする $.fx.off</a></li>
	<li><a href="#calibre_link-36">アニメーションの連続実行対策</a></li>
	<li><a href="#calibre_link-227">アニメーションの処理が思いと感じたら</a></li>
	
</ul>


</div>
<div id="calibre_link-291">
<h2 id="calibre_link-211">エフェクト .show() .hide(). toggle()</h2>
<p>エフェクトとは、アニメーションの効果のことを指します。何かの状態が変化した時に、いきなり表示が変わるのは、ユーザーにとっては何が起きたのか分かりにくいものです。一定のアニメーションを付けることで、ユーザーに変化が起きている事を伝えられます。適切な箇所で、適切なアニメーションを使っていきましょう。</p>


<ul>
	<li><a href="#calibre_link-212">.show()、.hide()</a></li>
	<li><a href="#calibre_link-213">.toggle()</a></li>
</ul>


<h3 id="calibre_link-212"><b>.show()、.hide()</b></h3>
<p>.show()、.hide()は、お互い反対のメソッドのため、一緒に見て行きましょう。.show()は、選択している要素を表示する場合、.hide()は、選択しているを非表示にする場合に使用します。</p>
<h4><b>.show()<br /><b></b>
  .hide()</b></h4>
<p>引数無しでこれらを呼び出した場合、瞬間的に選択されている要素を表示・非表示にします。 サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box1"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_show"</span><span>value</span>=<span>".show()"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_hide"</span><span>value</span>=<span>".hide()"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_show"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>show</span>();</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"#btn_hide"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>hide</span>();</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_show.php">実際のサンプル</a></p>
<p>.hide()は、CSSの値をdisplay: noneに設定します。 一方、.show()は、元の要素に明示的にdisplay:の指定があった場合はそれに戻し、そうでなかった場合はその要素に応じたデフォルトの値（block又はinline）に設定されます。</p>
<p>もし、それらの自動設定で不都合がある場合は、これらメソッドの使用は止め、{display: none} などのクラスを定義してそのクラスを.addClass()、removeClass()して、より明示的な方法を取ると良さそうです。</p>
<p>上記では瞬間的に切り替わるので、まだアニメーションとは言えませんが、すぐ下で見る引数を使うとアニメーションになります。</p>



<h4><b>.show( duration [, callback] )<br /><b></b>
  .hide( duration [, callback] )</b></h4>
<p>durationに、数値でミリ秒単位を指定することで、アニメーションが切り替わるまでの時間を設定できます。 また、ミリ秒単位以外でも文字列で、"slow"、"fast"と設定することで、それぞれ600ミリ秒、200ミリ秒に設定したことになります。 これら以外を設定すると、400ミリ秒（デフォルト）になります。<br />
サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box2"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_show2"</span><span>value</span>=<span>".show()"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_hide2"</span><span>value</span>=<span>".hide()"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_show2"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box2"</span>).<span>show</span>(<span>1000</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"#btn_hide2"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box2"</span>).<span>hide</span>(<span>"fast"</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_show.php#more">実際のサンプル</a></p>
<p>左上を起点にアニメーションしているのが分かるでしょうか？また、透明度も変化してフェード効果も自動で出ています。
また、第2引数に関数を指定して、アニメーションの完了後に実行させたい処理（コールバック関数）を指定することができます。（今回の例では省略しています）</p>
<h4><b>.show( [duration] [, easing] [, callback] )<br /><b></b>
  .hide( [duration] [, easing] [, callback] )</b></h4>
<p>上記のタイプに、更にeasingと呼ばれる動き具合を指定できるタイプです。easingには、"swing"と"linear"が標準で使えます。 "swing"がデフォルトで、これは動きの最初と最後が少しゆっくりになります。一方、"linear"は、全体を通して同じスピードで移動します。この2つ以外の動きがほしい場合は、<a href="http://jqueryui.com/show/">Query UI</a>などのプラグインを使って対応できます。</p>
<h3 id="calibre_link-213"><b>.toggle()</b></h3>
<p>上で見た.show()、.hide()は、よく使うメソッドなので、2つをセットにしたようなメソッドがあります。それが、.toggle()です。 このメソッドは、選択されている要素で、表示状態のものは非表示に切り替え、非表示のものは表示状態に切り替えます。その為、呼び出される度ごとに表示・非表示が切り替わることになります。 サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box3"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_toggle"</span><span>value</span>=<span>".toggle()"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_toggle"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box3"</span>).<span>toggle</span>(<span>1000</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_toggle.php">実際のサンプル</a></p>
<p>このメソッドには、以下の構文があります。</p>
<h4><b>.toggle( [duration] [, callback] )</b></h4>
<h4><b>.toggle( [duration] [, easing] [, callback] )</b></h4>
<h4><b>.toggle( showOrHide )</b></h4>
<p>最初の2つは、.show()、.hide()と同じだから省略します。3つ目を見てみます。これは、引数showOrHideの部分に、trueを渡すと表示させ、falseを渡すと非表示になります。</p>



</div>
<div id="calibre_link-307">
<h2 id="calibre_link-214">フェード効果</h2>
<p>透明度を操るアニメーションを見て行きましょう。</p>


<ul>
	<li><a href="#calibre_link-215">.fadeIn()、.fadeOut()</a></li>
	<li><a href="#calibre_link-216">.fadeToggle()</a></li>
	<li><a href="#calibre_link-217">.fadeTo()</a></li>
</ul>
<h3 id="calibre_link-215"><b>.fadeIn()、.fadeOut()</b></h3>
<p>先程見た.show()、.hide()では、アニメーションする際に大きさと透明度が変化していきましたが、こちらのメソッドは名前の通り、透明度だけが変化していきます。 .fadeIn()で徐々に現れ、.fadeOut()で徐々に消えていきます。.fadeOut()の最後は、display: noneになります。</p>
<h4><b>.fadeIn( [duration] [, callback] )<br /><b></b>
  .fadeOut( [duration] [, callback] )</b></h4>
<p>durationに、数値でミリ秒単位を指定することで、アニメーションが切り替わるまでの時間を設定できます。 また、ミリ秒単位以外でも文字列で、"slow"、"fast"と設定することで、それぞれ600ミリ秒、200ミリ秒に設定したことになります。 これら以外の設定又は未設定の場合は、400ミリ秒（デフォルト）になります。<br />
サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box1"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_fadeIn"</span><span>value</span>=<span>".fadeIn()"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_fadeOut"</span><span>value</span>=<span>".fadeOut()"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_fadeIn"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>fadeIn</span>(<span>1000</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"#btn_fadeOut"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>fadeOut</span>(<span>"fast"</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_fadeIn.php">実際のサンプル</a></p>
<p>透明度だけが変化して行きます。また、第2引数に関数を指定して、アニメーションの完了後に実行させたい処理を指定することができます。</p>
<h4><b>.fadeIn( [duration] [, easing] [, callback] )<br /><b></b>
  .fadeOut( [duration] [, easing] [, callback] )</b></h4>
<p>（.show()、.hide()の時と説明は、ダブりますが）上記のタイプに、更にeasingと呼ばれる動き具合を指定できるタイプです。easingには、"swing"と"linear"が標準で使えます。 "swing"がデフォルトで、これは動きの最初と最後が少しゆっくりになります。一方、"linear"は、全体を通して同じスピードで移動します。この2つ以外の動きがほしい場合は、<a href="http://jqueryui.com/show/">Query UI</a>などのプラグインを使って対応できます。</p>
<h3 id="calibre_link-216"><b>.fadeToggle()</b></h3>
<h4><b>.fadeToggle( [duration] [, easing] [, callback] )</b></h4>
<p>.show()、.hide()に、.toggle()があったように、.fadeIn()、.fadeOut()にも2つをセットにしたようなメソッドの.fadeToggle()があります。 このメソッドは、選択されている要素で、表示状態のものはfadeOutしながら非表示に切り替え、非表示のものはfadeInしながら表示状態に切り替えます。その為、呼び出される度ごとに表示・非表示が切り替わることになります。 サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box2"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_fadeToggle"</span><span>value</span>=<span>".fadeToggle()"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_fadeToggle"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box2"</span>).<span>fadeToggle</span>(<span>1000</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_fadeToggle.php">実際のサンプル</a></p>



<h3 id="calibre_link-217"><b>.fadeTo()</b></h3>
<h4><b>.fadeTo( duration, opacity [, callback] )</b></h4>
<h4><b>.fadeTo( duration, opacity [, easing] [, callback] )</b></h4>
<p>今までのメソッドは、表示・非表示のどちらか限定でしたが、.fadeToでは、opacity（0～1（or 0.0～1.0））を設定して、特定の透明度までアニメーションさせることができます。（0が非表示、1が完全表示）durationとopacityの引数は、必須になります。また、他の.fadeIn()、.fadeOut()などと異なり、<strong><b>opacityが0になってもdisplay: noneには設定されません。</b></strong></p>
<p>サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box3"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_fadeTo_0"</span><span>value</span>=<span>".fadeTo('slow', 0)"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_fadeTo_05"</span><span>value</span>=<span>".fadeTo('slow', 0.5)"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_fadeTo_05"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box3"</span>).<span>fadeTo</span>(<span>'slow'</span>,<span>0.5</span>);</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"#btn_fadeTo_0"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box3"</span>).<span>fadeTo</span>(<span>'slow'</span>,<span>0</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_fadeTo.php">実際のサンプル</a></p>
<p>&nbsp;</p>
<p>さて、フェード系の最後に、1つ問題を出してみます。以下は、画面にフワ～と「こんにちは」と表示されるつもりで書いたものです。ですが、実際は何も表示されません。どこに問題があったのでしょうか？</p>
<div>
<pre><span>&lt;style&gt;</span></pre>
<pre><span>.hello</span> {</pre>
<pre><span>position</span><span>:</span><span>fixed</span>;</pre>
<pre><span>top</span><span>:</span><span>50px</span>;</pre>
<pre><span>left</span><span>:</span><span>50px</span>;</pre>
<pre>}</pre>
<pre><span>&lt;/style&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"&lt;div&gt;こんにちは&lt;/div&gt;"</span>).<span>hide</span>().<span>addClass</span>(<span>"hello"</span>).<span>fadeIn</span>(<span>2000</span>);</pre></div>
<p>まず、DIVに囲まれたHTML要素を生成して、最後に、.fadeIn(2000)で表示させたかったのですが、そもそもこの生成したHTMLが、まだドキュメント上に存在しないのです。fadeIn()は、fadeTo()と異なり、display: none;のものをdisplay: block;などに変えて表示させる機能はあります。しかし、まだドキュメント上に存在しないものを表示させる機能までは流石にありません（この点、show()も同様）。ですので、下記のようにすれば、この問題は解決します。</p>
<div>
<pre><span>$</span>(<span>"&lt;div&gt;こんにちは&lt;/div&gt;"</span>).<span>hide</span>().<span>addClass</span>(<span>"hello"</span>).<span>appendTo</span>(<span>"body"</span>).<span>fadeIn</span>(<span>2000</span>);</pre></div>
<p>.appendTo("body")で、ドキュメントに付け加えるようにしています。</p>



</div>
<div id="calibre_link-318">
<h2 id="calibre_link-218">自作アニメ .animate()</h2>
<p>今まで見てきたメソッドは、手軽に使える分、そのアニメーション効果も限られているものでした。ここで見る.animate()を使えば、色々な動きをするアニメーション効果を作ることができます。</p>
<h3 id="calibre_link-219"><b>.animate()</b></h3>
<h4><b>.animate( properties [, duration] [, easing] [, complete] )</b></h4>
<p>propertiesに要素の最終形のCSSスタイルをキーと値からなるオブジェクト形式で記述します。例えば、{width: "100px", opacity: 0.5}のように指定すれば、このCSSの設定に向かってアニメーションして行きます。幾つかポイントを挙げてみます。</p>


<ul>
	<li>幅や高さを示す値については、単位を省略すれば、デフォルトでpxとなります。emや%を明示して単位を付けることもできます。</li>
	<li>また += や -= 記号を利用して、現在の位置からの相対位置で書くこともできます。例）{width: "+=100px"}</li>
	<li>単純に計算のできる数値のみのスタイルに限られます。「色」は指定できません。「色」のアニメ効果を出す場合は、<a href="http://jqueryui.com/animate/">jQuery UI</a>などをご利用下さい。</li>
	<li>値の指定に、"hide", "show", "toggle"のキーワードを利用できます。例えば、{opacity:"toggle"}のように指定すると、非表示の時はfadeInして現れ、表示状態の時は、fadeOutして非表示になります。（.fadeToggle()と同じ効果ですね）</li>
</ul>
<p>durationに、数値でミリ秒単位を指定することで、アニメーションが切り替わるまでの時間を設定できます。 また、ミリ秒単位以外でも文字列で、"slow"、"fast"と設定することで、それぞれ600ミリ秒、200ミリ秒に設定したことになります。 この2つ以外を設定すると、400ミリ秒（デフォルト）になります。</p>
<p>easingには、"swing"と"linear"が標準で使えます。 "swing"がデフォルトで、これは動きの最初と最後が少しゆっくりになります。一方、"linear"は、全体を通して同じスピードで移動します。この2つ以外の動きがほしい場合は、<a href="http://jqueryui.com/show/">Query UI</a>などのプラグインを使って対応できます。</p>
<p>completeには、アニメーションの完了後に実行させたい処理を指定します。</p>
<p>サンプルを見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box1"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_start"</span><span>value</span>=<span>"スタート"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({</pre>
<pre><span>width</span>:<span>"+=100px"</span>,</pre>
<pre><span>height</span>:<span>"-=50px"</span>,</pre>
<pre><span>opacity</span>:<span>0.5</span></pre>
<pre> },<span>1000</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_animate.php">実際のサンプル</a></p>


<h4><b>.animate( properties, options )</b></h4>
<p>こちらの構文も利用できます。propertiesは、上記と同じです。optionsには、以下のキーと値形式のオブジェクト（代表的なもののみ記載）が渡せます。</p>


<ul>
	<li>duration... 上記と同じ</li>
	<li>easing... 上記と同じ</li>
	<li>complete... 上記と同じ</li>
	<li>step... アニメーションの各ステップで呼ばれる関数（上級者用）</li>
	<li>queue...falseを渡すことで、キューを直ちに実行できます。デフォルト、true。（キューについては、後述）</li>
</ul>
<p>例）</p>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({</pre>
<pre><span>width</span>:<span>"+=100px"</span>,</pre>
<pre><span>height</span>:<span>"-=50px"</span>,</pre>
<pre><span>opacity</span>:<span>0.5</span></pre>
<pre> }, {</pre>
<pre><span>duration</span>:<span>1000</span>,</pre>
<pre><span>easing</span>:<span>"linear"</span></pre>
<pre> });</pre>
<pre>});</pre></div>



</div>
<div id="calibre_link-306">
<h2 id="calibre_link-220">キューとは</h2>
<p>キューとは、何かの処理待ち状態の事を言います。ここでは、アニメーションのキューについて見て行きます。最初の「キューとは」は、入門者向けですが、それ以降は、中級者向け内容になります。</p>


<ul>
	<li><a href="#calibre_link-221">キューとは</a></li>
	<li><a href="#calibre_link-222">キューの取得・追加 .queue()</a></li>
	<li><a href="#calibre_link-223">キューの取り出し＆実行 .dequeue()</a></li>
	<li><a href="#calibre_link-224">キューのクリア .clearQueue()</a></li>
	<li><a href="#calibre_link-225">キュー処理の遅延 .delay()</a></li>
</ul>
<h3 id="calibre_link-221"><b>キューとは</b></h3>
<p>まずは、次のサンプルをご覧ください。どのような動きをするか分かるでしょうか？</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box1"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_start"</span><span>value</span>=<span>"スタート"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>opacity</span>:<span>0.5</span>},<span>1000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>1000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>css</span>(<span>"background-color"</span>,<span>"green"</span>);</pre>
<pre>});</pre></div>
<p>実際のサンプルを動かす前に、動きを予想してみましょう。<br />
【予想1】</p>
<ol>
<li value="1">box1の背景がピンクになる</li>
<li value="2">その後、1秒掛けて、透明度が半分になると同時に、長さが100px伸びる</li>
<li value="3">その後、背景が緑になる</li>
</ol>







【予想2】
<ol>
<li value="1">box1の背景がピンクになる</li>
<li value="2">その後、1秒掛けて、透明度が半分になる</li>
<li value="3">その後、1秒掛けて、長さが100px伸びる</li>
<li value="4">その後、背景が緑になる</li>
</ol>
<p>↓では、実際に動かしてみましょう。</p>
<p><a href="http://jquery-master.net/examples/effects_queue.php">実際のサンプル</a></p>
<p>実際、動かしてみて分かったと思いますが、どちらの予想も外れでした。結果は、</p>
<ol>
<li value="1">box1の背景がピンクになると同時に緑になるので、緑しか認識できない</li>
<li value="2">その後、1秒掛けて、透明度が半分になる</li>
<li value="3">その後、1秒掛けて、長さが100px伸びる</li>
</ol>
<p>となります。<br />
つまり、プログラム自体は、上から下に即座に実行されているのですが、アニメーションの実際の処理に関しては、jQuery側で制御を掛け、早く登録されたものから順番に実行するようにしているのです。これがキューと呼ばれる仕組みで、処理待ちの状態を管理しています。</p>
<p>上記では便宜上、2行に分けて書きましたが、これはメソッドチェーンを使って1行で書いても同じことです。</p>
<div>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>opacity</span>:<span>0.5</span>},<span>1000</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>1000</span>);</pre></div>
<p>また、今回は同一のbox1に対するアニメーションの設定でした。もしこれらが別々の場合はどうでしょうか？</p>
<div>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>opacity</span>:<span>0.5</span>},<span>1000</span>);<span>// こちらは、box1に対して</span></pre>
<pre><span>$</span>(<span>"#box2"</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>1000</span>)<span>// こちらは、box2に対して</span></pre></div>
<p>この場合は、box1とbox2が同時に（別々に）アニメーションを始めます。あくまでキューは、個々の要素ごとで処理されます。</p>
<h3 id="calibre_link-222"><b>キューの取得・追加 .queue()</b></h3>
<p>jQueryでは、上記で見たキューをプログラムで操作することができます。また、後のサンプルで見ますが、キューは、アニメーションだけに限った話ではなく、より汎用的な目的で使えます。 ここで見る.queue()は、呼び出し方によって、以下の3つの事ができます。</p>


<ol>
	<li value="1">現在貯まっているキューを配列で得る</li>
	<li value="2">関数の配列を指定して、現在のキューと入れ替える</li>
	<li value="3">1つの関数を指定して、それをキューに追加する</li>
</ol>
<p>選択済みの要素全てに対してキューの処理を行います。1つ1つの構文を見て行きましょう。構文をまとめてザッと見た後で、サンプルを幾つか見て行きます。<br />
<strong><b>以下、全てのメソッドの引数の [ queueName ] は、省略可能で、デフォルトではアニメーションに使用される"fx"です。</b></strong>キューを区別するために使用されます</p>
<h4><b>.queue( [ queueName ] )</b></h4>
<p>現在貯まっているキュー（関数）の配列が返ります。</p>
<h4><b>.queue( [queueName], newQueue )</b></h4>
<p>newQueueには、キューにしたい関数を配列形式で渡します。現在貯まっているキューと入れ替わるのでご注意下さい。</p>
<h4><b>.queue( [queueName], callback( next ) )</b></h4>
<p>コールバック関数を1つ渡し、それをキューに追加します。 関数には、nextという関数が渡されます。これを使い、.dequeue()することができます。下記の.dequeue()のサンプル参照。</p>
<h3 id="calibre_link-223"><b>キューの取り出し＆実行 .dequeue()</b></h3>
<p>貯めたキューは、実行するために貯めたものです。キューを取り出して実行するのが、.dequeue()メソッドです。<br />
次の構文になります。</p>
<h4><b>.dequeue( [queueName] )</b></h4>
<p>サンプルで見てみましょう。このサンプルでは、各LI要素にキューを3つずつ貯めています。 そして、各LI要素をクリックする度ごとに、そのクリックしたLI要素のキューが取り除かれ、実行されていきます。 .queue()の引数に指定する関数内で、thisは、queueが設定された要素自身を指します。</p>
<div>
<pre><span>&lt;ul</span><span>id</span>=<span>"test1"</span><span>&gt;</span></pre>
<pre><span>&lt;li&gt;</span>太郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;li&gt;</span>次郎<span>&lt;/li&gt;</span></pre>
<pre><span>&lt;/ul&gt;</span></pre></div>
<div>
<pre><span>function</span><span>func1</span>() {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"yellow"</span>);</pre>
<pre>}</pre>
<pre><span>function</span><span>func2</span>() {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre>
<pre>}</pre>
<pre><span>function</span><span>func3</span>() {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"orange"</span>);</pre>
<pre>}</pre>
<div></div>
<pre><span>// ここではmyqueという名前でキューを貯める</span></pre>
<pre><span>$</span>(<span>"#test1 li"</span>).<span>queue</span>(<span>"myque"</span>,<span>func1</span>);</pre>
<pre><span>$</span>(<span>"#test1 li"</span>).<span>queue</span>(<span>"myque"</span>,<span>func2</span>);</pre>
<pre><span>$</span>(<span>"#test1 li"</span>).<span>queue</span>(<span>"myque"</span>,<span>func3</span>);</pre>
<div></div>
<pre><span>$</span>(<span>"#test1 li"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>// キューを実行して行く</span></pre>
<pre><span>$</span>(<span>this</span>).<span>dequeue</span>(<span>"myque"</span>);</pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_dequeue.php">実際のサンプル</a></p>
<p>もう一例、見てみましょう。少し上の「キューとは」で見たサンプルのJSを少し変更してみます。4行目と5行目を入れ替えました。</p>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>opacity</span>:<span>0.5</span>},<span>1000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>css</span>(<span>"background-color"</span>,<span>"green"</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>1000</span>);</pre>
<pre>});</pre></div>
<p>もうお分かりの通り、行を入れ替えたところで、事実上何も変わりません。 では、3行目の.animate()が終わった段階で、背景色を緑に変え、その後に、5行目の.animate()の処理をしたい場合はどうすれば良いでしょうか？ ここで先ほど見た.queue()を使います。次のようにします。</p>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>css</span>(<span>"background-color"</span>,<span>"pink"</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>opacity</span>:<span>0.5</span>},<span>1000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>queue</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"green"</span>);</pre>
<pre><span>$</span>(<span>this</span>).<span>dequeue</span>();</pre>
<pre> });</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>1000</span>);</pre>
<pre>});</pre></div>
<p>これで、2つのアニメーションの間に背景を緑にすることができるようになりました。ここで、6行目の.dequeue()の処理を忘れないで下さい。自分でキューの処理を書く場合は、自分で.dequeue()して次の処理を呼び出してやらなければなりません。 この.dequeue()の部分は、コールバック関数に渡される関数（next）を利用して、次のように書くこともできます。</p>
<div>
<pre><span>$</span>(<span>"#box1"</span>).<span>queue</span>(<span>function</span> (<span>next</span>) {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"green"</span>);</pre>
<pre><span>next</span>();</pre>
<pre>});</pre></div>
<p>nextという名前で無くても良いのですが、nextがよく使われます。</p>


<h3 id="calibre_link-224"><b>キューのクリア .clearQueue()</b></h3>
<h4><b>.clearQueue( [queueName] )</b></h4>
<p>まだ実行されずに貯まっているキューをクリア（全部削除）します。.queue()同様、queueNameは省略可能で、省略した場合は、アニメーションに使用される"fx"になります。</p>
<h3 id="calibre_link-225"><b>キュー処理の遅延 .delay()</b></h3>
<p>キューの中の次のキューの処理の実行を遅らせることができます。durationは、遅延させる時間（ミリ秒）で、"slow"、"fast"（それぞれ600ミリ秒、200ミリ秒）のキーワードも使えます。queueNameは、省略可能でデフォルト"fx"です。</p>
<div>
<pre><span>// 0.5秒掛けて.slideUp()し、1秒間停止し、その後0.7秒掛けて.slideDown()します。</span></pre>
<pre><span>$</span>(<span>'#hoge'</span>).<span>slideUp</span>(<span>500</span>).<span>delay</span>(<span>1000</span>).<span>slideDown</span>(<span>700</span>);</pre></div>


</div>
<div id="calibre_link-32">
<h2 id="calibre_link-226">アニメーションの停止</h2>
<p>先程は、キューについて見ました。キューは、アニメーションだけに限った話ではなく、より汎用的な目的で使えました。さて、アニメーションに話を戻し、アニメーションを停止するやり方を見てみましょう。キューの概念が分かっていれば簡単です。</p>


<ul>
	<li><a href="#calibre_link-33">アニメーションの停止 .stop()</a></li>
	<li><a href="#calibre_link-34">アニメーションの完了 .finish()</a></li>
	<li><a href="#calibre_link-35">アニメーションを全体的に無効にする $.fx.off</a></li>
	<li><a href="#calibre_link-36">アニメーションの連続実行対策</a></li>
</ul>
<h3 id="calibre_link-33"><b>アニメーションの停止 .stop()</b></h3>
<h4><b>.stop( [queueName] [,clearQueue] [, jumpToEnd] )</b></h4>
<p>.stop()メソッドで、選択している要素のアニメーションを停止させることができます。2つの引数で挙動を変更できます。どちらもデフォルトは、falseです。</p>


<ul>
<li>queueName... 停止対象のキュー名。（Ver.1.7より追加）</li>
	<li>clearQueue... 残りのアニメーションのキューも削除する場合は、true。</li>
	<li>jumpToEnd... 現在実行中のアニメーションをCSSの最終形の表示にするか（true）、そのまま放置するか（false）。</li>
</ul>
<p>trueとfalseの組み合わせで、合計4パターンあり得ます。 まとめてみました。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>第1引数</b></th>
<th><b>第2引数</b></th>
<th><b>挙動</b></th>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>現在実行中のキューがその場でストップし、次のキューの動作に移る。</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>現在実行中のキューが即座に最終形になり、終了。<br />（残りのアニメーションキューは削除）</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>その場で全て終了。時間が止まったイメージ。（残りのアニメーションキューは削除）</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>現在実行中のキューが最終形になり、引き続き次のキューの動作に移る。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>なおここで言う、「アニメーションのキュー」とは、実際の処理内容がアニメーションを伴うかどうかではなく、デフォルトのアニメーションのキュー名、"fx"で登録されているキューという意味です。</p>
<p>上記4パターンのサンプルを見てみましょう。（ストップボタン周りのHTMLは、省略しています）</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"box1"</span><span>style</span>=<span>"width: 100px; height: 100px; background-color: orange"</span><span>&gt;&lt;/div&gt;</span></pre>
<pre><span>&lt;form&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"button"</span><span>id</span>=<span>"btn_start"</span><span>value</span>=<span>"スタート"</span><span>&gt;</span></pre>
<pre><span>&lt;/form&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#btn_start"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>width</span>:<span>"+=100px"</span>},<span>2000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>animate</span>({<span>height</span>:<span>"+=100px"</span>},<span>2000</span>);</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>queue</span>(<span>function</span> () {</pre>
<pre><span>$</span>(<span>this</span>).<span>css</span>(<span>"background-color"</span>,<span>"green"</span>);</pre>
<pre> });</pre>
<pre>});</pre>
<pre><span>$</span>(<span>"#btn_stop"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>stop</span>(<span>false</span>,<span>false</span>);<span>// 実際の引数は、選択したラジオにより変化させます</span></pre>
<pre>});</pre></div>
<p><a href="http://jquery-master.net/examples/effects_stop.php">実際のサンプル</a></p>
<h3 id="calibre_link-34"><b>アニメーションの完了 .finish()</b></h3>
<h4><b>.finish( [queueName] )</b></h4>
<p>Ver.1.9より、上記.stop()だけでは実現できない「残りのキューも含めてアニメを最終形にする」というメソッドが追加されました。それが、.finish()です。.finish()を使うと、対象の要素のアニメーションが、一瞬で全てが完了します（まさにfinish）。瞬間的に仕事が終わるイメージです。下記サンプルでは、.stop()でのサンプルを一部変更して、.finish()に対応させました。サンプルを見ていて気づくのは、.finish()は、アニメーションを最終形に持っていきますが、.queue()で追加した処理については、一切無視しています。（最後に緑色になりません）</p>
<p><a href="http://jquery-master.net/examples/effects_finish.php">実際のサンプル</a></p>



<h3 id="calibre_link-35"><b>アニメーションを全体的に無効にする $.fx.off</b></h3>
<p>処理能力の低いデバイス向けに、アニメーション効果を無効にしたい場合もあるでしょう。その場合は、$.fx.offのプロパティをtrueに設定すれば、全体的なアニメーションを無効にすることができます。アニメーションを無効にすると、アニメーション効果はなくなり、即座にそのCSSの最終形になります。</p>
<div>
<pre><span>// アニメーションを無効にする</span></pre>
<pre><span>$</span>.<span>fx</span>.<span>off</span> =<span>true</span>;</pre>
<div></div>
<pre><span>// アニメーションを有効に戻す</span></pre>
<pre><span>$</span>.<span>fx</span>.<span>off</span> =<span>false</span>;</pre></div>



<h3 id="calibre_link-36"><b>アニメーションの連続実行対策</b></h3>
<p>さて、アニメーションやキューについて見てきましたが、最後にアニメーションの連続実行対策について考えてみましょう。
この章の最初の方で、.toggle()というメソッドを見ました。クリックする度ごとに、表示・非表示を繰り返してくれるメソッドです。下記のような感じでした。</p>
<div>
<pre><span>$</span>(<span>"#btn_toggle1"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box1"</span>).<span>toggle</span>(<span>1000</span>);</pre>
<pre>});</pre></div>
<p>上記の場合、ボタンをクリックする度ごとに、1秒掛けて、表示・非表示を繰り返しました。さて、ここで問題ですが、1秒以内にボタンを3回連打するとどんな動きになるでしょうか？大体もうお分かりかと思いますが、キューは貯まりますので、3秒掛けて、表示・非表示を繰り返すことになります。</p>
<p><a href="http://jquery-master.net/examples/effects_queue_animated.php">実際のサンプル（下記の分も含みます）</a></p>
<p>この動きがいいこともありますが、場合によっては、アニメーション中にボタンを連打しても、それは無効にしたい時もあります。そんな時は、セレクターの章で少しだけ登場した:animatedを使うと対応できます。以下のようになります。</p>
<div>
<pre><span>$</span>(<span>"#btn_toggle2"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box2:not(:animated)"</span>).<span>toggle</span>(<span>1000</span>);</pre>
<pre>});</pre></div>
<p>:not(:animated) として、アニメーション中でない要素のみに限定しています。こうすることで、アニメーション中の要素には、アニメーションを仕掛けないことが可能となります。</p>
<p>ついでにもう1つ見ておきましょう。.stop()というのも習いましたので、これも使ってみましょう。引数無しのデフォルト（＝現在実行中のキューがその場でストップし、次のキューの動作に移る）で行きます。</p>
<div>
<pre><span>$</span>(<span>"#btn_toggle3"</span>).<span>on</span>(<span>"click"</span>,<span>function</span> () {</pre>
<pre><span>$</span>(<span>"#box3"</span>).<span>stop</span>().<span>toggle</span>(<span>1000</span>);</pre>
<pre>});</pre></div>
<p>動きは、実際のサンプルでご確認いただける通り、アニメーション中にクリックすると、そのアニメーションが停止し、新たなアニメーションに移ることになります。</p>




</div>
<div id="calibre_link-329">
<h2 id="calibre_link-227">アニメーションの処理が思いと感じたら</h2>
<p>以前は、Flashが担当していたアニメーションの処理も、今ではすっかりJavaScript（jQuery）が担当するようになりました。基本的にアニメーションは、負荷の掛かる処理です。<br />

時折、PCではそれなりに動くのに、スマートフォンだとカクカクして実用的で無いことがあります。もちろん、プログラムの作りを見直すことによって、スムーズに動くこともあるでしょう。しかし、純粋にアニメーションで負荷が掛かっている場合、ハードウェアアクセラレータの効くCSS3（translate3d、translateZなど）の利用を検討してみると良いでしょう。驚くほどスムーズに動くようになります。CSS3は本書の範囲外の為、詳しくは、CSS3の書籍等を参考にして下さい。</p>


</div>
<div id="calibre_link-290">
<h1 id="calibre_link-370">10章　プロパティ</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-229">.prop()の基本的な使い方</a></li>
	<li><a href="#calibre_link-231">属性とプロパティ</a></li>
	<li><a href="#calibre_link-233">checked、disabledな状態にする、状態を調べる</a></li>
	<li><a href="#calibre_link-236">.prop()とデフォルトの値</a></li>
</ul>


</div>
<div id="calibre_link-341">
<h2 id="calibre_link-229">.prop()の基本的な使い方</h2>
<p>.prop()は、要素のプロパティを操作するメソッドとして、Ver.1.6から登場しました。プロパティと比較されるものとして属性というものがありますが、属性と言うのはHTML的な概念から来るもので、プロパティと言うのはJavascriptの言語仕様的なものです。 ここでは、.prop()の基本的な使い方を見て行きましょう。</p>
<h3 id="calibre_link-230"><b>.prop()</b></h3>
<h4><b>.prop(propertyName)</b></h4>
<p>第1引数で指定したプロパティの値を取得します。</p>
<div>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"chk1"</span><span>&gt;</span></pre></div>
<div>
<pre><span>var</span><span>val</span> =<span>$</span>(<span>"#chk1"</span>).<span>prop</span>(<span>"checked"</span>);</pre></div>
<p>上記の例では、現在、チェックボックスにチェックが入っているかをtrue/falseで取得します。複数の要素がマッチした場合は、マッチした要素の内の1番最初の要素の状態を取得します。</p>
<p>もし存在しないプロパティを指定した場合は、undefinedを返します。</p>
<h4><b>.prop(propertyName, value)</b></h4>
<p>第1引数のプロパティに第2引数で指定した値を設定します。</p>
<div>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>id</span>=<span>"chk1"</span><span>&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>"#chk1"</span>).<span>prop</span>(<span>"checked"</span>,<span>true</span>);</pre></div>
<p>マッチした要素のチェックをオンの状態にします。falseでオフにします。</p>
<h4><b>.prop(properties)</b></h4>
<p>propertiesにキーと値からなるオブジェクトを指定し、まとめてプロパティを設定します。</p>


</div>
<div id="calibre_link-304">
<h2 id="calibre_link-231">属性とプロパティ</h2>
<p>属性とプロパティは、DOM要素を操作する上で大事な2つになります。 この2つは、DOM要素を表すJavaScriptオブジェクトに割り当てられます。</p>
<h3 id="calibre_link-232"><b>属性とプロパティ</b></h3>
<p>属性と言うのはHTML的な概念から来るものです。そして、HTMLのマークアップに付与された属性が、DOM要素を表すオブジェクトのプロパティに割り当てられます。 また、その属性自体も「attributes」というプロパティに割り当てられます。<br />
詳しく見てみましょう。</p>
<p>次のようなイメージ画像があったとします。<img src="images/00009.jpeg" alt="忍者" title="忍者です" /></p>
<div>
<pre><span>&lt;img</span><span>id</span>=<span>"ninja"</span><span>src</span>=<span>"img/ninja.png"</span><span>class</span>=<span>"kage"</span><span>alt</span>=<span>"忍者"</span><span>title</span>=<span>"忍者です"</span><span>&gt;</span></pre></div>
<p>HTMLの属性というのは、id="ninja" から始まり、title="忍者です" までの部分です。このHTMLがブラウザによって解釈＆分析されると、 このimg要素を表すオブジェクトのプロパティに割り当てられます。</p>
<p><img src="images/000071.gif" /></p>
<p>ほとんど同じ内容がコピーされていますが、少し違う点もあります。まず、srcについては、属性では相対パスになっていたのが、プロパティでは絶対パスになっています。 また、属性ではclassとなっていたものが、プロパティでは、classNameとなっています。（classは、JavaScriptの予約語です） また、ここでは登場しませんでしたが、属性は必ず文字列の形を取るのに対し、プロパティは、真偽値（ture/false）や数値になるものもあります。</p>
<p>ところでこの時、HTMLの属性についても、img要素の「attributes」というプロパティに同じものがコピーされます。</p>
<p><img src="images/00008.jpeg" /></p>
<p>こちらについてはsrcやclassについてもHTMLの属性がそのまま入ってきます。（図は簡略化して書いてます）</p>
<p>そしてこれらのプロパティと属性は、対応するもの同士、お互いどちらかを変更すれば、もう一方も変更されるという関係にあります。</p>
<p><img src="images/00070.jpeg" /></p>
<p>さて、ここまで図を使って説明してきましたが、実際にそうなのか、ChromeのデベロッパーツールやFirefoxのFirebugを使って確認してみましょう。</p>
<p>素材→<img src="images/00009.jpeg" alt="忍者" title="忍者です" /></p>
<p><a href="http://jquery-master.net/examples/prop_propattr.php">実際の忍者の素材はこちら</a></p>
<p>Chromeのデベロッパーツールをお使いの方は、左下の虫眼鏡アイコンをクリックして、上の忍者アイコンをクリックして下さい。 そして、右側画面から、「Properties」をクリックし、「img#ninja.kage」をクリックして展開してください。次のような画面が確認できると思います。 実際は、たくさんのプロパティがあるので、対応するプロパティを探すには、下までスクロールする必要があります。</p>
<p><img src="images/000044.gif" /></p>
<p>attributesに関しては、クリックして展開していくと、実際はかなり複雑であることが分かるでしょう。例えば、idなど展開すると色々表示されますが、要はnameとvalueという所を見ればOKです。</p>
<p><img src="images/000001.gif" /></p>
<p>FirefoxのFirebugをお使いの方は、左上の虫アイコンの右側をクリックして、上の忍者アイコンをクリックして下さい。 そして、右側画面から、「DOM」のタブをクリックすると、プロパティが一覧表示されます。</p>
<p><img src="images/000077.gif" /></p>
<p>attributesについては、すぐ上のChromeのデベロッパーツールの場合を参考にして下さい。<br />
これで、属性やプロパティがどういうものか分かりやすくなったでしょう。</p>
</div>
<div id="calibre_link-354">
<h2 id="calibre_link-233">checked、disabledな状態にする、状態を調べる</h2>
<p>ここで少し一休みして、checked、disabledな状態にする場合や状態を調べる場合を見てみましょう。</p>
<h3 id="calibre_link-234"><b>checked、disabledな状態にする、状態を調べる</b></h3>
<div>
<pre><span>// ラジオボタンやチェックボックスにチェックを付ける</span></pre>
<pre><span>// 外す場合は、falseを指定</span></pre>
<pre><span>$</span>(<span>'#chk1'</span>).<span>prop</span>(<span>'checked'</span>,<span>true</span>);</pre>
<div></div>
<pre><span>// 同上の現在のチェック状態を調べる</span></pre>
<pre><span>// チェックされている状態なら、trueが返る</span></pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>'#chk1'</span>).<span>prop</span>(<span>'checked'</span>);</pre>
<pre><span>var</span><span>ret</span> =<span>$</span>(<span>'#chk1'</span>).<span>is</span>(<span>':checked'</span>);<span>// こちらの方法もある</span></pre>
<div></div>
<div></div>
<pre><span>// フォームを構成する要素をdisabledな状態にする</span></pre>
<pre><span>// その逆は、falseを指定</span></pre>
<pre><span>$</span>(<span>'#btn1'</span>).<span>prop</span>(<span>'disabled'</span>,<span>true</span>);</pre>
<div></div>
<pre><span>// 同上のdisabledな状態を調べる</span></pre>
<pre><span>// disabledの状態なら、trueが返る</span></pre>
<pre><span>$</span>(<span>'#btn1'</span>).<span>prop</span>(<span>'disabled'</span>);</pre>
<pre><span>$</span>(<span>'#btn1'</span>).<span>is</span>(<span>':disabled'</span>);<span>// こちらもある</span></pre></div>
<p>以上のようになります。状態を取得する場合は、マッチした要素の内の1番最初の要素の状態を取得します。</p>
<h3 id="calibre_link-235"><b>.attr()で変更するやり方は、もう古い</b></h3>
<p>.attr()を使ってchecked、selected、disabledプロパティを変更する下記のようなやり方（第2引数にtrue/falseを指定）は、古いやり方です。 使うのは辞めましょう。（何かと混同したやり方です）</p>
<div>
<pre><span>$</span>(<span>'#chk1'</span>).<span>attr</span>(<span>"checked"</span>,<span>true</span>);</pre></div>


</div>
<div id="calibre_link-6">
<h2 id="calibre_link-236">.prop()とデフォルトの値</h2>
<p>ここでは、少し小面倒な話を見ていきます。入門者の方は、この章の残りは読み飛ばして下さい。</p>
<p>プロパティを操作するのが.prop()で、属性を操作するのは.attr()ですが、jQuery1.6未満、1.6、1.6.1以上と3段階で、.attr()の仕様が変化しています。 その辺の仕様変化を細かく説明しているとパニック状態になってしまいますので、本書では紹介しません。 そこら辺を詳しく知りたい方は、「jquery attr 1.6」などで検索して、諸先輩方のブログなどを参考にして下さい。</p>
<p>、、とは言え、少しだけ紹介しておきますと、jQuery1.6未満のjQueryでは、プロパティを操作する為の.prop()メソッドがありませんでした。代わりにjQueryでは、.attr()が内部的にプロパティを操作する面倒を見てくれていました。 が、「属性とプロパティを混同した仕様は、良くない」と言うことになり、1.6で属性とプロパティ用のメソッドをちゃんと分けることにしたのですが、それがかえって利用者に混乱をもたらしたため、一部機能を1.6.1で復活させた、という経緯になります。</p>
<p>以降の説明やサンプルでは、<strong><b>古いjQuery（Ver. 1.6.1未満）を使っている場合は、必ずしも同じ挙動になりません。</b></strong>是非、最新のjQueryでお楽しみ下さい。また、checkedを使って話を進めて行きますが、「selected」「disabled」などに関しても同様な事が言えます。</p>
<h3 id="calibre_link-237"><b>checked属性、checkedプロパティ、defaultCheckedプロパティ</b></h3>
<p>まずポイント部分だけ列挙して、その後、解説に入ります。これさえ分かれば、もう大丈夫です。</p>
<p>&nbsp;</p>
<table width="100%">
<tbody><tr>
<th><b>属性／プロパティ</b></th>
<th><b>内容</b></th>
</tr>
<tr>
<td>checked属性</td>
<td>初期のチェック状態を表現</td>
</tr>
<tr>
<td><strong><b>checkedプロパティ</b></strong></td>
<td><strong><b>現在の</b></strong>チェック状態をtrue/falseにて表現</td>
</tr>
<tr>
<td>defaultCheckedプロパティ</td>
<td>初期のチェック状態をtrue/falseにて表現</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>用語の整理をしておきますと、「初期」とは、ページ読み込み直後のデフォルトの状態のことです。「現在」とは、その後ユーザーがチェックを付けたり外したりした後の今現在（見た目上の）の状態を指します。</p>
<p>なので、現在チェックされているかを調べるのは、<strong><b>checkedプロパティ</b></strong>を見れば良いことになります。初期のチェック状態など、普通は気にしません。</p>


<h3 id="calibre_link-238"><b>デフォルト（初期）のチェックを付ける</b></h3>
<p>チェックを付けるやり方は、少し前で見た通りですが、ここでは、初期の（デフォルトの）チェックを付けるやり方を見てみましょう。</p>
<div>
<pre><span>$</span>(<span>"#chk1"</span>).<span>attr</span>(<span>"checked"</span>,<span>"checked"</span>);<span>// デフォルトのチェックを付ける</span></pre>
<pre><span>$</span>(<span>"#chk1"</span>).<span>prop</span>(<span>"defaultChecked"</span>,<span>true</span>);<span>// 同上</span></pre></div>
<p>デフォルトとは、ページの読み込み時などに初期値を設定するものです。 属性には対応するプロパティがあるのは、既に書いた通りですが、紛らわしい事に、<strong><b>checked属性の対応するプロパティは、checkedプロパティではなく、defaultCheckedプロパティ</b></strong>なのです。</p>
<p>デフォルトは、通常は、HTMLタグに直接書くことが多いです。</p>
<div>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>checked</span>=<span>"checked"</span><span>&gt;</span></pre></div>
<p>そして、JavaScriptから、この初期値を設定できても不思議ではありません。 初期値は、ページが表示された後に操作するのはまだOKですが、ユーザーがチェックボックスを操作した後（つまり、チェックを付けたり、外したりした後）は、もはや手遅れです。 この場合、もはや初期値を表すchecked属性を変更したところで、現在の（見た目上の）チェック状態は変わりません。 （しかし、checked属性やdefaultCheckedプロパティの値自体は、変わる）</p>
<p><strong><b>checked属性</b></strong>の値は、現在の（見た目上の）のチェック状態を表してはいません。</p>
<p>そして、checked属性とcheckedプロパティは、対応関係にはありません。（ただ、実際は、checkedプロパティは、その時の状態を反映するので、checked属性を変更することでチェックが入れば、それが結果的にcheckedプロパティにも反映される。逆にcheckedプロパティを変更してもchecked属性には反映されない）</p>
<p>デフォルトにチェックを付ける<a href="http://jquery-master.net/examples/prop_checked.php">動作確認用のサンプル</a>を用意しました。（IE7以下には非対応）</p>
<p>なるほど。ユーザーが操作する前なら、初期値を設定できることが分かりました。 しかし、このように思うかも知れません。「初期値って何？.prop("checked", true);で変更できるなら、それだけ使っていればいいじゃん！」 確かにそうです。.prop("checked", true); だけ使っていれば十分かも知れません。 しかし、初期状態を設定できるということは、ほんの少し違い（メリット）もあります。 問い合わせフォームなどでよく見る「リセット」ボタンというのがあります。 自分でフォームを作ったことがある方ならご存知かも知れませんが、あの「リセット」ボタンは、 フォームを真っ更な状態にするのではなく（通常、その場合が多いですが...）、フォームを初期の状態に戻すためにあります。 つまり、初期の状態でチェックが付いていれば、「リセット」ボタンで、そのチェックが付いている状態に戻すことができるのです。 これが、初期状態を設定した場合の違い（メリット）です。 もっとも最近では、「リセット」ボタンの存在価値も薄くなっているかも知れませんが。</p>
<p>ということで、使い分けをまとめると、ページのロード時に、「このチェックボックスは、デフォルトでONにすべきだ」という判断になった場合は、ここで紹介した方法が妥当になります。 一方、例えばユーザーが何か操作することで、チェックボックスのON／OFFを切り替える場合などでは、最初に紹介したやり方が妥当ということになります。</p>


<h3 id="calibre_link-239"><b>disabled="disabled" の話</b></h3>
<p>少し余談ですが、上記で見たHTMLにデフォルトのcheckedを付ける場合に関連した話として、checkedやdisabledなど、対応するプロパティが真偽値（true/false）を取る属性は、その存在だけが問われ、値の中身は問われません。よって、下記全てデフォルトで「チェックが付く」又は「disabledになる」となります。</p>
<div>
<pre>// どれでもチェックが付く</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>checked</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>checked</span>=<span>"checked"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>checked</span>=<span>"abc"</span><span>&gt;</span></pre>
<div></div>
<pre>// どれでもdisabledになる</pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span>=<span>"disabled"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span>=<span>""</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span>=<span>"hoge"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span>=<span>"false"</span><span>&gt;</span></pre>
<pre><span>&lt;input</span><span>type</span>=<span>"checkbox"</span><span>disabled</span>=<span>"abled"</span><span>&gt;</span></pre></div>
<p><img src="images/000015.gif" /></p>
<h3 id="calibre_link-240"><b>valueを扱う時は、.val()で</b></h3>
<p>フォームのvalue値を取り扱う時は、.prop()や.attr()ではなく、それ専用の<a href="#calibre_link-7">.val()</a>を使うようにします。</p>
<div>
<pre><span>$</span>(<span>"#myselect"</span>).<span>val</span>();<span>// 取得</span></pre>
<pre><span>$</span>(<span>"#myselect"</span>).<span>val</span>(<span>"abcde"</span>);<span>// 設定</span></pre></div>


</div>
<div id="calibre_link-28">
<h1 id="calibre_link-371">11章　.data()</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-29">.data()の基本的な使い方</a></li>
	<li><a href="#calibre_link-30">HTML5のカスタム属性</a></li>
	<li><a href="#calibre_link-31">.data()とHTML5のカスタム属性の関係</a></li>
</ul>


</div>
<div id="calibre_link-328">
<h2 id="calibre_link-29">.data()の基本的な使い方</h2>
<p>DOM要素にデータを設定（紐付け）＆取得する.data()メソッドを見ていきましょう。</p>
<p>JavaScriptでは、データを管理するために、「変数」と呼ばれるものがあります。変数を使えばデータの管理はできるのですが、その変数を使わずに、DOM要素にデータを設定してしまおう、というものです。変数というのは、自分で定義して管理していくことになり、何かと手間のかかるものです。特定の要素だけに関係するデータであれば、その要素に設定できてしまうと、何かと楽になるというものです。</p>
<h3 id="calibre_link-242"><b>.data()</b></h3>
<h4><b>.data(key, value)</b></h4>
<h4><b>.data(key)</b></h4>
<p>keyとvalueの両方を指定した時は、マッチした要素にkeyをキーとする値valueを設定します。keyのみ指定した時は、マッチした要素の内の最初の要素に紐づくkeyの値を返します。 該当するデータが無い時は、undefinedが返ります。</p>
<div>
<pre><span>// #div1要素に「myname / 太郎」を設定する</span></pre>
<pre><span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"myname"</span>,<span>"太郎"</span>);</pre>
<div></div>
<pre><span>// nameは、「太郎」になる。</span></pre>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"myname"</span>);</pre></div>
<p>valueで指定する値は、何も文字列に限りません。JavaScriptのあらゆる形式が指定可能です。</p>
<div>
<pre><span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"name"</span>, {<span>firstName</span>:<span>"太郎"</span>,<span>lastName</span>:<span>"山田"</span>});</pre>
<div></div>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"name"</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>name</span>.<span>firstName</span>);<span>// 「太郎」を出力</span></pre></div>
<p>上記ではオブジェクトを指定してみました。他にも、例えば関数なども設定可能です。</p>
<h4><b>.data(object)</b></h4>
<p>オブジェクト形式で指定して、複数のキーと値のペアを設定することもできます。</p>
<div>
<pre><span>$</span>(<span>"#div1"</span>).<span>data</span>({<span>firstName</span>:<span>"太郎"</span>,<span>lastName</span>:<span>"山田"</span>});</pre>
<div></div>
<pre><span>// nameは、「太郎」になる。</span></pre>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"firstName"</span>);</pre></div>


<h4><b>.data()</b></h4>
<p>.data(key)が、keyの値しか取得しないのに対し、こちらは、紐付く全てのデータをオブジェクト形式で取得します。</p>
<div>
<pre><span>$</span>(<span>"#div1"</span>).<span>data</span>({<span>firstName</span>:<span>"太郎"</span>,<span>lastName</span>:<span>"山田"</span>});</pre>
<div></div>
<pre><span>var</span><span>names</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>();</pre>
<pre><span>console</span>.<span>log</span>(<span>names</span>.<span>firstName</span>);<span>// 「太郎」を出力</span></pre></div>


<h3 id="calibre_link-243"><b>.removeData()</b></h3>
<h4><b>.removeData([name])</b></h4>
<p>nameを指定して、要素に紐付くデータを削除します。引数を指定しない時は、紐付く全てのデータが削除されます。</p>
<h4><b>.removeData([list]) （Ver.1.7～）</b></h4>
<p>配列またはスペース区切りの名前を指定して、要素に紐付くデータを削除します。</p>
</div>
<div id="calibre_link-287">
<h2 id="calibre_link-30">HTML5のカスタム属性</h2>
<p>少し、.data()メソッドから話は逸れ、HTML5のカスタム属性（data-*）について、見ていきましょう。</p>
<h3 id="calibre_link-244"><b>HTML5のカスタム属性</b></h3>
<p>属性とプロパティについては、<a href="#calibre_link-231">「属性とプロパティ」</a>も参考にして下さい。</p>
<p>HTMLのマークアップに属性を書く時、もし自分の好きな属性名（カスタム属性）を使うとどのようになるのでしょうか？ 実のところ、そのようなことも可能です。ですがHTML5が登場するまでは、そのような標準でない属性は、文法的には妥当なものとはなりませんでした。 そこで、HTML5では、特定の記述方式で書けば、文法的にも妥当なものとなり、カスタム属性が設定できるようになりました。 それが、data-* の形式です。</p>
<div>
<pre>/* HTML5のカスタム属性でないやり方。文法的には妥当でないが、属性にはなる。*/</pre>
<pre><span>&lt;div</span><span>id</span>=<span>"div1"</span><span>myname</span>=<span>"太郎"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre>/* HTML5のカスタム属性方式。文法的にも妥当。 */</pre>
<pre><span>&lt;div</span><span>id</span>=<span>"div2"</span><span>data-myname</span>=<span>"二郎"</span><span>&gt;&lt;/div&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>// name1は、「太郎」となる</span></pre>
<pre><span>var</span><span>name1</span> =<span>$</span>(<span>"#div1"</span>).<span>attr</span>(<span>"myname"</span>);</pre>
<div></div>
<pre><span>// name2は、「二郎」となる</span></pre>
<pre><span>var</span><span>name2</span> =<span>$</span>(<span>"#div2"</span>).<span>attr</span>(<span>"data-myname"</span>);</pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>さて、せっかくですので、Firebugなどのコンソール画面を使って、HTML5のカスタム属性がどのようにDOM要素のプロパティに割り当てられているか見てみましょう。</p>
<p>次のようなイメージ画像があったとします。<img src="images/00009.jpeg" /></p>
<div>
<pre><span>&lt;img</span><span>src</span>=<span>"img/ninja.png"</span><span>nickname</span>=<span>"はっとり君"</span><span>data-name</span>=<span>"服部半蔵"</span><span>data-middle-name</span>=<span>"忍者"</span><span>&gt;</span></pre></div>
<p>HTML5形式でないカスタム属性が1つとHTML5形式のカスタム属性が2つあります。これら3つは、DOM要素のプロパティには、割り当てられていないのが分かると思います。 しかしattributesプロパティには相変わらずそのままの形で割り当てられているのが確認できます。そして、HTML5のカスタム属性については、datasetというプロパティにも割り当てられているのが確認できます。（古いブラウザを除く）</p>
<p><img src="images/000056.gif" /></p>
<p>attributesプロパティについては、HTMLマークアップそのままですが、datasetプロパティには、「data-」が取れた形の名前が付いています。 また、「middle-name」となっていたものは、ハイフンが取れ、camelCase形式となって、「middleName」と変化しています。この次に見ますが、このHTML5のカスタム属性は、jQueryの.data()メソッドで取得することができます。</p>
<p>カスタム属性を使うと、.data()メソッドに頼らずとも、DOM要素にデータを設定できることが、何となく分かってきました。</p>
</div>
<div id="calibre_link-339">
<h2 id="calibre_link-31">.data()とHTML5のカスタム属性の関係</h2>
<p>HTML5のカスタム属性は、文法的にも妥当でありながら、DOM要素に特定のデータを設定できるというものでした。 そこで、ここでは、このHTML5のカスタム属性と、jQueryの.data()メソッドの関係を見てみましょう。</p>
<h3 id="calibre_link-245"><b>.data()とHTML5のカスタム属性の関係</b></h3>
<p>まず、このHTML5のカスタム属性とjQueryの.data()で管理されるデータは、<strong><b>本来まったく別物</b></strong>と認識しておきましょう。jQueryの.data()は、<strong><b>jQuery独自の方式</b></strong>でDOM要素にデータを関連付けて管理しています。</p>
<p>と言いつつも、.data()メソッドは、HTML5のカスタム属性の値を取ってきてくれるという機能があります。</p>
<p>具体例で見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"div1"</span><span>data-myname</span>=<span>"織田信長"</span><span>&gt;&lt;/div&gt;</span></pre></div>
<div>
<pre><span>// nameは、「織田信長」になる</span></pre>
<pre><span>var</span><span>name</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>(<span>"myname"</span>);<span>// 「data-myname」とは書かない</span></pre></div>
<p>別管理ではあるのですが、.data()メソッドは、気前よくHTML5のカスタム属性の値を取ってきてくれます。 しかし、この気前のいい機能ですが、1度値を取ってくると、もうそれ以上は最新の値を取って来てくれません。 詳しくは、すぐ下の注意点1で。</p>
<p><img src="images/000025.gif" /></p>
<h3 id="calibre_link-246"><b>注意点1、データは、最初の取得時に固定される</b></h3>
<p>HTML5のカスタム属性から取ってきた値は、最初の取得時に固定されます。<br />
具体例で見てみましょう。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"div2"</span><span>data-myname</span>=<span>"織田信長"</span><span>&gt;&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>name</span>;</pre>
<div></div>
<pre><span>// マークアップでは、「織田信長」だったが、「豊臣秀吉」に変更する</span></pre>
<pre><span>// （attr()を使ってカスタム属性を変更）</span></pre>
<pre><span>$</span>(<span>"#div2"</span>).<span>attr</span>(<span>"data-myname"</span>,<span>"豊臣秀吉"</span>);</pre>
<div></div>
<pre><span>// nameは、「豊臣秀吉」になる。</span></pre>
<pre><span>// この時点で、jQueryが.data()で管理するデータは固定される。</span></pre>
<pre><span>name</span> =<span>$</span>(<span>"#div2"</span>).<span>data</span>(<span>"myname"</span>);</pre>
<div></div>
<pre><span>// もう一度、カスタム属性を変更してみる。</span></pre>
<pre><span>$</span>(<span>"#div2"</span>).<span>attr</span>(<span>"data-myname"</span>,<span>"徳川家康"</span>);</pre>
<div></div>
<pre><span>// nameは、「徳川家康」にはならずに、「豊臣秀吉」のまま</span></pre>
<pre><span>name</span> =<span>$</span>(<span>"#div2"</span>).<span>data</span>(<span>"myname"</span>);</pre>
<div></div>
<pre><span>// いっそ、カスタム属性を削除してみる</span></pre>
<pre><span>$</span>(<span>"#div2"</span>).<span>removeAttr</span>(<span>"data-myname"</span>);</pre>
<div></div>
<pre><span>// nameは、相変わらず「豊臣秀吉」</span></pre>
<pre><span>name</span> =<span>$</span>(<span>"#div2"</span>).<span>data</span>(<span>"myname"</span>);</pre>
<div></div>
<pre><span>// カスタム属性の方は、undefined</span></pre>
<pre><span>name</span> =<span>$</span>(<span>"#div2"</span>).<span>attr</span>(<span>"data-myname"</span>);</pre></div>


<h3 id="calibre_link-247"><b>注意点2、値は変換できる型に変換される</b></h3>
<p>HTML5のカスタム属性から取ってきた値は、自動で変換可能な型に変換されます。 ある意味、機能であり、便利ではあるのですが、意図せぬ型変換が行われることもあるので、注意が必要です。</p>
<div>
<pre><span>&lt;div</span><span>id</span>=<span>"kata1"</span><span>data-num</span>=<span>"[1,2,3]"</span><span>data-yes</span>=<span>"true"</span><span>data-person</span>=<span>'{"name":"Taro","age":"45"}'</span><span>&gt;&lt;/div&gt;</span></pre></div>
<div>
<pre><span>var</span><span>ret1</span> =<span>$</span>(<span>"#kata1"</span>).<span>data</span>(<span>"num"</span>);</pre>
<pre><span>var</span><span>ret2</span> =<span>$</span>(<span>"#kata1"</span>).<span>data</span>(<span>"yes"</span>);</pre>
<pre><span>var</span><span>ret3</span> =<span>$</span>(<span>"#kata1"</span>).<span>data</span>(<span>"person"</span>);</pre>
<div></div>
<pre><span>// ret1は、[1,2,3]の配列</span></pre>
<pre><span>// ret2は、真偽値のtrue</span></pre>
<pre><span>// ret3は、オブジェクト型（JSONとして解釈可能のため）</span></pre></div>
<p>もし意図せぬ型変換を避けたい場合は、.attr()メソッドで直接、属性値を取得すれば良いでしょう。</p>
<div>
<pre><span>var</span><span>ret1</span> =<span>$</span>(<span>"#kata1"</span>).<span>attr</span>(<span>"data-num"</span>);</pre>
<div></div>
<pre><span>// ret1は、"[1,2,3]"の文字列</span></pre></div>



<h3 id="calibre_link-248"><b>注意点3、キーとなる名前にはハイフンは使わない方が無難</b></h3>
<p>Ver.3.0未満とそれ以降では、キーにハイフンがある時の取り扱いに変更が生じます。トラブルを避けるためには、なるべくハイフンを使わない方が無難です。</p>
<p>一例</p>
<div>
<pre><span>$</span>(<span>"#div1"</span>).<span>data</span>({<span>"my-name"</span>:<span>"太郎"</span>});</pre>
<pre><span>var</span><span>mydata</span> =<span>$</span>(<span>"#div1"</span>).<span>data</span>();</pre>
<div></div>
<pre><span>// mydataは、</span></pre>
<pre><span>// Ver.3.0未満では、Object {my-name: "太郎"}</span></pre>
<pre><span>// Ver.3.0以降では、Object {myName: "太郎"}</span></pre>
<pre><span>console</span>.<span>log</span>(<span>mydata</span>);</pre></div>





<h3 id="calibre_link-249"><b>その他注意点</b></h3>
<p>HTML5のカスタム属性を削除する場合は、.removeData()ではなく、.removeAttr()を使います。</p>


</div>
<div id="calibre_link-302">
<h1 id="calibre_link-372">12章　ユーティリィ（関数）</h1>
<p>この章で登場するユーティリティ関数の一覧です。</p>


<ul>
	<li><a href="#calibre_link-255">$.each()</a></li>
	<li><a href="#calibre_link-256">$.map()</a></li>
	<li><a href="#calibre_link-257">eachとmapのコールバック関数の引数について</a></li>
	<li><a href="#calibre_link-258">$.grep()</a></li>
	<li><a href="#calibre_link-259">$.merge()</a></li>
	<li><a href="#calibre_link-260">$.extend()</a></li>
	<li><a href="#calibre_link-261">$.inArray()</a></li>
	<li><a href="#calibre_link-262">$.makeArray()</a></li>
	<li><a href="#calibre_link-263">$.parseJSON()</a></li>
</ul>
</div>
<div id="calibre_link-352">
<h2 id="calibre_link-251">ユーティリティ（関数）とは</h2>
<h3 id="calibre_link-252"><b>ユーティリティ（関数）とは</b></h3>
<p>jQueryには、「ユーティリティ又はユーティリティ関数」と呼ばれているものがあります。 早い話、ユーティリティー関数とは、便利な関数（群）のことを言います。 今まで見てきたjQueryオブジェクトのメソッドとはどう違うのかと言うと、メソッドは、jQueryオブジェクト（DOM要素など）に対して作用するのに対し、 ユーティリティー関数は、それらには関係なく、単純に便利な関数になります。</p>


<h3 id="calibre_link-253"><b>ユーティリティ関数の形式と範囲</b></h3>
<p>ユーティリティ関数は、<strong><b>$.xxx()</b></strong>の形式で利用します。例えば、$.each() などです。 $.xxx() という形には違和感を覚えるかも知れませんが、jQuery.xxx() と書いても同じなため、こちらの方が見た目しっくり来るかも知れません。 本家サイトでは、ユーティリティ関数は、<strong><b>jQuery.xxx()</b></strong>の形で書かれています。 （一方、jQueryオブジェクトに作用するメソッドは、<strong><b>.xxx()</b></strong>の形で書かれています）</p>
<p>また、メソッドとユーティリティ関数で、同じ名前のものも多数存在します。例えば、eachなどがあります。使い方も似ているところがあります。 メソッドは、<strong><b>$(selector).each()</b></strong>の形で、ユーティリティ関数は、<strong><b>$.each()</b></strong>の形で書きます。</p>
<p>基本的に $.xxx() の形式を取るものは、ユーティリティ関数と捉える事ができるのですが、その目的性が強いもの、 例えば、AJAXの目的で使う$.ajax() などは、本家サイトでは、ユーティリティ関数には分類されておりません。</p>
<h4><b>用語について</b></h4>
<p>一般に「ユーティリティ関数」と呼ばれていますが、テクニカル的（文法的）には、「関数」というより「メソッド」と呼ぶべきかも知れませんが、一般には、「ユーティリティ関数」と呼ばれています。</p>
</div>
<div id="calibre_link-314">
<h2 id="calibre_link-254">ユーティリティ関数 $.each()、$.map()、$.grep()</h2>
<h3 id="calibre_link-255"><b>$.each()</b></h3>
<h4><b>$.each(array, function (index, value))</b></h4>
<h4><b>$.each(object, function (name, value))</b></h4>
<p>$.each()は、第1引数に指定した配列又はオブジェクトの各アイテムに対し、第2引数に指定した関数を実行していきます。 関数に渡される第1引数は、配列のインデックス番号（オブジェクトの場合は、プロパティ名）、第2引数はその値になります。 共に、thisは、第2引数と同じになります。<br />
この、$.each()は、jQueryオブジェクトに対して作用する<a href="#calibre_link-15">.each()</a>メソッドとは、使い方は異なります。</p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>// 配列の場合</span></pre>
<pre><span>var</span><span>names</span> = [<span>"太郎"</span>,<span>"次郎"</span>,<span>"三郎"</span>];</pre>
<pre><span>$</span>.<span>each</span>(<span>names</span>,<span>function</span> (<span>i</span>,<span>val</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>i</span> +<span>": "</span> +<span>val</span>);</pre>
<pre>});</pre>
<div></div>
<pre><span>// オブジェクトの場合</span></pre>
<pre><span>var</span><span>person</span> = {</pre>
<pre><span>name</span>:<span>"太郎"</span>,</pre>
<pre><span>age</span>:<span>"35"</span>,</pre>
<pre><span>gender</span>:<span>"男性"</span></pre>
<pre>};</pre>
<pre><span>$</span>.<span>each</span>(<span>person</span>,<span>function</span> (<span>n</span>,<span>val</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>n</span> +<span>": "</span> +<span>val</span>);</pre>
<pre>});</pre></div>
<p>上記を実行すると、以下のように出力されます。</p>
<p><img src="images/000068.gif" /></p>
<p>$.each()は、第1引数で指定した配列又はオブジェクトをそのまま返します。</p>
<p>もし、大量のデータを扱っていて、動作が遅い、と感じた時は、$.each()ではなく、素のJavaScriptのfor文を使うのも検討してみましょう。 パフォーマンス的には早くなります。下記にfor文を使う昔ながらの方法も記載しておきます。</p>
<div>
<pre><span>// 配列の場合</span></pre>
<pre><span>var</span><span>i</span>,</pre>
<pre><span>names</span> = [<span>"太郎"</span>,<span>"次郎"</span>,<span>"三郎"</span>],</pre>
<pre><span>len</span> =<span>names</span>.<span>length</span>;</pre>
<div></div>
<pre><span>for</span> (<span>i</span> =<span>0</span>;<span>i</span> &lt;<span>len</span>;<span>i</span> +=<span>1</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>i</span> +<span>": "</span> +<span>names</span>[<span>i</span>]);</pre>
<pre>}</pre>
<div></div>
<pre><span>// オブジェクトの場合</span></pre>
<pre><span>var</span><span>n</span>,</pre>
<pre><span>person</span> = {</pre>
<pre><span>name</span>:<span>"太郎"</span>,</pre>
<pre><span>age</span>:<span>"35"</span>,</pre>
<pre><span>gender</span>:<span>"男性"</span></pre>
<pre> };</pre>
<div></div>
<pre><span>for</span> (<span>n</span><span>in</span><span>person</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>n</span> +<span>": "</span> +<span>person</span>[<span>n</span>]);</pre>
<pre>}</pre></div>


<h3 id="calibre_link-256"><b>$.map()</b></h3>
<h4><b>$.map(array, function (value, index))</b></h4>
<h4><b>$.map(object, function (value, name))　Ver.1.6～</b></h4>
<p>$.map()は、第1引数に指定した配列又はオブジェクトの各アイテムに対し、第2引数に指定した関数を実行していき、その関数内からreturnしたデータを新しい配列として返します。nullやundefinedを返した場合は、その回のデータは含まれません。（＝何もreturnしなければ含まれない）</p>
<p>関数に渡される第1引数は、配列やオブジェクトの各値、第2引数は配列のインデックス番号（オブジェクトの場合は、プロパティ名）です。<strong><b>この順序は、上記の$.each()とは、真逆なことにご注意下さい。また、thisは、グローバルオブジェクト（window）を指すため、利用価値は薄いです。</b></strong></p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>var</span><span>arr</span> =<span>$</span>.<span>map</span>([<span>"太郎"</span>,<span>"次郎"</span>,<span>"三郎"</span>],<span>function</span> (<span>val</span>) {</pre>
<pre><span>return</span><span>val</span> +<span>"様"</span>;</pre>
<pre>});</pre>
<pre><span>console</span>.<span>log</span>(<span>arr</span>);</pre></div>
<p>上記を実行すると、以下のように出力されます。</p>
<p><img src="images/000066.gif" /></p>
<p>もし、returnで配列を返せば、その配列は展開され、個々の値が、配列を構成します。 また、$.each()との違いですが、$.each()は、個々の要素に対して何か処理する所にポイントがあり、 $.map()の場合は、returnして収集したデータで何かする所にポイントがあります。</p>
<p>この、$.map()は、jQueryオブジェクトに対して行う<a href="#calibre_link-144">.map()</a>メソッドとは、使い方は異なります。</p>


<h3 id="calibre_link-257"><b>eachとmapのコールバック関数の引数について</b></h3>
<p>せっかくなので、eachとmapのコールバック関数に渡される引数をまとめてみましょう。 次のようになります。（用語をシンプルにするため、オブジェクトを指定する場合は除きます）</p>
<p><img src="images/00043.jpeg" /></p>
<p>ポイントは、ユーティリティ関数の $.map() だけ異なる、ということです。 では、何故異なるのか？要は、jQueryも完璧ではないという事でしょう。ということで、以下では、引数について少し考察しています。</p>
<p>1つだけ異なる $.map() は除き、他3つについてですが、配列の各要素を操作する際、一番大事なのは、その各要素です。これは、thisを使って参照することが可能です。 なので、とりあえず引数無しでも、thisだけ使っていれば事足ります。</p>
<p>とは言え、「インデックス番号もあると便利かも」、ということで、第1引数にインデックス番号が追加されるようになった。 （、、、と勝手に推測します）</p>
<p>そして、thisも文脈によっては、意味が変わってしまうので、「ついでに、各要素も第2引数で指定できるようにしておこう」、ということで、第2引数に各要素が渡されるようになった、と考えることもできます。</p>
<p>ついでに言えば、$.map() は、thisが各要素に設定されていないので、それが最優先で第1引数に設定されています。そして、インデックス番号は、2番目に格下げされています。 $.map() だけ仲間外れにも見えますが、何気にこの次に見る $.grep() とは同じだったりします。</p>


<h3 id="calibre_link-258"><b>$.grep(array, function (value, index), invert)</b></h3>
<p>grepという用語を聞きなれない方も多いと思いますが、分かりやすく言えば、<strong><b>フィルター</b></strong>です。$.grep()は、第1引数に指定した配列の各要素に対し、第2引数に指定した関数を実行していき、その関数内からtrue（trueと評価されるもの含む）を返した場合の要素だけを収集していき、それらを新しい配列で返します。</p>
<p>関数に渡される第1引数は、配列の値、第2引数は配列のインデックス番号です。第3引数（invert、デフォルトは、false）に、trueを指定した場合は、関数内でtrueではなく、false（falseと評価されるもの含む）を返した場合にデータを収集します。 第1引数の配列が変化することはありません。</p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>var</span><span>arr</span> =<span>$</span>.<span>grep</span>([<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>],<span>function</span> (<span>val</span>) {</pre>
<pre><span>return</span><span>val</span> &gt;<span>3</span>;</pre>
<pre>});</pre></div>
<p>この結果、arrは、[4, 5] となります。 関数内で、値が3より大きい場合にtrueを返しています。</p>
<p>なお、フィルターといえば、jQueryオブジェクトに作用する<a href="#calibre_link-134">.filter()</a>メソッドもあります。</p>


<h3 id="calibre_link-259"><b>$.merge(array1, array2)</b></h3>
<p>第1引数の配列に第2引数の配列を付け足します。第1引数の配列は、<strong><b>付け足されて変化する</b></strong>のでご注意下さい。 また、その変化後の配列が、$.merge()の返り値ともなります。配列の順番は、そのまま維持されます。また、引数は2つまでです。（3つ目以降は無効です）</p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>var</span><span>arr1</span> = [<span>0</span>,<span>1</span>,<span>2</span>];</pre>
<pre><span>var</span><span>arr2</span> = [<span>2</span>,<span>3</span>,<span>4</span>];</pre>
<div></div>
<pre><span>$</span>.<span>merge</span>(<span>arr1</span>,<span>arr2</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>arr1</span>);<span>// arr1は、[0, 1, 2, 2, 3, 4] となる</span></pre></div>
<p><strong><b>元の配列arr1が、変化していることに注意して下さい。</b></strong>（第2引数はそのままです）もし、変化されるのが困る場合は、予め配列のコピーを作成し、そのコピーを使用するといいです。そのコピーを作成するのにも $.merge() が使えます。</p>
<div>
<pre><span>var</span><span>arr1</span> = [<span>0</span>,<span>1</span>,<span>2</span>];</pre>
<pre><span>var</span><span>arr2</span> = [<span>2</span>,<span>3</span>,<span>4</span>];</pre>
<pre><span>var</span><span>arr3</span> =<span>$</span>.<span>merge</span>([],<span>arr1</span>);<span>// コピーを作成する</span></pre>
<div></div>
<pre><span>$</span>.<span>merge</span>(<span>arr3</span>,<span>arr2</span>);</pre>
<div></div>
<pre><span>console</span>.<span>log</span>(<span>arr1</span>);<span>// arr1は、[0, 1, 2] のまま</span></pre>
<pre><span>console</span>.<span>log</span>(<span>arr3</span>);<span>// arr3は、[0, 1, 2, 2, 3, 4] となる。</span></pre></div>
<p>単純にarr3 = arr1; としても配列の参照が渡されarr1も変化してしまうため、上記のようにやります。</p>
<h3 id="calibre_link-260"><b>$.extend( [deep], target, object1 [, objectN ] )</b></h3>
<p>2つ以上のオブジェクトを指定し、オブジェクトを連結します。object1で指定したものが、targetに連結されます。 同じ名前のプロパティがある場合は、object1側のもので上書きされます。objectは、複数指定でき、もし同じ名前のプロパティがある場合は、より後のもので上書きされます。 （nullやundefinedの引数は、無視されます）</p>
<p>targetは、この操作により<strong><b>変更されますのでご注意下さい。</b></strong>また、その変更後のオブジェクトが、この$.extend()の返り値ともなります。省略可能な引数deepにtrueを指定すると、ディープコピーを行うようになります。</p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>var</span><span>target</span> = {</pre>
<pre><span>fruit</span>:<span>"apple"</span>,</pre>
<pre><span>price</span>:<span>100</span></pre>
<pre>};</pre>
<pre><span>var</span><span>object1</span> = {</pre>
<pre><span>price</span>:<span>200</span>,</pre>
<pre><span>num</span>:<span>5</span></pre>
<pre>};</pre>
<pre><span>$</span>.<span>extend</span>(<span>target</span>,<span>object1</span>);</pre>
<div></div>
<pre><span>// これで、targetは、以下のようになる。</span></pre>
<pre>{</pre>
<pre><span>fruit</span>:<span>"apple"</span></pre>
<pre><span>price</span>:<span>200</span>,</pre>
<pre><span>num</span>:<span>5</span></pre>
<pre>}</pre></div>
<p>もし元のtargetを上書きされたくなり場合は、代わりに空のオブジェクトを指定します。</p>
<div>
<pre><span>var</span><span>new_obj</span> =<span>$</span>.<span>extend</span>({},<span>target</span>,<span>object1</span>);</pre></div>
<p>空のオブジェクトを利用することで、オブジェクトのコピーを取るのにも役立ちます。</p>
<div>
<pre><span>var</span><span>clone</span> =<span>$</span>.<span>extend</span>({},<span>original</span>);</pre></div>
<p>また、$.extend() は、自作関数などでオプションをユーザーから受け取る際に、デフォルトのオプションと結合するのにも使えます。</p>
<div>
<pre><span>function</span><span>example</span>(<span>options</span>) {</pre>
<div></div>
<pre><span>// デフォルトのオプション</span></pre>
<pre><span>var</span><span>defaults</span> = {</pre>
<pre><span>color</span>:<span>"white"</span>,</pre>
<pre><span>animation</span>:<span>false</span>,</pre>
<pre><span>duration</span>:<span>100</span></pre>
<pre> };</pre>
<div></div>
<pre><span>var</span><span>settings</span> =<span>$</span>.<span>extend</span>({},<span>defaults</span>,<span>options</span>);</pre>
<div></div>
<pre><span>// 以下、略</span></pre>
<pre>}</pre></div>


<h4><b>ディープコピー</b></h4>
<p>deepにtrueを指定した場合は、ディープコピーとなります。
ディープコピーは、再帰的に処理していくやり方です。</p>
<p>サンプルで見てみましょう。</p>
<div>
<pre><span>var</span><span>chara1</span> = {</pre>
<pre><span>attr</span>:<span>"human"</span>,</pre>
<pre><span>skill</span>: {</pre>
<pre><span>jump</span>:<span>100</span></pre>
<pre> }</pre>
<pre>};</pre>
<pre><span>var</span><span>chara2</span> = {</pre>
<pre><span>attr</span>:<span>"wizard"</span>,</pre>
<pre><span>skill</span>: {</pre>
<pre><span>magic</span>:<span>200</span>,</pre>
<pre><span>fire</span>:<span>300</span></pre>
<pre> }</pre>
<pre>};</pre>
<pre><span>// シャロー（浅い）コピーの場合</span></pre>
<pre><span>var</span><span>ret1</span> =<span>$</span>.<span>extend</span>({},<span>chara1</span>,<span>chara2</span>);</pre>
<div></div>
<pre><span>// ret1は、以下のようになる</span></pre>
<pre>{</pre>
<pre><span>attr</span>:<span>"wizard"</span>,</pre>
<pre><span>skill</span>: {</pre>
<pre><span>magic</span>:<span>200</span>,</pre>
<pre><span>fire</span>:<span>300</span></pre>
<pre> }</pre>
<pre>}</pre>
<div></div>
<pre><span>// ディープ（浅い）コピーの場合</span></pre>
<pre><span>var</span><span>ret2</span> =<span>$</span>.<span>extend</span>(<span>true</span>, {},<span>chara1</span>,<span>chara2</span>);</pre>
<div></div>
<pre><span>// ret2は、以下のようになる</span></pre>
<pre>{</pre>
<pre><span>attr</span>:<span>"wizard"</span>,</pre>
<pre><span>skill</span>: {</pre>
<pre><span>jump</span>:<span>100</span>,<span>// ここが存在する</span></pre>
<pre><span>magic</span>:<span>200</span>,</pre>
<pre><span>fire</span>:<span>300</span></pre>
<pre> }</pre>
<pre>}</pre></div>


<h4><b>targetを省略した場合<span><b>中級</b></span></b></h4>
<p>オブジェクトを1つしか指定しない場合は、targetを省略したとみなされ、その場合は、object1で "jQuery" 自体への連結となります。 つまり、jQueryのネームスペースへプロパティや関数を設定します。ユーティリティ関数などを作成する場合に利用できます。</p>
<div>
<pre><span>$</span>.<span>extend</span>({</pre>
<pre><span>sum</span>:<span>function</span>(<span>a</span>,<span>b</span>) {</pre>
<pre><span>return</span><span>a</span> +<span>b</span>;</pre>
<pre> }</pre>
<pre>});</pre>
<div></div>
<pre><span>var</span><span>ans</span> =<span>$</span>.<span>sum</span>(<span>2</span>,<span>3</span>);<span>// ansは、5になる。</span></pre></div>


<h3 id="calibre_link-261"><b>$.inArray(value, array [, fromIndex])</b></h3>
<p>配列内に特定の要素があるかを調べ、もしある場合は最初に見つかった要素のインデックス番号を返します（JavaScriptのインデックス番号なので、0からスタートです）。 第1引数のvalueが調べる要素で、第2引数のarrayの配列内から検索します。fromIndex番号を指定し、そのインデックス番号から検索を開始することもできます。該当するデータが見つかれなければ、-1が返ります。</p>
<p>サンプルを見てみましょう。</p>
<div>
<pre><span>var</span><span>arr</span> = [<span>"taro"</span>,<span>"jiro"</span>,<span>"saburo"</span>,<span>"taro"</span>],</pre>
<pre><span>ret</span>;</pre>
<div></div>
<pre><span>ret</span> =<span>$</span>.<span>inArray</span>(<span>"taro"</span>,<span>arr</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret</span>);<span>// 0を出力</span></pre>
<div></div>
<pre><span>ret</span> =<span>$</span>.<span>inArray</span>(<span>"jiro"</span>,<span>arr</span>);</pre>
<pre><span>console</span>.<span>log</span>(<span>ret</span>);<span>// 1を出力</span></pre>
<div></div>
<pre><span>ret</span> =<span>$</span>.<span>inArray</span>(<span>"taro"</span>,<span>arr</span>,<span>1</span>);<span>// jiroから検索開始</span></pre>
<pre><span>console</span>.<span>log</span>(<span>ret</span>);<span>// 3を出力</span></pre></div>
<p>この関数は、</p>
<ul>
<li>そもそも配列内に存在するか？</li>
<li>存在する場合は、何番目か？</li>
</ul>
<p>の2つの目的で使用できます。もし、配列内に存在するかどうかだけが問題であれば、返り値が、-1かどうか（or -1以上か）で判断します。（true、falseでの判断ではないのでご注意下さい。0はfalse扱いのため）</p>
<div>
<pre><span>var</span><span>arr</span> = [<span>"taro"</span>,<span>"jiro"</span>,<span>"saburo"</span>],</pre>
<pre><span>ret</span> =<span>$</span>.<span>inArray</span>(<span>"yotarou"</span>,<span>arr</span>);</pre>
<div></div>
<pre><span>if</span> (<span>ret</span> ===<span>-1</span>) {</pre>
<pre><span>console</span>.<span>log</span>(<span>"与太郎は、居ません"</span>);<span>// こちらを出力</span></pre>
<pre>}<span>else</span> {</pre>
<pre><span>console</span>.<span>log</span>(<span>"与太郎は、居ます"</span>);</pre>
<pre>}</pre></div>
<p>ちなみに、$.inArrayは、型のチェックも厳密に行う（===を使って比較する）為、例えば文字列の'100'と数値の100は、同じと見なされません。</p>
<h3 id="calibre_link-262"><b>$.makeArray(obj)</b></h3>
<p>いわゆるJavaScriptで言う「配列のようなオブジェク」から、本当の配列を作成して返します。ノードリストやargumentsオブジェクト、jQueryオブジェクトなどが候補として考えられます。</p>
<div>
<pre><span>var</span><span>array_like</span> = {</pre>
<pre><span>0</span>:<span>"taro"</span>,</pre>
<pre><span>1</span>:<span>"jiro"</span>,</pre>
<pre><span>2</span>:<span>"saburo"</span>,</pre>
<pre><span>length</span>:<span>3</span></pre>
<pre>};</pre>
<div></div>
<pre><span>var</span><span>ret</span> =<span>$</span>.<span>makeArray</span>(<span>array_like</span>);<span>// retは、["taro", "jiro", "saburo"]となる</span></pre></div>



<h3 id="calibre_link-263"><b>$.parseJSON(json)</b></h3>
<p>JSON形式の文字列を引数に取り、JavaScriptオブジェクトに変換して返します。 形式が不正な場合は、JavaScriptの例外（エラー）が発生します。JSONは、JavaScriptのオブジェクトの記法よりも文法的に厳格ですのでご注意下さい。</p>
<div>
<pre><span>var</span><span>ret</span> ;</pre>
<pre><span>ret</span> =<span>$</span>.<span>parseJSON</span>(<span>"{test: 1}"</span>);<span>// 例外発生、testを"で括っていない</span></pre>
<pre><span>ret</span> =<span>$</span>.<span>parseJSON</span>(<span>"{'test': 1}"</span>);<span>// 例外発生、testを'で括ってしまった</span></pre>
<pre><span>ret</span> =<span>$</span>.<span>parseJSON</span>(<span>'{"test": 1}'</span>);<span>// OK。</span></pre></div>
<p>標準JSONでは、コントロール文字も許可されていません。</p>
<div>
<pre><span>var</span><span>ret</span> ;</pre>
<pre><span>ret</span> =<span>$</span>.<span>parseJSON</span>(<span>'{"testing": "1\t2\n3"}'</span>);<span>// 多くの処理系ではエラー</span></pre>
<pre><span>ret</span> =<span>$</span>.<span>parseJSON</span>(<span>'{"testing": "1\\t2\\n3"}'</span>);<span>// OK。期待する動作になる</span></pre></div>
<p>特にPHPからJavaScriptファイルに出力する場合などにご注意下さい。</p>
<p>モダンブラウザでは、元々のJavaScriptの機能のJSON.parse()が使えますので、古いブラウザは対象外でOKの場合、JSON.parse()を使ってしまうという手もあります。と言いますのも、jQuery Ver.3.0がサポートするブラウザでは、必ずJSON.parse()が使えますので、このユーティリティ関数はVer.3.0にて将来廃止予定に位置づけられました。</p>
<p>JSONをパース（デコード）する関数は上記の通りですが、JSONにエンコードする関数は、jQueryには用意されていません。その場合は、Crockford氏の<a href="https://github.com/douglascrockford/JSON-js">json2.js</a>をご利用下さい。 もし、古いブラウザのサポートが不要な場合は、ブラウザネイティブのJSON.stringify()が利用できます。</p>


</div>
<div id="calibre_link-23">
<h1 id="calibre_link-373">13章　プラグインの作り方</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-24">jQueryオブジェクト・メソッドのプラグインの作り方</a></li>
	<li><a href="#calibre_link-25">ユーティリティ関数の作り方</a></li>
	<li><a href="#calibre_link-26">一般公開用のメソッドプラグインの作り方（お決まりと作法）</a></li>
</ul>


</div>
<div id="calibre_link-311">
<h2 id="calibre_link-265">jQueryプラグインの作り方</h2>
<p>jQueryの基本の<a href="#calibre_link-55">「$ 又はjQueryの基本的な使い方」</a>で説明しましたが、jQueryには、(1)jQueryオブジェクトに作用するメソッドと(2)ユーティリティ関数の2つのタイプがあります。 まずは、(1)のjQueryオブジェクトのメソッドの作り方から見て行きましょう。（ここでは、まずは自分用のプラグインを作ることを想定しています）</p>
<p>なお、この章は中級者以上向けです。</p>
<h3 id="calibre_link-24"><b>jQueryオブジェクト・メソッドのプラグインの作り方</b></h3>
<p>全てのjQueryオブジェクト・メソッドは、jQuery.fnオブジェクトに格納されています（jQuery.fnは、prototypeオブジェクトへのショートカット）。ですので、このjQuery.fn（又は、$.fn）のプロパティに関数を登録すれば良いことになります。 まずは、簡単な例でjQueryオブジェクトの高さと幅を現在の値に+50pxするというプラグイン、.makeBig()メソッドを作ってみましょう。<br />
次のようになります。</p>
<div>
<pre><span>$</span>.<span>fn</span>.<span>makeBig</span> =<span>function</span>() {</pre>
<pre><span>this</span>.<span>width</span>(<span>"+=50"</span>);</pre>
<pre><span>this</span>.<span>height</span>(<span>"+=50"</span>);</pre>
<pre><span>return</span><span>this</span>;</pre>
<pre>};</pre></div>
<p>これを次のように呼び出して使うことができます。</p>
<div>
<pre><span>$</span>(<span>".smallBox"</span>).<span>makeBig</span>();</pre></div>
<p>これで、$(".smallBox")で選択された要素の幅と高さを+50pxします。 機能的にはやや微妙なプラグインですが、ポイントとなる部分を見てみましょう。</p>
<p>まず、<strong><b>プラグイン内のthisは、対象のjQueryオブジェクト</b></strong>を指します。この場合、$(".smallBox") です。 よくイベントハンドラーの中で、$(this) のように書きますが、ここではそのようには書きません。thisは生のDOM要素ではないからです。<br />
.width() や .height() は、jQueryに元々存在するメソッドです。 そして、最後にreturn this; としています。こうすることにより、jQueryオブジェクトを返しているので、.makeBig()メソッドの後に引き続き別のメソッドを書くことができます（＝メソッドチェーン）。 けど、もし何かの値を返すプラグインを作る場合は、当然、jQueryオブジェクトではなく、そちらの値を返すようにします。</p>
<p>上記は、下記のように簡潔に書くこともできます。</p>
<div>
<pre><span>$</span>.<span>fn</span>.<span>makeBig</span> =<span>function</span>() {</pre>
<pre><span>return</span><span>this</span>.<span>width</span>(<span>"+=50"</span>).<span>height</span>(<span>"+=50"</span>);</pre>
<pre>};</pre></div>
<p>次は、ユーザーがオプションを指定できるやり方を見てみましょう。</p>
<h4><b>ユーザーからオプションを受け取る例</b></h4>
<p>何も引数を指定しない場合、背景色は赤、フォントサイズを20pxにするというメソッド、makeNice()を作りましょう。 もし背景色やフォントサイズを指定する場合は、それぞれ、color, fontSizeをキーとするオブジェクト形式で引数に渡します。</p>
<div>
<pre><span>$</span>.<span>fn</span>.<span>makeNice</span> =<span>function</span> (<span>options</span>) {</pre>
<pre><span>var</span><span>settings</span> =<span>$</span>.<span>extend</span>({</pre>
<pre><span>// デフォルトをここで指定。指定が無い場合、ここの値が使われる。</span></pre>
<pre><span>color</span>:<span>"red"</span>,</pre>
<pre><span>fontSize</span>:<span>"20px"</span></pre>
<pre> },<span>options</span>);</pre>
<div></div>
<pre><span>this</span>.<span>css</span>(<span>"background-color"</span>,<span>settings</span>.<span>color</span>);</pre>
<pre><span>this</span>.<span>css</span>(<span>"font-size"</span>,<span>settings</span>.<span>fontSize</span>);</pre>
<pre><span>return</span><span>this</span>;</pre>
<pre>};</pre></div>
<p>次のように使用します。</p>
<div>
<pre><span>$</span>(<span>".myDiv"</span>).<span>makeNice</span>();<span>// デフォルト設定で使用</span></pre>
<div></div>
<pre><span>$</span>(<span>".myDiv"</span>).<span>makeNice</span>({</pre>
<pre><span>color</span> :<span>"blue"</span><span>// 背景色は青で</span></pre>
<pre>});</pre>
<div></div>
<pre><span>$</span>(<span>".myDiv"</span>).<span>makeNice</span>({</pre>
<pre><span>color</span> :<span>"blue"</span>,<span>// 背景色は青で</span></pre>
<pre><span>fontSize</span>:<span>"50px"</span><span>// フォントサイズは、50pxで</span></pre>
<pre>});</pre></div>


<h4><b>.each()を使った例</b></h4>
<p>もう1つ別の例を見てみましょう。今度は、img要素のaltとwidthの属性値からタイトル文字列を生成し、それをtitle属性に設定するというプラグインです。 （あくまで、altとwidthが設定されているのを前提）</p>
<div>
<pre><span>$</span>.<span>fn</span>.<span>makeTitle</span> =<span>function</span>() {</pre>
<pre><span>this</span>.<span>each</span>(<span>function</span> () {</pre>
<pre><span>var</span><span>title</span> =<span>$</span>(<span>this</span>).<span>attr</span>(<span>"alt"</span>) +<span>" / 幅："</span> +<span>$</span>(<span>this</span>).<span>attr</span>(<span>"width"</span>);</pre>
<div></div>
<pre><span>$</span>(<span>this</span>).<span>attr</span>(<span>"title"</span>,<span>title</span>);</pre>
<pre> });</pre>
<pre><span>return</span><span>this</span>;</pre>
<pre>};</pre></div>
<p>今度は、thisと$(this)が登場しています。「なんだ、さっきと言ってることが違うじゃないか！？」と言われそうですが、そうではなく、eachに指定する関数の中では、そのeach関数用のthisになるからです。 なので、その関数の中では、今までどおりの$(this)となります。</p>
<p>例えば、次のように使います。</p>
<div>
<pre><span>&lt;img</span><span>class</span>=<span>"myImg"</span><span>src</span>=<span>"abc.jpg"</span><span>alt</span>=<span>"太郎"</span><span>width</span>=<span>"50"</span><span>height</span>=<span>"50"</span><span>&gt;</span></pre>
<pre><span>&lt;img</span><span>class</span>=<span>"myImg"</span><span>src</span>=<span>"def.jpg"</span><span>alt</span>=<span>"次郎"</span><span>width</span>=<span>"100"</span><span>height</span>=<span>"100"</span><span>&gt;</span></pre></div>
<div>
<pre><span>$</span>(<span>".myImg"</span>).<span>makeTitle</span>();</pre></div>
<p>実は、上記は.each()を使わずに、下記のように書くこともできます。</p>
<div>
<pre><span>$</span>.<span>fn</span>.<span>makeTitle</span> =<span>function</span>() {</pre>
<pre><span>return</span><span>this</span>.<span>filter</span>(<span>"img"</span>).<span>attr</span>(<span>"title"</span>,<span>function</span> () {</pre>
<pre><span>return</span><span>$</span>(<span>this</span>).<span>attr</span>(<span>"alt"</span>) +<span>" / 幅："</span> +<span>$</span>(<span>this</span>).<span>attr</span>(<span>"width"</span>);</pre>
<pre> });</pre>
<pre>};</pre></div>
<p>先ほどと比べ、.filter("img") で画像に限定したりしていますが、そこはさておき、.each() の代わりに、.attr("title", function () {}) の形を取っている所がポイントです。</p>
</div>
<div id="calibre_link-322">
<h2 id="calibre_link-25">ユーティリティ関数の作り方</h2>
<p>ユーティリティ関数の作り方を見て行きましょう。こちらは、jQueryオブジェクトに何か作用するというものではありません。汎用的な関数になります。作り方は簡単で、jQueryのプロパティに対して、関数を設定すれば良いのみです。下記は、数字の引数を2つ取り、足し算した結果を返すというユーティリティ関数（$.sum）です。</p>
<div>
<pre><span>$</span>.<span>sum</span> =<span>function</span>(<span>a</span>,<span>b</span>) {</pre>
<pre><span>return</span><span>a</span> +<span>b</span>;</pre>
<pre>}</pre>
<div></div>
<pre><span>// このように使用する</span></pre>
<pre><span>var</span><span>ans</span> =<span>$</span>.<span>sum</span>(<span>2</span>,<span>3</span>);<span>// ansは、5になる。</span></pre></div>
<p>ユーティリィの章でも見ましたが、$.extend()関数を使って、ユーティリティ関数を作ることもできます。</p>
<div>
<pre><span>$</span>.<span>extend</span>({</pre>
<pre><span>sum</span>:<span>function</span>(<span>a</span>,<span>b</span>) {</pre>
<pre><span>return</span><span>a</span> +<span>b</span>;</pre>
<pre> }</pre>
<pre>});</pre></div>
<p>実際の所、このようなユーティリティ関数群は、別ファイルに独立して保存し、なお且つ、グローバルの$を使用を避けることを考慮すると、以下のような形を取るでしょう。</p>
<div>
<pre>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>.<span>sum</span> =<span>function</span>(<span>a</span>,<span>b</span>) {</pre>
<pre><span>return</span><span>a</span> +<span>b</span>;</pre>
<pre> }</pre>
<pre>}(<span>jQuery</span>));</pre></div>
<p>そもそも、わざわざユーティリティ関数なんてものにせずに、普通にJavaScriptの関数で作ればいいではないか、という話も出てきますが、jQueryの名前空間を利用することにより、グローバル領域での関数の作成を避けることができます。</p>


</div>
<div id="calibre_link-332">
<h2 id="calibre_link-26">一般公開用のメソッドプラグインの作り方（お決まりと作法）</h2>
<h3 id="calibre_link-266"><b>お決まりと作法</b></h3>
<p>さて、役立つプラグインを作ったら、一般に公開したくなってくるでしょう。 その時のお決まりと作法は、以下のようになります。</p>


<ol>
	<li value="1">JSファイルは、個別に作り、ファイル名は、jquery.xxxxx.jsの形にすること。</li>
	<li value="2">ショートカット用の$には依存しないように。つまり、お決まりのテンプレートを用いる。</li>
	<li value="3">グローバルな名前空間を汚染しない。</li>
	<li value="4">何かの値を返すのでなければ、jQueryオブジェクト（通常、this）を返すこと。</li>
	<li value="5">複数の要素がある場合を考え、each()などで処理すること。</li>
	<li value="6">複数のオプションを受け取れるようにする場合は、オブジェクト形式で受け取ること。</li>
	<li value="7">イベントハンドラーを使用する際は、イベントの名前空間を使うこと。</li>
	<li value="8">.data()を使う際は、プラグインと同等の名前を付け、1つで済ますこと（複数個使わない。1つのオブジェクトを格納して対応）</li>
	<li value="9">無駄にメソッド名を消費しない。複数のメソッド名を作りたい時は、1つのメソッドを定義し、そのメソッドの第1引数に動作を示す値を受け取って、適宜対応すること。</li>
</ol>
<p>幾つか補足しておきましょう。</p>
<h4><b>1. JSファイルは、個別に作り、ファイル名は、jquery.xxxxx.jsの形</b></h4>
<p>xxxxxは、プラグイン名になります。必要に応じてバージョンを含めます。例（jquery.tiger-1.0.js） 他のプラグインと名前がダブらないよう、あまりありきたりな名前でない方が良いでしょう。既にその名前がネット上に存在しないか、Googleなどで検索してみたり、<a href="http://plugins.jquery.com/">本家サイト</a>などでも確認してみると良いでしょう。 会社名や特定の略語などを頭に付けるのもいいかも知れません。例（jquery.fendTiger-1.0.js）</p>
<h4><b>2. ショートカット用の$には依存しないように。つまり、お決まりのテンプレートを用いる</b></h4>
<p>jQueryのショートカットの$は、他のライブラリと衝突する場合には使えません。なので、$に依存しないように書きます。 つまり、次のテンプレートがお決まりになります。</p>
<div>
<pre>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>// この中にプラグインを書く。</span></pre>
<pre>}(<span>jQuery</span>));</pre></div>
<p>これは、即行関数（or 即時関数）などと呼ばれたりします。これで、$に依存しない書き方になりつつ、内部では、$を安全に使うことができます。 更に、用心深いプログラマーは、最初の頭にセミコロン（;）を付けたりもします。</p>
<div>
<pre>;(<span>function</span> (<span>$</span>) {</pre>
<pre><span>// この中にプラグインを書く。</span></pre>
<pre>}(<span>jQuery</span>));</pre></div>
<p>これは、他のプログラムと1つに合体されて縮小された際に、余計な不具合を起こさない為の対策です。更に上を行く版では、次のようなものもあります。</p>
<div>
<pre>;(<span>function</span> (<span>$</span>,<span>window</span>,<span>document</span>,<span>undefined</span>) {</pre>
<pre><span>// この中にプラグインを書く。</span></pre>
<pre>}(<span>jQuery</span>,<span>window</span>,<span>document</span>));</pre></div>
<p>window, documentをこのようにローカル変数とすることで、縮小時に1文字に変換可能とさせるための軽量化対策と、ローカル変数化による気持ちばかりのパフォーマンスアップを狙っています。undefinedについては、（古いブラウザの）JavaScriptでは、グローバルのundefinedが上書き可能なため、それに対する予防処置です。引数としてこのように指定することによって（呼び出し側の3行目では、undefinedに対応するもの無し）、undefinedを 本来のundefinedとして安全に使うことが可能になります。<br />
なお、これの変形バージョンも存在しますが、この辺で辞めておきます。</p>
<h4><b>3. グローバルな名前空間を汚染しない</b></h4>
<p>上記2番のテンプレートを使いつつ、且つ変数をvarを使って宣言すれば、グローバルな領域を汚さないで済みますね。 そもそも2番のテンプレートは、そういう意味＆目的もあります。</p>
<h4><b>9. 無駄にメソッド名を消費しない</b></h4>
<p>jQuery UIをかじった事がある人は、すぐに分かると思います。本家サイトで紹介している例で見てみましょう。<br />
こちらが悪い例です。</p>
<div>
<pre>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>.<span>fn</span>.<span>openPopup</span> =<span>function</span>() {</pre>
<pre><span>// ポップアップを開く処理</span></pre>
<pre> };</pre>
<pre><span>$</span>.<span>fn</span>.<span>closePopup</span> =<span>function</span>() {</pre>
<pre><span>// ポップアップを閉じる処理</span></pre>
<pre> };</pre>
<pre>}(<span>jQuery</span>));</pre></div>
<p>openPopupとclosePopupという2つのメソッド名を消費しています。<br />
そして、こちらが良い例です。</p>
<div>
<pre>(<span>function</span> (<span>$</span>) {</pre>
<pre><span>$</span>.<span>fn</span>.<span>popup</span> =<span>function</span> (<span>action</span>) {</pre>
<pre><span>if</span> (<span>action</span> ===<span>"open"</span>) {</pre>
<pre><span>// ポップアップを開く処理</span></pre>
<pre>  }</pre>
<pre><span>if</span> (<span>action</span> ===<span>"close"</span>) {</pre>
<pre><span>// ポップアップを閉じる処理</span></pre>
<pre>  }</pre>
<pre> };</pre>
<pre>}(<span>jQuery</span>));</pre></div>
<p>それぞれの例の場合、どのように使うか見ておきましょう。</p>
<div>
<pre><span>// 悪い例の場合</span></pre>
<pre><span>$</span>(<span>".myDiv"</span>).<span>openPopup</span>();</pre>
<pre><span>$</span>(<span>".myDiv"</span>).<span>closePopup</span>();</pre>
<div></div>
<pre><span>// 良い例の場合</span></pre>
<pre><span>$</span>(<span>".myDiv"</span>).<span>popup</span>(<span>"open"</span>);</pre>
<pre><span>$</span>(<span>".myDiv"</span>).<span>popup</span>(<span>"close"</span>);</pre></div>
<p>メソッド名を無駄に消費しない。それがポイントです。</p>
<p>さて、幾つか見て来ましたが、実は、より使いやすいプラグイン（よりイケてるプラグイン）を書くための方法が<a href="http://learn.jquery.com/plugins/advanced-plugin-concepts/">本家サイト</a>には紹介されていますが、そちらについては、上級者向けになるため省略させていただきます。</p>


</div>
<div id="calibre_link-289">
<h1 id="calibre_link-374">14章　その他</h1>
<p>この章で見る主な内容です。</p>


<ul>
	<li><a href="#calibre_link-268">jQuery Migrate</a></li>
	<li><a href="#calibre_link-271">jQuery1.12、2.2の条件付き読み込み</a></li>
	<li><a href="#calibre_link-272">主な廃止された機能</a></li>
</ul>
</div>
<div id="calibre_link-1">
<h2 id="calibre_link-268">jQuery Migrate</h2>
<h3 id="calibre_link-269"><b>jQuery1.9以上への移行</b></h3>
<p>2016年6月にjQuery Ver.3.0が正式にリリースされましたが、実際の現場では、まだまだVer.1.9前後辺りが多く使われているのが実情です。そして、<strong><b>Ver.1.9系からは、多くの機能が削除されています。その為、Ver.1.9は、大きな通過点となります。</b></strong>そこでVer.1.9未満からVer.1.9以上にスムーズに移行するために「jQuery Migrate」というものが用意されています。 このjQuery Migrateを使うと、Ver.1.9で削除された機能を復元することができ、また古い書き方があれば、それを警告表示することができます。Ver.1.9は、今となっては、もはや古い部類に入ってきますが、実際の現場では、更に古いバージョンが使われていたりもします。</p>
<p>jQuery Migrateの基本的な使い方は、jQueryを読み込んだ後に、jQuery Migrateを読み込みます。jQuery Migrateは、jQuery Ver.1.6.4～から読み込むことができますが、実際に復元機能が働くのは、対象の機能が削除されたVer.1.9以上となります。 jQuery Migrateには、開発用と本番用（縮小版）があり、警告が表示されるのは、開発用の場合になります。本番用では、復元機能のみ働きます。 警告は、ブラウザのコンソール画面（FirefoxのFirebugなど）に出力されます。 jQuery Migrateは、本家サイトの<a href="http://jquery.com/download/">ダウンロードページ</a>から行えますが、CDNを使ってしまう方が楽でいいでしょう。</p>
<p>では、実際に使ったイメージを見てみましょう。CDNを利用します。<br />
ここでは、ブラウザ情報を取得するjQuery.browserを使ってみます。これは、Ver.1.9からは、機能が削除されています。</p>
<p>まずは、jQuery Migrateを使わない場合です。</p>
<div>
<pre><span>&lt;!-- Ver1.12.4において --&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"js/jquery-1.12.4.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>console</span>.<span>log</span>(<span>jQuery</span>.<span>browser</span>);<span>// ブラウザ情報を表示</span></pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>コンソールに次の表示がされます。ブラウザ情報は取得されません。</p>
<p><img src="images/000058.gif" /></p>
<p>次に、jQuery Migrateの開発版を使ってみます。</p>
<div>
<pre><span>&lt;!-- jQuery Ver1.6.4でも同じ結果 --&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"js/jquery-1.12.4.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"http://code.jquery.com/jquery-migrate-1.4.1.js"</span><span>&gt;&lt;/script&gt;</span><span>&lt;!-- 開発版 --&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>console</span>.<span>log</span>(<span>jQuery</span>.<span>browser</span>);<span>// ブラウザ情報を表示</span></pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>機能が削除されているにも関わらず、ブラウザ情報を無事に取得できました。</p>
<p><img src="images/000076.gif" /></p>
<p>次に、jQuery Migrateの本番用を使った場合です。</p>
<div>
<pre><span>&lt;!-- jQuery Ver1.6.4でも同じ結果 --&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"js/jquery-1.12.4.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"http://code.jquery.com/jquery-migrate-1.4.1.min.js"</span><span>&gt;&lt;/script&gt;</span><span>&lt;!-- 本番用 --&gt;</span></pre>
<div></div>
<pre><span>&lt;script&gt;</span></pre>
<pre><span>console</span>.<span>log</span>(<span>jQuery</span>.<span>browser</span>);<span>// ブラウザ情報を表示</span></pre>
<pre><span>&lt;/script&gt;</span></pre></div>
<p>警告表示はありません。ですが、ブラウザ情報を無事に取得できました。</p>
<p><img src="images/000013.gif" /></p>
<p>警告メッセージは他にも沢山あります。<a href="https://github.com/jquery/jquery-migrate/blob/master/warnings.md">こちらのサイト（英語）</a>に詳細の説明があります。</p>
<p>jQuery Migrateを使うと以前の機能を復活できてしまうのでそこで安心してしまいますが、正式に移行する際は、Migrateの開発版を使って警告が出た箇所を警告が出ないように修正し、Migrateを外しても警告やエラーが表示されないようにして、移行しましょう。</p>



<h3 id="calibre_link-270"><b>jQuery3.0以上への移行</b></h3>
<p>Ver.3.0以上へ移行する際の手順は、まずは上記で見た方法でVer.1系、2系の最新版に移行します。その後、Ver.3.0用のjQuery Migrate（jQuery Migrate 3.0）を使用して、上記と同様の手順で移行します。Ver.1.9の時ほど多くの人に影響は与えないと言われています。</p>
<p>参考サイト<br />
<a href="https://github.com/jquery/jquery-migrate">Migrate older jQuery code to jQuery 3.0+（英語）</a></p>




</div>
<div id="calibre_link-281">
<h2 id="calibre_link-271">jQuery1.12、2.2の条件付き読み込み</h2>
<p>最新のブラウザでは、よりスリムで軽いVer.2.2を読み込ませ、時代遅れのIE6～8では、Ver.1.12を読みこませる方法があります。 IEの条件付きコメントを使います。</p>
<p>以下のようになります。</p>
<div>
<pre><span>&lt;!--[if lt IE 9]&gt;</span></pre>
<pre><span>&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;![endif]--&gt;</span></pre>
<pre><span>&lt;!--[if gte IE 9]&gt;&lt;!--&gt;</span></pre>
<pre><span>&lt;script</span><span>src</span>=<span>"jquery-2.2.4.js"</span><span>&gt;&lt;/script&gt;</span></pre>
<pre><span>&lt;!--&lt;![endif]--&gt;</span></pre></div>
<p>細かく上記の条件分岐（if文）を眺めた方は、一瞬「あれ？」と思うかも知れません。 上側の条件分岐では、「IE9未満の場合」となっています。 下側の条件分岐では、「IE9以上の場合」と見て取れますが、では、IE以外はどうなってしまうのか？ よくよく見ると、下側の方は余計なコメントが多いのが分かります。 これで、下側の方は、「IE9以上とIE以外のブラウザ」で読み込まれることになります。</p>
<p>参考サイト<br />
<a href="http://blog.jquery.com/2012/06/28/jquery-core-version-1-9-and-beyond/">本家サイトのブログ（英語）</a><br />
<a href="http://ja.wikipedia.org/wiki/%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88">条件付きコメント（Wiki）</a></p>
</div>
<div id="calibre_link-292">
<h2 id="calibre_link-272">主な廃止された機能</h2>
<p>ここでは、jQuery Ver.1.8以降に廃止された機能を見ていきます。<strong><b>主なもの限定</b></strong>です。</p>
<p>その前に少し整理ですが、ある機能が廃止される場合、jQueryでは、いきなり廃止されるのではなく、<strong><b>「将来廃止予定（deprecated）」</b></strong>という状態を経て、<strong><b>「削除済み（removed）」</b></strong>となります。以下、既に削除されたものについては、将来廃止予定の記述は省略し、削除された旨のみ記載しています。それと、日本語でただ単に「廃止」と言うと、削除されたのか、これから削除されるのか、分かりにくいですね。その点、英語（deprecated、removed）は明確な気がします。</p>
<p>参考サイト<br />
<a href="https://jquery.com/upgrade-guide/1.9/">jQuery Core 1.9 Upgrade Guide（本家サイト）</a></p>
<a href="https://jquery.com/upgrade-guide/3.0/">jQuery Core 3.0 Upgrade Guide（本家サイト）</a>


<h3><b>jQuery 1.8で将来廃止予定（deprecated）と位置づけられたもの</b></h3>
<h4><b>.andSelf()</b></h4>







代わりに、<a href="#calibre_link-138">.addBack()</a>を使用します。AJAX用の<a href="#calibre_link-195">.load()</a>は、未だ健在です。


<h4><b>.size()</b></h4>
<p>代わりに、<a href="#calibre_link-141">.length</a>を使用します。</p>



<h3 id="calibre_link-274"><b>jQuery 1.9で削除されたもの（removed）</b></h3>
<h4><b>.toggle(func(), func() ...)</b></h4>
<p>マウスイベント用の<a href="#calibre_link-164">.toggle()</a>が削除されました。マウスをクリックする度に、引数で指定した関数が順番に実行されていくというメソッドです。</p>
<p>アニメーション用の<a href="#calibre_link-213">.toggle()</a>は、未だ健在です。「いないいないばあ」する方です。</p>
<h4><b>jQuery.browser</b></h4>
<p>代わりに、Modernizrと呼ばれるライブラリを使いましょう。</p>
<h4><b>.live()、.die()</b></h4>
<p>代わりに、.on()、.off()を使いましょう。</p>
<h4><b>擬似イベント"hover"</b></h4>
<p>.hover()メソッドではなく、hover擬似イベントと呼ばれるものが削除されました。 （指定したところでエラーは起こらないでしょうが、動作しません） 詳しくは、<a href="#calibre_link-163">..hover()メソッド と .on() と "hover"擬似イベント</a>にて。</p>






<h3 id="calibre_link-275"><b>jQuery 3.0で将来廃止予定（deprecated）と位置づけられたもの</b></h3>
<h4><b>$.parseJSON()</b></h4>
<p>代わりに、JSON.parse()を使います。</p>


<h4><b>.bind()、.unbind()、.delegate()、.undelegate()</b></h4>
<p>代わりに.on()、.off()を使います。</p>


<h4><b>jQuery(function) 形式以外のドキュメント構築後の関数登録</b></h4>
<p>下記でご確認下さい。後半はあまり見かけないかも知れません。（fnは、function（関数）の事です）</p>
<div>
<pre><span>// OK</span></pre>
<pre><span>jQuery</span>(<span>fn</span>);</pre>
<pre><span>$</span>(<span>fn</span>);</pre>
<div></div>
<pre><span>// 将来廃止予定</span></pre>
<pre><span>$</span>(<span>document</span>).<span>ready</span>(<span>fn</span>);</pre>
<pre><span>$</span>().<span>ready</span>(<span>fn</span>);</pre>
<pre><span>$</span>(<span>"selector"</span>).<span>ready</span>(<span>fn</span>);</pre>
<div></div>
<pre><span>// 下記は、削除</span></pre>
<pre><span>$</span>(<span>document</span>).<span>on</span>(<span>"ready"</span>,<span>fn</span>);</pre></div>


<h4><b>$.unique()</b></h4>
<p>本書では登場しませんでしたが、$.unique() が、$.uniqueSort() へと名称変更される為です。</p>




<h3 id="calibre_link-276"><b>jQuery 3.0で削除されたもの（removed）</b></h3>
<h4><b>.load()、.unload()、.error()</b></h4>
<p>ショートカット用イベントの上記3つが削除されました。同様の機能は、.on()を使って実現させます。AJAX用の<a href="#calibre_link-195">.load()</a>は、未だ健在です。</p>


<h4><b>.$(document).on("ready", fn);</b></h4>
<p>上記でも出てきましたが、あまり見慣れないこの形式は、削除となります。</p>


</div>
<div id="calibre_link-308">
<h1 id="calibre_link-375">あとがき</h1>
<p>本書を最初からここまで読まれた皆さんは、これでjQueryの基礎はしっかり学んだことと思います。後は、実践あるのみです。あいにく、本書には実践サンプルのようなものはありません。しかし、そのようなものは、WEBを検索すれば、幾らでも出てきます。例えば、タブやアコーディオン、jQueryでやるにはどうしたら良いのか？今この段階ではボンヤリしか分からなくても、Googleで検索すれば、幾らでもヒットします。jQueryを理解された皆さんであれば、WEBで見つけたサンプルを見れば、それらを理解し、簡単に使いこなせるでしょう。<br />
実際、筆者もネットサーフィンをしていると、「これ、どうやってやっているんだろう？」と思うこともありますが、WEBで検索したり、はてまた、そのプログラムを読んだりすることで、理解し、応用できるようにしています。</p>
<p>是非、jQueryを活用し、楽しいサイト作成を行って下さい。</p>
<p><a href="http://www.amazon.co.jp/gp/product/B00HE4R9H2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00HE4R9H2&amp;linkCode=as2&amp;tag=amazonzon0205-22"><img src="images/000033.gif" alt="jQuery入門道場" /></a></p>
<p>&nbsp;</p>
<p>ホームページ：<a href="http://jquery-master.net/">http://jquery-master.net/</a><br />
執筆：株式会社フェンドーラ 白岩登</p>



</div>
<div id="calibre_link-319">
<h2 id="calibre_link-278">筆者による他の書籍の紹介です</h2>
<p><a href="http://www.amazon.co.jp/gp/product/B00I204T8Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00I204T8Y&amp;linkCode=as2&amp;tag=amazonzon0205-22"><img src="images/000048.gif" alt="Google Maps JavaScript API V3 入門マスター" /></a></p>
<p><a href="http://www.amazon.co.jp/gp/product/B00I204T8Y/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00I204T8Y&amp;linkCode=as2&amp;tag=amazonzon0205-22">Google Maps JavaScript API V3 入門マスター</a></p>





</div>
<div id="calibre_link-309">
<h2 id="calibre_link-279">改定履歴</h2>
<p>バージョンは、新しい順に記載しております。</p>


<h4><b>2016年6月10日　ver 2.0</b></h4>
<p>jQuery3.0に対応しました。</p>


<h4><b>2015年12月2日　ver 1.71</b></h4>
<p>誤字・脱字を修正しました。</p>


<h4><b>2014年8月3日　ver 1.7</b></h4>
<p>一部画像を調整しました。また、細かい誤字を修正しました。</p>


<h4><b>2014年6月24日　ver 1.6</b></h4>
<p>改行の幅を端末側で調整できるようにしました。また、キュー周りの解説を少し見直しました。</p>


<h4><b>2014年4月5日　ver 1.5</b></h4>
<p>「アニメーションの連続実行対策」を追加。</p>


<h4><b>2014年3月1日　ver 1.4</b></h4>
<p>:checkboxなどについて少し情報追加。fadeIn系で問題文を1つ追加。ajaxのtraditional周りで情報追加。.index()を追加。</p>


<h4><b>2014年2月14日　ver 1.3</b></h4>
<p>イベント委譲と.show()、.hide()に少し説明を追加しました。また:eq()に問題文を追加しました。</p>


<h4><b>2014年1月29日　ver 1.2</b></h4>
<p>ver1.1でコード部分が右に溢れて最後まで表示されない問題を修正しました。また、改訂履歴を付けました。</p>


<h4><b>2014年1月7日　ver 1.1</b></h4>
<p>リンク機能で移動すると、数ページ先でページが乱れることがあるのを修正しました。</p>


<h4><b>2013年12月18日　ver 1 （初版）</b></h4>
<p>初版出版しました。</p>
</div>




<script>function myFunction(){document.getElementById("tateyoko").classList.toggle("tateread")}</script></body></html>
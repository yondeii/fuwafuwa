<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ゲームを作りながら楽しく学べるHTML5+CSS+JavaScriptプログラミング (NextPublishing)</title>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/css/mainday.css" title="default">
<link rel="alternate stylesheet" href="/css/mainnight.css" title="alternate">
<script type="text/javascript" src="/js/styleswitcher.js"></script>
<script type="text/javascript" src="/js/global.js"></script>
</head>
<body>
<div class="novelpage">
<div class="novelbody">
<div id="tateyoko">
<div id="_top"></div>
<a href="/">🏠</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('default'); return false;">日</a>&emsp;
<a href="#" onclick="setActiveStyleSheet('alternate'); return false;">月</a>&emsp;
<a href="#_top" onclick="myFunction()" style="cursor: pointer;">縦書き／横書き</a>
<div id="calibre_link-120">
<div>
<div>
<table class="noveltitle">
<tr>
<td colspan="2"><i><span><i>ゲームを作りながら楽しく学べるHTML5+CSS+JavaScriptプログラミング (NextPublishing)</i></span></i></td>
</tr>
<tr>
                    
                    
      </tr>
<tr>
<td colspan="2">田中 賢一郎</td>
</tr>
<tr>
<td colspan="2"> (2013)</td>
</tr>
<tr>
<td colspan="2"></td>
</tr>
</table>
<div></div>
</div>
<div>
<p>若い人向けに、楽しく学ぶことができるようにゲームを中心にしたサンプルを豊富に取り上げます。また、習得した知識を確認するための演習も満載。プログラミング上達の早道はなによりコードを読み、コードを書いてみることという筆者の経験から、リストを読み、実際に書いてもらうことを目指します。本書前半はプログラミング経験のまったくない人を対象に、HTML、CSS、JavaScriptの基本知識を解説。平板な解説に陥らないように、豊富なサンプルと演習が用意されています。本書後半は誰でもなじみのあるブロック崩し、テトリスライクなゲームを作成していきます。サンプルは、コード入力の負担が過度に大きくないこと、コードがわかりやすいこと、ちょっとした驚きがあることを心がけています。読者が自分で入力・確認してく過程で、プログラミングのスキルを身に着けることができるでしょう。</p>
</div>
</div>
</div>



<div id="calibre_link-134">
<h1 id="calibre_link-193"><b>目次</b></h1>
<ol>
<li value="1">
<a href="#calibre_link-135">はじめに</a>
</li>
<li value="2">
<a href="#calibre_link-136">電子書籍閲覧に関するご注意</a>
</li>
<li value="3">
<a href="#calibre_link-137">本書の動作環境</a>
</li>
<li value="4">
<a href="#calibre_link-138">第1章　HTML入門</a>
<ol>
<li value="1">
  <a href="#calibre_link-139">1-1　はじめてのHTML</a>
</li>
<li value="2">
  <a href="#calibre_link-140">1-2　画像の表示</a>
</li>
<li value="3">
  <a href="#calibre_link-141">1-3　DOM（Document Object Model）</a>
</li>
<li value="4">
  <a href="#calibre_link-142">1-4　イベント</a>
</li>
<li value="5">
  <a href="#calibre_link-143">1-5　デバッグのコツ</a>
</li>
</ol>
</li>
<li value="5">
<a href="#calibre_link-144">第2章　CSS入門</a>
<ol>
<li value="1">
  <a href="#calibre_link-145">2-1　Webページの見映えを設定する</a>
</li>
<li value="2">
  <a href="#calibre_link-146">2-2　インラインスタイル</a>
</li>
<li value="3">
  <a href="#calibre_link-147">2-3　style要素内にCSSを記述する</a>
</li>
<li value="4">
  <a href="#calibre_link-148">2-4　link要素でCSSファイルを参照する</a>
</li>
<li value="5">
  <a href="#calibre_link-149">2-5　ページのレイアウト</a>
</li>
<li value="6">
  <a href="#calibre_link-150">2-6　色や長さの指定</a>
</li>
<li value="7">
  <a href="#calibre_link-151">2-7　主なスタイル</a>
</li>
</ol>
</li>
<li value="6">
<a href="#calibre_link-152">第3章　JavaScript入門</a>
<ol>
<li value="1">
  <a href="#calibre_link-153">3-1　プログラミング言語とは</a>
</li>
<li value="2">
  <a href="#calibre_link-154">3-2　変数</a>
</li>
<li value="3">
  <a href="#calibre_link-155">3-3　コメント</a>
</li>
<li value="4">
  <a href="#calibre_link-156">3-4　配列</a>
</li>
<li value="5">
  <a href="#calibre_link-157">3-5　演算子</a>
</li>
<li value="6">
  <a href="#calibre_link-158">3-6　条件式</a>
</li>
<li value="7">
  <a href="#calibre_link-159">3-7　制御式</a>
</li>
<li value="8">
  <a href="#calibre_link-160">3-8　関数</a>
</li>
<li value="9">
  <a href="#calibre_link-161">3-9　デバッグ</a>
</li>
<li value="10">
  <a href="#calibre_link-162">3-10　DOMの操作</a>
</li>
<li value="11">
  <a href="#calibre_link-163">3-11　オブジェクトの操作</a>
</li>
<li value="12">
  <a href="#calibre_link-164">3-12　組み込みオブジェクト</a>
</li>
<li value="13">
  <a href="#calibre_link-165">3-13　JSON記法</a>
</li>
</ol>
</li>
<li value="7">
<a href="#calibre_link-166">第4章　Canvas</a>
<ol>
<li value="1">
  <a href="#calibre_link-167">4-1　コンテキスト</a>
</li>
<li value="2">
  <a href="#calibre_link-168">4-2　描画の方法</a>
</li>
<li value="3">
  <a href="#calibre_link-169">4-3　文字</a>
</li>
<li value="4">
  <a href="#calibre_link-170">4-4　画像</a>
</li>
<li value="5">
  <a href="#calibre_link-171">4-5　座標系</a>
</li>
</ol>
</li>
<li value="8">
<a href="#calibre_link-172">第5章　ゲームプログラミングに挑戦</a>
<ol>
<li value="1">
  <a href="#calibre_link-173">5-1　Canvasを使った基礎的なゲーム</a>
</li>
<li value="2">
  <a href="#calibre_link-174">5-2　横方向にスクロールするゲーム</a>
</li>
<li value="3">
  <a href="#calibre_link-175">5-3　DOMを使ったパズルゲーム</a>
</li>
<li value="4">
  <a href="#calibre_link-176">5-4　ボールの反射を応用したゲーム</a>
</li>
<li value="5">
  <a href="#calibre_link-177">5-5　シューティングゲーム（1）</a>
</li>
<li value="6">
  <a href="#calibre_link-178">5-6　シューティングゲーム（2）</a>
</li>
<li value="7">
  <a href="#calibre_link-179">5-7　全方位スクロールゲーム</a>
</li>
<li value="8">
  <a href="#calibre_link-180">5-8　リアルタイム陣取りゲーム</a>
</li>
<li value="9">
  <a href="#calibre_link-181">5-9　落ちもの系ゲーム</a>
</li>
</ol>
</li>
<li value="9">
<a href="#calibre_link-182">あとがき</a>
</li>
<li value="10">
<a href="#calibre_link-183">著者紹介</a>
</li>
</ol>
</div>
<div id="calibre_link-51">
<section>
<hgroup>
<h1 id="calibre_link-135"><b>はじめに</b></h1>
</hgroup>
</section>
</div>
<div id="calibre_link-89">
<section>
<h2 id="calibre_link-194"><b>プログラムのスキル ＝ コードを読む量 × コードを書く量</b></h2>
<p>　畳の上で水泳の練習をしても泳げるようにはなりません。本を読んだだけでゴルフが上達することもないでしょう。どちらも自分の体で覚えることが大切です。プログラミングも同じです。本を読んだだけ、授業を受けただけで上達することは困難です。</p>
<p>　一方、すべて独学で習得することも非効率と言わざるを得ません。スイミングスクールに通ったり、ゴルフ教室に通ったりすることで習得のスピードは劇的に向上します。プログラミングも同じです。すべて独学で勉強するのは大変です。先人の知恵とも言える良質のコードに触れ、そこから盗むことでいろいろと吸収することができます。</p>
<p>　このように、コードを読んで、コードを書いて、というプロセスを繰り返すことがプログラミング上達の王道だと思います。幸いにも筆者は世界各国からの優秀なプログラマーと働く機会に恵まれましたが、彼らの多くが学生の頃から趣味でプログラミングをしていたそうです。</p>
<p>　自分も子供の頃は、ゲームをしたいばかりに、雑誌を読みながらプログラムをコツコツと入力したものでした。いろいろなゲームを入力して、その動作する様子を実感することで、プログラムがどのように動くのかを習得できたように思います。</p>
<p>　最近は、ソースコードを掲載する雑誌も少なくなり、わざわざ自分で入力しなくても簡単にゲームが入手できるような環境となりました。このようなことが原因かと思いますが、自分でゲームを入力する機会がほとんどなくなってしまったことが残念でなりません。</p>
<p>　そんな状況に一石を投じたいという思いから、プログラミングを始めたいという方のために、いくつかゲームを作ってみました。サンプルとなるゲームを作るにあたり、コード入力の負担が過度に大きくないこと、コードがわかりやすいこと、ちょっとした驚きがあること（このゲームはこんな風に実装されているのか！）という点に心がけました。</p>
<p>　ゲームで遊ぶのも楽しいかもしれませんが、自分で作って改造するのも同じくらい楽しいものです。そんな楽しさを通して、プログラミングのスキルを身に着けていただきたいと思っています。ゲームをやったことは履歴書に書けませんが、ゲームを作ったことは履歴書に書けるかもしれません！</p>
<p>
<br />
</p>
<p>　それでは、コードを読んで、コードを書いて、というプロセスを効率よく進めるにはどうすればよいでしょうか？いろいろな要因があるとは思いますが、その中でも特に重要と思われるものを以下に列挙します。</p>
<h3 id="calibre_link-195">■本人のやる気</h3>
<p>　なによりも大切です。アプリを作りたい、コンピュータのことを知りたい、プログラムを書けるようになりたい、このような本人のモチベーションがなければ始まりません。まずこのような気持ちを持つことが大切です。</p>
<h3 id="calibre_link-196">■没頭できる環境</h3>
<p>　自分が好きに使えるパソコンの存在も重要です。未成年の方は、保護者の方に相談してみましょう。将来の投資ということで真剣にお願いすれば買ってくれるかもしれません。もちろん、買ってもらえた暁には、期待を裏切らないようしっかりと精進することが大切です。</p>
<h3 id="calibre_link-197">■身近にいる詳しい人</h3>
<p>　プログラミングに慣れないうちは必ずつまずくことがあるでしょう。どうしても困ったときに質問できる人が周囲にいるのといないのでは状況が大きく異なります。学校の先生や、パソコンに詳しい友人など、人脈をたどってぜひとも見つけるようにしてください。ただし、まずは自分で解決策を探すことが大切です。どうしてもわからないときに聞くようにしてください。</p>
<p>
<br />
</p>
<p>　前置きはこの位で十分です。本書がプログラミングに親しむきっかけになることを切に願っています。楽しんでください！</p>
<p>
<br />
</p>
<p>田中　賢一郎</p>
</section>
</div>
<div id="calibre_link-55">
<section>
<hgroup>
<h1 id="calibre_link-136"><b>電子書籍閲覧に関するご注意</b></h1>
</hgroup>
<p>本書では、プログラムリストに専用の等幅フォントを使用しています。ビューアによって以下の作業が必要になります。</p>
<p>・Kindle Paperwhiteの場合：フォント設定画面で「出版者のフォント」を選択</p>
<p>・kobo Androidアプリの場合：フォント画面で「オリジナル」を選択</p>
</section>
</div>
<div id="calibre_link-107">
<section>
<hgroup>
<h1 id="calibre_link-137"><b>本書の動作環境</b></h1>
</hgroup>
<p>　本書で扱っているのはHTML/CSS/JavaScriptの基本的な内容です。解説・執筆環境はWindowsのInternet Explorer、Google Chromeで行っています。</p>
<p>　なお、CanvasはHTML5で導入された機能なので、古いブラウザでは動きません。もし意図したように描画されなかったときは、ブラウザの最新版をインストールしてください。IEなら9以降、Chromeなら3.0以降であれば大丈夫でしょう。</p>
<p>　プログラムを入力するためのエディターは好きなものを使っていただいてかまいません。Windowsであればメモ帳でも可能です。しかしながら、効率よく作業するためにはIDE（Integrated Development Environment：統合開発環境）を使用することを強くおすすめします。Visual Studio ExpressやEclipseといったIDEは無料で入手することも可能です。入力候補となる内容を提示してくれたり、プログラムの見た目を整えて読みやすくしてくれたり、デバッグ用の環境が統合されていたり、と作業効率を格段に向上させることができるはずです。</p>
<p>　また、本書に掲載しているプログラムはパソコン単体で動作します。Webサーバーなどを用意する必要はありません。Internetに接続していないパソコンでも実行可能です。最近のゲームの多くはなんらかのライブラリを使用することも多いようですが、そのようなライブラリも一切使用していません。プログラミングの基本、楽しさといったところにフォーカスしたかったのでそのようなスタンスで書き進めていきました。</p>
<p>
<br />
</p>
<section>
<p>※本書の内容は、執筆時点での情報をもとに書かれています。個々のソフトウエアのアップデート状況や、使用者の環境によって、本書の記載と異なる場合があります。<br />
　本書に記載されているURLは、本書執筆後に変更される可能性があります。<br />
　本書の内容およびサンプルの実施・運用において発生したいかなる損害も株式会社インプレスR&amp;Dと著者は一切の責任を負いません。</p>
</section>
</section>
</div>
<div id="calibre_link-99">
<div>
<h1 id="calibre_link-138"><b>第1章　HTML入門</b></h1>
<h2 id="calibre_link-198"><b>HTMLはホームページを書くための言語</b></h2>
</div>
<section>
<p><b>　Webには、ニュース、SNS、ゲーム、ショップなど多種多様なサイトがあります。これらはさまざまな技術を使って構築されていますが、基本は「HTML」（Hyper Text Markup Language）という言語です。いろいろなページのHTMLを見たり、本書のサンプルを書いたりしながら、HTMLの基礎知識を身につけましょう。</b></p>
</section>
</div>
<div id="calibre_link-86">
<section>
<hgroup>
<h1 id="calibre_link-139"><b>1-1　はじめてのHTML</b></h1>
</hgroup>
<p>　「HTML」（Hyper Text Markup Language）とはホームページを書くための言語です。みなさんが見ているホームページもすべてこのHTMLという言語で書かれています。なにはともあれ、どんなものか見てみましょう。ブラウザーでページを表示し、画面上を右クリックして「ソースの表示」（Internet Explorerの場合）という項目を選びます。</p>
<figure>
<img src="images/00045.jpeg" />
<figcaption>Internet Explorer</figcaption>
</figure>
<p>　Google Chromeでは「ページのソースを表示」を選びます。</p>
<figure>
<img src="images/00098.jpeg" />
<figcaption>Google Chrome</figcaption>
</figure>
<p>　ブラウザーによって表示状態は異なりますが、以下のようなHTMLの内容が表示されます。</p>
<figure>
<img src="images/00138.jpeg" />
<figcaption>HTMLの内容</figcaption>
</figure>
<p>　パッと見、非常に複雑そうに見えますが、基本から順番にはじめていけば大丈夫です。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>いろいろなページの内容を見てみましょう。</p>
<hr />
</section>
</div>
<div id="calibre_link-28">
<section>
<h2 id="calibre_link-199"><b>1-1-1　HTML文書の基本構成</b></h2>
<p>　HTML文書はざっくりと以下のような構成になっています。「&lt;」や「&gt;」がたくさんあります。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;title&gt;タイトル&lt;/title&gt;</code>
<code>        &lt;style&gt;</code>
<code>                ここにスタイル（見た目）を記述</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>                ここにスクリプト（プログラム）を記述</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>                ここに文書を記述</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　「&lt;」と「&gt;」に囲まれた部分を「タグ」もしくは「要素」とも呼びます。これらは、ほぼ同じ意味で使われます。ちなみに英語ではtagやelementと呼びますが、辞書でtagを調べると「区別する、タグを付ける、認識する」などと説明されています。つまり、文書の特定の部分に特別な意味を与えるために使うものなのです。</p>
<p>　たとえば、ある部分を斜体で表現したい場合は、「天気は&lt;i&gt;快晴&lt;/i&gt;です」のように記述します。こうすると「快晴」の部分だけが斜体で表示されます。つまり、特定の部分に特別な意味を与えているのです。これこそがタグの本質です。</p>
<figure>
<img src="images/00089.jpeg" />
<figcaption>斜体の設定</figcaption>
</figure>
<p>　じつは、みなさんがレポートや感想文を書くときにも、知らず知らずのうちに同じことをしています。題、日付、著者名、段落、章、節、脚注、下線...これらはタグが行っていることとまったく同じなのです。これから、難しい用語がたくさん出てきますが、じつは、今までごく自然に触れてきたことを厳密に表現しているだけなのです。最初はとまどうかもしれませんがすぐに慣れるので安心してください。</p>
<p>　必要のない部分は省略することができます。より簡単な具体例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;body&gt;</code>
<code>&lt;h1&gt;タイトル&lt;/h1&gt;</code>
<code>&lt;p&gt;これは&lt;b&gt;パラグラフ&lt;/b&gt;です&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00168.jpeg" />
<figcaption>ブラウザーの表示</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>上のHTMLを入力して表示してみましょう</p>
<p>1）メモ帳を開く</p>
<p>2）上記のコードを入力</p>
<p>3）「Sample1.html」として保存</p>
<p>4）そのファイルをダブルクリックして表示する（ダブルクリックしてもブラウザーが立ち上がらない場合はファイルの拡張子が正しく設定されているか確認してください。「1-5-5 拡張子の問題」参照）</p>
<hr />
</section>
</div>
<div id="calibre_link-98">
<section>
<h2 id="calibre_link-200"><b>1-1-2　HTMLの基本のルール</b></h2>
<p>　タグを使うときには以下のようなルールに従う必要があります。</p>
<p>
<br />
</p>
<p>●タグには開始タグと終了タグがあり、その中に中身を記述します。</p>
<section>
<p>開始タグ→　　<strong><b>＜タグ名＞</b></strong></p>
<p>終了タグ→　　<strong><b>＜/タグ名＞</b></strong></p>
</section>
<p>例）見出し</p>
<pre>
<code>&lt;h1&gt;今日の天気&lt;/h1&gt;</code>
</pre>
<p>
<br />
</p>
<p>●中身がない場合は以下のように記述します。「空要素」とも呼びます。</p>
<section>
<p>空要素→　　<strong><b>＜タグ名 /＞</b></strong></p>
</section>
<p>例）改行</p>
<pre>
<code>&lt;br /&gt;</code>
</pre>
<p>
<br />
</p>
<p>「タグ名」と半角スラッシュ「/」の間の半角スペースは入れても入れなくてもかまいません。</p>
<p>
<br />
</p>
<p>●付属情報は属性として記述します。属性は複数指定することもできます。</p>
<section>
<p>
<strong><b>＜タグ名 属性名1＝"属性値1" 属性名2＝"属性値2"＞</b></strong>
</p>
</section>
<p>例）幅100の大きさで、photo.jpgという画像を表示</p>
<pre>
<code>&lt;img width="100" src="photo.jpg" /&gt;</code>
</pre>
<p>
<br />
</p>
<p>●タグは別のタグを含むことができますが、その際は全体を含まなくてはなりません。</p>
<figure>
<img src="images/00163.jpeg" />
<figcaption>外側のタグは内側のタグ全体を含む</figcaption>
</figure>
<p>　たとえば、以下の例1では、内側のタグ&lt;b&gt;の全体が外側のタグ&lt;p&gt;に含まれているので問題ありませんが、例2ではそうなっていないので、不正なHTMLになっています。</p>
<p>例1）よい例</p>
<pre>
<code>&lt;p&gt;今日の天気は&lt;b&gt;快晴&lt;/b&gt;です&lt;/p&gt;</code>
</pre>
<p>例2）悪い例</p>
<pre>
<code>&lt;p&gt;今日の天気は&lt;b&gt;快晴&lt;/p&gt;です&lt;/b&gt;</code>
</pre>
<p>
<br />
</p>
<p>●一番外側は&lt;html&gt;タグ1つだけです。</p>
<p>
<br />
</p>
<p>　なお、&lt;html&gt;の上にある&lt;!DOCTYPE html&gt;は「このHTML文書はHTML5を意識して作られたものです」と宣言するためのものです。ブラウザーはこの情報を見て「この文書はHTML5を想定して作られたんだな」と認識することができます。この行はHTMLの先頭に記述されますが、画面を構成する要素ではありません。「おまじない」のようなものだと思っておいてください。</p>
<p>　以上、細かいことはいろいろありますが、主なルールはこれくらいです。HTMLが非常に学習しやすい言語ということがおわかりいただけたと思います。</p>
</section>
</div>
<div id="calibre_link-122">
<section>
<h2 id="calibre_link-201"><b>1-1-3　よく使われるタグ</b></h2>
<p>　HTML辞典などの書籍やタグを解説しているページを見ると実にたくさんの要素について説明がなされています。しかし、実際にはそれらを全部覚える必要はありません。代表的なタグをいくつか覚えれば十分です。ここでは、そのような代表的なタグをいくつかご紹介します。</p>
<table>
<caption>主なタグ</caption>
<tbody>
<tr>
  <th>タグ名</th>
  <th>用途</th>
</tr>
<tr>
  <td>h1</td>
  <td>見出し1（heading 1）</td>
</tr>
<tr>
  <td>h2</td>
  <td>見出し2（heading 2）</td>
</tr>
<tr>
  <td>h3</td>
  <td>見出し3（heading 3）</td>
</tr>
<tr>
  <td>p</td>
  <td>段落（paragraph）</td>
</tr>
<tr>
  <td>div</td>
  <td>グループ化</td>
</tr>
<tr>
  <td>span</td>
  <td>テキストの一部</td>
</tr>
<tr>
  <td>ul</td>
  <td>箇条書き（unordered list）</td>
</tr>
<tr>
  <td>ol</td>
  <td>番号付リスト（ordered list）</td>
</tr>
<tr>
  <td>li</td>
  <td>リストの項目（list item）</td>
</tr>
<tr>
  <td>img</td>
  <td>画像（image）</td>
</tr>
<tr>
  <td>br</td>
  <td>改行（break）</td>
</tr>
<tr>
  <td>button</td>
  <td>ボタン</td>
</tr>
<tr>
  <td>input</td>
  <td>インプット</td>
</tr>
<tr>
  <td>a</td>
  <td>文書間のリンクを記述（anchor）</td>
</tr>
<tr>
  <td>table</td>
  <td>テーブル</td>
</tr>
<tr>
  <td>tr</td>
  <td>テーブルの行</td>
</tr>
<tr>
  <td>td</td>
  <td>テーブルのセル</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　昔はいろいろなタグを駆使して、ページの見映えを競う傾向がありましたが、最近はスタイルを使って調整する方法が主流になってきました。</p>
<p>　タグの種類は使っているうちに自然に覚えるものなので、タグを暗記することに時間を割く必要はありません。例を見て、手を動かすのが一番です。</p>
<p>　以下は先の表の主なタグを使った例です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;title&gt;主な要素&lt;/title&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;h1&gt;タイトル&lt;/h1&gt;</code>
<code>        &lt;h2&gt;副題&lt;/h2&gt;</code>
<code></code>
<code>        &lt;p&gt;</code>
<code>            これはパラグラフです。文節を記述するためタグです。</code>
<code>            一部分だけをマーキングする場合は&lt;span&gt;スパン&lt;/span&gt;を使用します。</code>
<code>        &lt;/p&gt;</code>
<code></code>
<code>        &lt;h3&gt;番号付リストの例&lt;/h3&gt;</code>
<code>        &lt;ol&gt;</code>
<code>            &lt;li&gt;野菜を切る&lt;/li&gt;</code>
<code>            &lt;li&gt;材料を炒める&lt;/li&gt;</code>
<code>            &lt;li&gt;盛り付ける&lt;/li&gt;</code>
<code>        &lt;/ol&gt;</code>
<code></code>
<code>        &lt;h3&gt;箇条書きの例&lt;/h3&gt;</code>
<code>        &lt;ul&gt;</code>
<code>            &lt;li&gt;HTMLの基本&lt;/li&gt;</code>
<code>            &lt;li&gt;スタイルの基本&lt;/li&gt;</code>
<code>            &lt;li&gt;スクリプトの基本&lt;/li&gt;</code>
<code>        &lt;/ul&gt;</code>
<code></code>
<code>        &lt;button&gt;OKボタン&lt;/button&gt;</code>
<code>        &lt;button&gt;NGボタン&lt;/button&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　表示結果は以下のようになります。</p>
<figure>
<img src="images/00003.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>今日の予定、好きな食べ物、何でもかまいません。ここで説明されたタグを使って、自由にHTMLを書いて、その結果を見てみましょう。</p>
<hr />
<p>　プレーンテキストに比べると、箇条書きや見出しなど、文章の構造が見た目に反映されていますが、まだまだ無骨な感じがします。より見映えのするページにするためには、スタイルを活用する必要がありますが、スタイルに関しては次の章で詳しく説明します。</p>
<h3 id="calibre_link-202">■テーブル</h3>
<p>　table（テーブル全体）、tr（行）、td（マス）を組み合わせることでテーブル形式の構造を表現することができます。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;table border="1"&gt;</code>
<code>            &lt;tr&gt;</code>
<code>                &lt;td&gt;&lt;/td&gt;</code>
<code>                &lt;td&gt;月&lt;/td&gt;</code>
<code>                &lt;td&gt;火&lt;/td&gt;</code>
<code>                &lt;td&gt;水&lt;/td&gt;</code>
<code>                &lt;td&gt;木&lt;/td&gt;</code>
<code>                &lt;td&gt;金&lt;/td&gt;</code>
<code>            &lt;/tr&gt;</code>
<code>            &lt;tr&gt;</code>
<code>                &lt;td&gt;午前&lt;/td&gt;</code>
<code>                &lt;td&gt;理&lt;/td&gt;</code>
<code>                &lt;td&gt;国&lt;/td&gt;</code>
<code>                &lt;td&gt;算&lt;/td&gt;</code>
<code>                &lt;td&gt;英&lt;/td&gt;</code>
<code>                &lt;td&gt;社&lt;/td&gt;</code>
<code>            &lt;/tr&gt;</code>
<code>            &lt;tr&gt;</code>
<code>                &lt;td&gt;午後&lt;/td&gt;</code>
<code>                &lt;td&gt;英&lt;/td&gt;</code>
<code>                &lt;td&gt;国&lt;/td&gt;</code>
<code>                &lt;td&gt;理&lt;/td&gt;</code>
<code>                &lt;td&gt;算&lt;/td&gt;</code>
<code>                &lt;td&gt;社&lt;/td&gt;</code>
<code>            &lt;/tr&gt;</code>
<code>        &lt;/table&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00067.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　このHTML文書の構造を図で表すと以下のようになります。table要素の「border="1"」属性で枠線の太さを指定します。</p>
<figure>
<img src="images/00109.jpeg" />
<figcaption>前記リストのtable要素の構造</figcaption>
</figure>
<p>　なお、以前はレイアウト目的でtableが使用されることもありましたが、最近はCSSスタイルが普及してきたこともあり、以前ほどは使われなくなったように感じられます。</p>
<h3 id="calibre_link-203">■anchor要素</h3>
<p>　「文書間を簡単にリンクで結び付けることができる」という特徴があったからこそ、HTMLはここまで普及したと言えるでしょう。そのリンクはanchor要素で指定します。使い方は非常に簡単です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;a href="another.html"&gt;別のページ&lt;/a&gt;</code>
</pre>
<p>　遷移先のページをhrefの属性値として指定します。ブラウザー上には、要素のテキスト部分がリンクを示すアンダーラインと青の文字で表示されます。クリックするとそのページに遷移します。</p>
<figure>
<img src="images/00139.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　ほかのサーバーのページへリンクを張るのも簡単です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;a href="http://www.yahoo.co.jp"&gt;Yahooへ&lt;/a&gt;</code>
<code>&lt;a href="http://www.bing.com"&gt;Bingへ&lt;/a&gt;</code>
</pre>
<p>とURLを記述すると、そのURLへ遷移します。</p>
<figure>
<img src="images/00007.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　これで、自由にいろいろなサイトへのリンクを持ったページを作ることができるようになりました。</p>
</section>
</div>
<div id="calibre_link-73">
<section>
<hgroup>
<h1 id="calibre_link-140"><b>1-2　画像の表示</b></h1>
</hgroup>
</section>
</div>
<div id="calibre_link-16">
<section>
<h2 id="calibre_link-204"><b>1-2-1　画像のフォーマット</b></h2>
<p>　&lt;img&gt;要素では以下のように画像ファイルを指定すると、そこに画像が表示されます。</p>
<p>
<br />
</p>
<pre>
<code>&lt;img src="sample.jpg"/&gt;</code>
<code>&lt;img src="folder/sample.jpg"/&gt;</code>
</pre>
<p>　既存の画像ファイルを表示する場合はあまり問題になりませんが、自分で作った画像を保存する際には、フォーマットを選ぶ必要があります。フォーマットとは、画像データをファイルで保存する形式のことで、代表的なものにJPEG、PNG、BMPなどがあります。画像の内容に適したフォーマットを選べるようになるためには、これらのフォーマットの特徴を知っておくことが重要です。</p>
<table>
<caption>画像フォーマットの特徴</caption>
<tbody>
<tr>
  <td></td>
  <td>呼称</td>
  <td>用途</td>
  <td>圧縮</td>
  <td>アルゴリズム</td>
</tr>
<tr>
  <td>BMP</td>
  <td>ビットマップ、ビーエムピー</td>
  <td>アイコン</td>
  <td>なし</td>
  <td>各ピクセルのデータをそのまま保存</td>
</tr>
<tr>
  <td>PNG</td>
  <td>ピング、ピーエヌジー</td>
  <td>アイコン、模様</td>
  <td>可逆（元のデータに戻すことができる）</td>
  <td>ラインごとに情報を圧縮。たとえば「1100000000」のようなビット列は「11のあとに0が8回」と記録するとサイズが小さくなる</td>
</tr>
<tr>
  <td>JPG</td>
  <td>ジェーペグ</td>
  <td>写真</td>
  <td>不可逆（元のデータには戻せない）</td>
  <td>人間が気づかない程度に、情報を削除することでサイズを圧縮</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<hr />
<p>
<strong><b>【演習】</b></strong>mspaintを起動し、お手持ちの写真を開いて（ない場合はカメラアプリから撮影してみましょう！）、JPEG、PNG、BMPそれぞれの形式で保存します。デスクトップでJPEG、PNG、BMPのファイルサイズを比べてみましょう。また、写真の代わりに、単なる塗りつぶしの画像やアイコンなどでも同じ作業をやってみましょう。</p>
<hr />
</section>
</div>
<div id="calibre_link-39">
<section>
<hgroup>
<h1 id="calibre_link-141"><b>1-3　DOM（Document Object Model）</b></h1>
</hgroup>
<p>　ここまでHTMLの基本について説明してきました。しかし、動かないページはあまりおもしろくありません。HTMLに動きを与えるにはJavaScriptを使う必要があります。JavaScriptのプログラミングの詳細に関しては、別の章で詳しく説明しますが、ここでは、HTMLとJavaScriptの橋渡しとなるDOMについて説明します。DOMとはDocument Object Modelの略で、文書をオブジェクトとして扱うモデルという意味です。現時点ではチンプンカンプンだと思いますが、とりあえず、「JavaScriptからプログラムを使ってHTML文書をコントロールする方法」という程度の理解で、あまり気にせず読み進めてみてください。</p>
</section>
</div>
<div id="calibre_link-58">
<section>
<h2 id="calibre_link-205"><b>1-3-1　HTML文書の構造</b></h2>
<p>　DOMの詳細に入る前に、まずHTML文書の構造について説明しておきましょう。「1-1-2 HTMLの基本のルール」で、</p>
<ul>
<li>あるタグは別のタグに完全に含まれる</li>
<li>一番外側にはhtml要素がある</li>
</ul>
<p>という説明をしました。このことから、すべてのHTML文書は以下のように、html要素を頂点とする親子関係で表せることになります。</p>
<figure>
<img src="images/00166.jpeg" />
<figcaption>HTML文書はhtml要素を頂点とする親子関係</figcaption>
</figure>
<p>　下の矩形を上の矩形が含んでいることを表しています。たとえば、「要素2」は「要素a」と「要素b」を含んでいます。ここで、含む方を「親」、含まれる方を「子」と呼びます。</p>
<p>　このような親子関係は実際の世界でも普通に見ることができます。たとえば、パソコンとその構成部品も似たような図で表現することができます。</p>
<figure>
<img src="images/00084.jpeg" />
<figcaption>パソコンとその構成部品</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>このような構造で表されるものは、ほかにどのようなものがあるでしょうか？</p>
<hr />
<p>　では、「1-1-1 HTML文書の基本構成」で挙げたHTMLの例を見てみましょう。HTMLは以下のようになります。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;body&gt;</code>
<code>&lt;h1&gt;タイトル&lt;/h1&gt;</code>
<code>&lt;p&gt;これは&lt;b&gt;パラグラフ&lt;/b&gt;です&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00030.jpeg" />
<figcaption>前記HTMLの階層図</figcaption>
</figure>
<p>　htmlがbodyを含み、bodyはh1とpを含み、と読んでいきます。私たちは、このようなHTMLを入力していますが、JavaScriptからは、図のような形で文章が見えているのです。ここが大きなポイントです。では、実際にDOMを操作してみましょう。</p>
</section>
</div>
<div id="calibre_link-80">
<section>
<h2 id="calibre_link-206"><b>1-3-2　documentオブジェクト</b></h2>
<p>　HTML文書がブラウザーに読み込まれると、その文書のhtml要素がdocumentという変数に保持されます。これはどのブラウザーでも同じです。このdocumentを起点としてJavaScriptからHTMLの各要素にアクセスできるようになっています。</p>
<p>　これも実際に試してみるのが一番です、以下の文書を入力してブラウザーで表示してください。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;h1 id="title"&gt;HTMLの基礎&lt;/h1&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　どのブラウザーでも以下のように表示されるはずです。</p>
<figure>
<img src="images/00116.jpeg" />
<figcaption>ブラウザーの表示</figcaption>
</figure>
<h3 id="calibre_link-207">■Internet ExplorerでDOMを操作する</h3>
<p>　F12キーを押すと以下の画面（開発者ツール）が表示されます。この画面はInternet Explorer（以下IE）の中で何が起きているか詳しく調べることができるウィンドウです。</p>
<figure>
<img src="images/00040.jpeg" />
<figcaption>F12キーを押して開発者ツールを表示</figcaption>
</figure>
<p>　「スクリプト」タブを選び、その下のツールバーから「コンソール」を選びます。「コンソール」の下端にある入力領域「&gt;&gt;」に以下のように入力して、Enterキーを押下します。</p>
<p>
<br />
</p>
<pre>
<code>document.getElementById("title").textContent="hello"</code>
</pre>
<figure>
<img src="images/00061.jpeg" />
<figcaption>「スクリプト」タブ→「コンソール」下端に入力</figcaption>
</figure>
<p>　「ブロックされているコンテンツを許可(A)」と表示された場合はそのままクリックし、再度入力領域に同じ命令を入力してEnterキーを押してください。</p>
<figure>
<img src="images/00100.jpeg" />
<figcaption>「ブロックされているコンテンツを許可(A)」をクリック</figcaption>
</figure>
<p>　すると図のように&lt;h1&gt;要素の内容が置き換えられます。</p>
<figure>
<img src="images/00135.jpeg" />
<figcaption>操作結果</figcaption>
</figure>
<h3 id="calibre_link-208">■Google Chromeの場合</h3>
<p>　Google ChromeでもIEと同様の操作を行えます。HTML文書を表示して、メニューから「ツール」→「JavaScriptコンソール」を選びます。</p>
<figure>
<img src="images/00004.jpeg" />
<figcaption>HTML文書を表示</figcaption>
</figure>
<figure>
<img src="images/00066.jpeg" />
<figcaption>「ツール」→「JavaScriptコンソール」を選択</figcaption>
</figure>
<p>　ウィンドウ下部にコンソールが表示されるので、「&gt;」に続けて以下のように入力して、Enterキーを押下します。</p>
<p>
<br />
</p>
<pre>
<code>document.getElementById("title").textContent="hello"</code>
</pre>
<p>　下図のように、&lt;h1&gt;要素の内容が差し替えられました。</p>
<figure>
<img src="images/00078.jpeg" />
<figcaption>操作結果</figcaption>
</figure>
<h3 id="calibre_link-209">■DOMによるテキストの置き換え</h3>
<p>　IEやGoogle Chromeのコンソールで行った操作は、JavaScriptからDOMを操作していることにほかなりません。コンソールに入力した内容を詳しく見ていくことにしましょう。</p>
<p>
<br />
</p>
<pre>
<code>document.getElementById("title").textContent="hello"</code>
</pre>
<p>　前述したように、documentという変数には、現在の文書のhtml要素が格納されます。では、文中の要素にアクセスする場合にはどうすればよいでしょうか？</p>
<p>　じつは、このdocumentは単にhtml要素を格納しているだけではなく、いろいろな処理をお願いすることができます。このお願いのことを「メソッド」と呼びます。getElementByIdメソッドはその名前が意味する通り、idを使って要素を取得します。つまり、documentオブジェクトのgetElementByIdメソッドを使うと、idを使って文書中の特定の要素にアクセスできるのです。</p>
<figure>
<img src="images/00035.jpeg" />
<figcaption>getElementByIdメソッドの意味</figcaption>
</figure>
<p>　「どうしてdocumentのあとに「.」（ドット）が必要で、そのあとにgetElementByIdなのか？」など疑問に思われるかもしれませんが、今は特定のidを持つ要素を取得するおまじないだと思ってください。</p>
<p>　ここでは、「&lt;h1 id="title"&gt;」のようにid属性を設定していたので、「document.getElementById("title")」でh1要素が取得できます。</p>
<p>　そして取得したh1要素の内容を書き換える役目をしていたのが、後半の「textContent="hello"」の部分です。</p>
<p>
<br />
</p>
<pre>
<code>document.getElementById("title").textContent="hello"</code>
</pre>
<p>　h1要素のtextContentプロパティに値を代入すると、そのテキストを置き換えることができます。プロパティとは「所有物、資産、特徴、性質」といった意味です。世の中のあらゆるものはプロパティを持っています。みなさんの名前、身長、体重、視力、握力はみなさんのプロパティです。自動車の色、重量、ガソリン残量もプロパティです。このプロパティについてもJavaScriptの章で詳しく説明します。</p>
<p>　ともあれ、現時点では</p>
<ul>
<li>HTML文書にはたくさんの要素が含まれている</li>
<li>document.getElementById()で要素にアクセスできる</li>
<li>要素にはプロパティがあり、値を代入すると表示が更新される</li>
</ul>
<p>と覚えておいておけば十分です。</p>
</section>
</div>
<div id="calibre_link-103">
<section>
<hgroup>
<h1 id="calibre_link-142"><b>1-4　イベント</b></h1>
</hgroup>
<p>　DOMはHTML文書をJavaScriptの橋渡しをするものと説明しました。もう1つ、HTMLとJavaScriptを結び付けてくれるものがあります。それはイベントです。イベントとは「出来事、事件、事象、行事」というような意味ですが、ここでは「出来事、事象」といったニュアンスが近いでしょう。</p>
</section>
</div>
<div id="calibre_link-116">
<section>
<h2 id="calibre_link-210"><b>1-4-1　ブラウザーで発生する主なイベント</b></h2>
<p>　イベントはブラウザーで発生し、JavaScriptに伝えられます。JavaScriptでは、そのイベントを処理していきます。ブラウザーで発生する主なイベントには以下のようなものがあります。</p>
<ul>
<li>ページを読み込んだ</li>
<li>マウスが動いた</li>
<li>マウスがクリックされた</li>
<li>キーが押された</li>
<li>キーが離された</li>
<li>ボタンがクリックされた</li>
</ul>
<p>　このように、さまざまなイベントが用意されています。具体例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>function calc() {</code>
<code>    var w = document.getElementById("weight").value;</code>
<code>    var h = document.getElementById("height").value;</code>
<code>    var r = w / (h * h); // BMI指数＝体重(kg) ÷ (身長(m) Ｘ 身長(m))</code>
<code>    document.getElementById("result").textContent = "あなたのBMIは" + r + "です";</code>
<code>}</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;h1&gt;BMIの計算&lt;/h1&gt;</code>
<code>        体重(kg)：&lt;input id="weight" /&gt;&lt;br /&gt;</code>
<code>        身長(m) ：&lt;input id="height" /&gt;&lt;br /&gt;</code>
<code>        計算：&lt;button onclick="calc()"&gt;計算&lt;/button&gt;</code>
<code>        &lt;p id="result"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　実行すると以下のようになります。体重と身長を入力して計算ボタンを押すとBMIの値が表示されます（「ブロックされているコンテンツを許可(A)」と表示された場合はそのままクリックしてください）。</p>
<figure>
<img src="images/00152.jpeg" />
<figcaption>「体重」「身長」を入力して「計算」ボタンを押すとBMIの値が表示される</figcaption>
</figure>
<p>　JavaScriptでのプログラミングは発生したイベントを処理することと言っても過言ではありません。この例で何が起きているのか詳しく見てみましょう。</p>
</section>
</div>
<div id="calibre_link-17">
<section>
<h2 id="calibre_link-211"><b>1-4-2　イベントハンドラー</b></h2>
<p>　HTML中に</p>
<p>
<br />
</p>
<pre>
<code>&lt;button onclick="calc()"&gt;計算&lt;/button&gt;</code>
</pre>
<p>と書かれていますが、これがボタンの記述です。クリックされたときにonclick属性で指定された内容「"calc()"」が実行されます。このように、何かしらの事象（例：クリックされた）に応じて実行される関数を「イベントハンドラー」と呼びます。今回の場合は、calcがイベントハンドラーとなります。</p>
<p>　プログラムは&lt;script&gt;要素の中に記述します。一般的に&lt;script&gt;要素は&lt;head&gt;要素の中に配置します。今回は以下のように記述されています。</p>
<p>
<br />
</p>
<pre>
<code>function calc() {</code>
<code>    var w = document.getElementById("weight").value;</code>
<code>    var h = document.getElementById("height").value;</code>
<code>    var r = w / (h * h); // BMI指数＝体重(kg) ÷ (身長(m) Ｘ 身長(m))</code>
<code>    document.getElementById("result").textContent = "あなたのBMIは" + r + "です";</code>
<code>}</code>
</pre>
<p>　「function」は関数を意味するキーワードです。関数とは、ある一定の処理をまとめたものだと思ってください。</p>
<p>　「document.getElementById("weight").value」で「&lt;input id="weight" /&gt;」に入力した値を取得することができます。この場合は体重の値が変数wに格納されます。</p>
<p>　同様に、「document.getElementById("height").value」で身長を取得し、その内容が変数hに格納されます。「var r = w / (h * h)」でBMIを計算し、その値を変数rに格納しています。最後の行でその内容を表示しています。関数や変数、「*」などの演算子についてはJavaScriptの章で詳しく説明しますので、ここでは大まかな動作がわかれば十分です。</p>
<p>　このような処理でBMI値が計算され、ブラウザーに表示されているわけです。非常にシンプルな例ですが、これでも立派なHTMLコンテンツです。</p>
<p>
<br />
</p>
<p>　さて、ここまで、HTMLの書き方、画像フォーマット、DOM、イベントといろいろなことを説明してきました。これらは基礎となる事項なので、しっかりと理解する必要があります。頭で理解するのではなく、手を動かして体におぼえこませるようにしてください。</p>
</section>
</div>
<div id="calibre_link-12">
<section>
<hgroup>
<h1 id="calibre_link-143"><b>1-5　デバッグのコツ</b></h1>
</hgroup>
<p>　実際に入力したプログラムが一度で動くような幸運に恵まれる人はほとんどいません。何かしらの入力ミスをしてしまうものです。しかし、ミスしたことを残念に思う必要はまったくありません。ミスを修正する作業、すなわち、デバッグを通して多くのことを学べるからです。ここでは、ありがちなミスを見てみたいと思います。</p>
</section>
</div>
<div id="calibre_link-78">
<section>
<h2 id="calibre_link-212"><b>1-5-1　タイプミス</b></h2>
<p>　一番多いのがタイプミスです。JavaScriptでは大文字と小文字は別のものとして扱われることに注意してください。</p>
<figure>
<img src="images/00062.jpeg" />
<figcaption>タイプミスの例</figcaption>
</figure>
<p>　エラーが発生すると、ブラウザーは親切にもエラー箇所とエラー内容を表示してくれます。まずは、このエラーメッセージを読み、該当する箇所の前後を注意深く見直してください。</p>
<figure>
<img src="images/00160.jpeg" />
<figcaption>エラーメッセージ</figcaption>
</figure>
<p>　ただし、必ずしも示されている行に間違いがあるとは限りません。たとえば、次で説明する括弧の対応が取れていない場合などは、エラーメッセージにある行番号と、間違いのある箇所は別の場所になるので注意してください。</p>
</section>
</div>
<div id="calibre_link-32">
<section>
<h2 id="calibre_link-213"><b>1-5-2　関数の括弧の対応</b></h2>
<p>　括弧の対応が取れていないのもよくあるミスです。たとえば、以下のコードではinitとkeydownの2つの関数を定義しているように見えるかもしれませんが、実際にはそうではありません。</p>
<p>
<br />
</p>
<pre>
<code>function init() {</code>
<code>    var canvas = document.getElementById("canvas");</code>
<code>    var ctx = canvas.getContext("2d");</code>
<code></code>
<code>    document.getElementById("focus").onkeydown = keydown;</code>
<code>    var a = 0;</code>
<code>    for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>        a += i;</code>
<code>}</code>
<code></code>
<code>function keydown(e) {</code>
<code>    //...</code>
<code>}</code>
</pre>
<p>　どこに問題があるのでしょうか？よく見るとfor文の閉じ括弧がありません。このため、もともとは関数の終わりを意図した閉じ括弧がfor文の閉じ括弧としてみなされてしまいます。</p>
<p>　つまり、ブラウザーからはinit関数の中にkeydown関数が含まれているように見えているのです。</p>
<p>
<br />
</p>
<pre>
<code>function init() {</code>
<code>    var canvas = document.getElementById("canvas");</code>
<code>    var ctx = canvas.getContext("2d");</code>
<code></code>
<code>    document.getElementById("focus").onkeydown = keydown;</code>
<code>    var a = 0;</code>
<code>    for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>        a += i;</code>
<code>    }</code>
<code></code>
<code>    function keydown(e) {</code>
<code>      //...</code>
<code>    }</code>
</pre>
<p>　その結果、関数initはもちろん、keydownも正しく定義されなくなってしまいます。ですから</p>
<p>
<br />
</p>
<pre>
<code>&lt;body onload="init()"&gt;</code>
</pre>
<p>のように関数を実行したのに何も起きない、もしくは以下のようなエラーメッセージが表示される場合、おそらくは括弧の対応が間違っている可能性が高いと考えられます。</p>
<figure>
<img src="images/00094.jpeg" />
<figcaption>このようなエラーメッセージは括弧の対応が間違っている可能性が高い</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-76">
<section>
<h2 id="calibre_link-214"><b>1-5-3　ビジーループ</b></h2>
<p>　実行してみるとブラウザーが固まってしまう、そんな現象に出くわすこともあるでしょう。ブラウザーは画面の描画処理、イベントの処理、コードの実行を順番に行います。JavaScriptのコードで非常に重い処理、もしくは永遠に終わらない処理を記述してしまうと、その処理が終わるまで再描画や各種操作が行われなくなってしまいます。</p>
<p>　多少極端な例ですが以下のようなコードがあったとします。</p>
<p>
<br />
</p>
<pre>
<code>function keydown(e) {</code>
<code>    while (flag) {</code>
<code>        //</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　flagがfalseであれば問題はありません。しかし、flagがtrueであり、while文の中からbreakが呼ばれなければ、この関数は永遠に実行を続けてしまいます。このような状態を「ビジーループ」と呼びます。</p>
<p>　こうなると、タスクマネージャーを使ってブラウザーを強制終了するしか方法はありません。</p>
<figure>
<img src="images/00099.jpeg" />
<figcaption>タスクマネージャー</figcaption>
</figure>
<p>　複雑な処理を記述していると、このような状況に陥ることが少なからずあります。そうなった場合は、プログラムを順番に実行し、どこでビジーループに突入しているか慎重に探してください。</p>
</section>
</div>
<div id="calibre_link-92">
<section>
<h2 id="calibre_link-215"><b>1-5-4　Visual StudioなどのIDEの環境</b></h2>
<p>　スペルミスや括弧の対応のずれなどはVisual Studioなどの開発環境を使用することで大幅に軽減することができます（「3-9 デバッグ」参照）。Visual Studioには「インテリセンス」という機能があり、メソッドやプロパティの選択候補を列挙してくれます。ここから選べばスペルミスの心配はありません。また、閉じ括弧を入力した時点で、関数を見やすい状態にフォーマットしてくれます。この機能を使えば括弧の対応がずれる可能性はかなり低くなります。</p>
<p>　慣れ親しんだテキストエディタの方が入力しやすいと思う人もいるかもしれませんが、ぜひ最新の開発環境を試してみてください。きっとその便利さの虜になることでしょう。</p>
</section>
</div>
<div id="calibre_link-111">
<section>
<h2 id="calibre_link-216"><b>1-5-5　拡張子の問題</b></h2>
<p>　「HTMLファイルを入力して、そのファイルを起動したのにブラウザーが立ち上がらない」そんな状況に陥る人もいるかもしれません。これは、ファイルの拡張子が正しく設定されていないことが原因かもしれません。</p>
<p>　Windowsでは、ファイルの種類を示す拡張子をファイル名の最後に付けています。</p>
<table>
<caption>主な拡張子</caption>
<tbody>
<tr>
  <th>拡張子</th>
  <th>説明</th>
</tr>
<tr>
  <td>.txt</td>
  <td>テキストファイル</td>
</tr>
<tr>
  <td>.doc、.docx</td>
  <td>Wordのファイル</td>
</tr>
<tr>
  <td>.jpg、.jpeg</td>
  <td>JPEG画像ファイル</td>
</tr>
<tr>
  <td>.htm、.html</td>
  <td>HTMLファイル</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　この拡張子とアプリケーションが関連付けられているので、txtファイルをダブルクリックするとテキストエディタが起動し、編集が可能となるのです。</p>
<p>　しかしながら、この拡張子は諸刃の剣で、簡単にアプリケーションを起動できる反面、拡張子を変更すると希望するアプリケーションが立ち上がらないという状況も引き起こしてしまいます。</p>
<p>　Windowsは広く普及したことで、PCに詳しい人だけでなく、普通の人たちも使用するようになりました。ファイル名を変えただけでアプリケーションが起動しなくなっては大変です。そこで、最近のWindowsではこの拡張子がデフォルトでは非表示となっています。</p>
<p>　たとえば、以下のようなファイルがあった（もしくはメモ帳などで作成した）とします。</p>
<figure>
<img src="images/00169.jpeg" />
<figcaption>一見拡張子は「.html」のように見える</figcaption>
</figure>
<p>　このファイルをダブルクリックしてもブラウザーは起動しません。テキストエディタが立ち上がります。よく見ると「種類」のところが「テキスト ドキュメント」となっていることがわかります。</p>
<p>　そこで「ファイル名拡張子」を表示するチェックボックスをオンにしてみましょう。画面は以下のようになります。</p>
<figure>
<img src="images/00033.jpeg" />
<figcaption>「ファイル名拡張子」をチェックして確認</figcaption>
</figure>
<p>　実際のファイル名が「test.html.txt」であったことがわかります。これが原因でブラウザーが起動しなかったのです。この画面からファイル名を「test.html」に修正し、ファイルをダブルクリックしてください。今度は正常にブラウザーが起動するはずです。</p>
</section>
</div>
<div id="calibre_link-121">
<div>
<h1 id="calibre_link-144"><b>第2章　CSS入門</b></h1>
<h2 id="calibre_link-217"><b>ページのデザインを設定するCSS</b></h2>
</div>
<section>
<p><b>　前章のHTMLは主に見出しや本文など、文書の構造を定義するものでした。CSSはこれらに文字の種類や色などの見映えを設定する仕様です。HTMLの各要素にCSSをどのように設定していくか、本章でしっかり学習しましょう。</b></p>
</section>
</div>
<div id="calibre_link-191">
<section>
<hgroup>
<h1 id="calibre_link-145"><b>2-1　Webページの見映えを設定する</b></h1>
</hgroup>
<p>　Webページには、単に文書の内容を表示するだけでなく、文字の書体やサイズ、文字や図形の色や配置など、閲覧者が読みやすいようにデザインする工夫も必要です。こうした見映えの設定は、昔はHTMLのタグを使って指定していました。たとえば、以下のような具合です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;body&gt;</code>
<code>        普通のテキスト</code>
<code>        &lt;center&gt;中央よせ&lt;/center&gt;</code>
<code>        &lt;font color="red"&gt;赤色のテキスト&lt;/font&gt;</code>
<code>        &lt;br /&gt;</code>
<code>        &lt;font size="6"&gt;大きいテキスト&lt;/font&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00070.jpeg" />
<figcaption>設定例</figcaption>
</figure>
<p>　このように、HTML中に見映えに関する指定を埋め込んでしまうと、その文書をいろいろな用途で使い回すときに不便です。これだけではピンとこないですよね。具体例を使って説明してみましょう。</p>
<p>　たとえば、パソコン用のページは大きな画面を想定して作成されます。レイアウトに凝って、そこにたくさんの情報を表示することができます。一方、スマートフォンを想定した画面は、デザインをシンプルに、文字も小さくする必要があります。そのため、見映えに関する指定をHTMLに埋め込んでしまうと、そのHTMLを使い回すことが難しくなってしまうのです。</p>
<figure>
<img src="images/00059.jpeg" />
<figcaption>HTMLに見映えを設定すると使い回すことが難しい</figcaption>
</figure>
<p>　このような場合、文章の構造（章、段落、見出しなど）と、見映え（色、文字の大きさ、フォントなど）を切り離すことができれば、見映えのみの修正で済むようになります。この見映えを指定するためのルールが「CSS」（Cascading Style Sheets）です。</p>
<figure>
<img src="images/00156.jpeg" />
<figcaption>文書の構造はHTML、見映えはCSSに分離</figcaption>
</figure>
<p>　このように文書の構造と見映えを切り離し、用途別のCSSを適用することで、いろいろなデバイスで最適な状態で表示できるようになります。つまり、HTML文書をほとんど修正しなくても、いろいろな用途に使えるようになるのです。</p>
<p>　それではCSSがどのようなものか、さっそく見ていくことにしましょう。</p>
</section>
</div>
<div id="calibre_link-56">
<section>
<h2 id="calibre_link-218"><b>2-1-1　「カスケード」とは</b></h2>
<p>　スタイルの具体例を見ていく前に、「カスケーディング」の意味を説明しておきます。カスケード(cascade)とは、滝が流れる、流れ落ちる、というようなイメージを表します。</p>
<p>　たとえば、下図のように、body要素に「color:blue」というスタイルを適用すると、その文書全体の文字が青色になります。</p>
<figure>
<img src="images/00085.jpeg" />
<figcaption>body要素にスタイルを設定すると文書全体に適用される</figcaption>
</figure>
<p>　その子要素の&lt;p&gt;に「font-style:italic」というスタイルを適用すると、その下にある文字がイタリック（斜体）になります。</p>
<figure>
<img src="images/00088.jpeg" />
<figcaption>子要素の&lt;p&gt;にスタイルを設定するとその下にある文字に適用される</figcaption>
</figure>
<p>　つまり、スタイルは、それを適用した要素だけに有効になるのではなく、その子要素全体に適用されるのです。これが、「カスケーディング」の本質です。「上で指定したスタイルが、その下に流れていく」、そんなイメージを持っていただくとよいでしょう。よって、文書全体の見た目を一括して指定し、必要なところだけ個別にスタイルを適用することが可能となります。</p>
<p>　ちなみに、上記のスタイルを適用した結果は、以下のようになります。図はモノクロなので確認できませんが、文書全体が青色に、段落の内容が斜体になっています。</p>
<figure>
<img src="images/00150.jpeg" />
<figcaption>設定例</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-34">
<section>
<hgroup>
<h1 id="calibre_link-146"><b>2-2　インラインスタイル</b></h1>
</hgroup>
<p>　それでは、このようなスタイルをどのように指定するのか、順番に見ていくことにしましょう。もっとも簡単なのは、その要素のstyle属性を使う方法です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;body&gt;</code>
<code>    &lt;p style="color:red;"&gt;赤色のテキスト&lt;/p&gt;</code>
<code>    &lt;p style="color:green; font-size:24px"&gt;緑色, 24px&lt;/p&gt;</code>
<code>    &lt;p&gt;テキストの一部にスタイルを適用する場合は、</code>
<code>        &lt;span style="font-style:italic"&gt;span要素&lt;/span&gt;を使います。</code>
<code>    &lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　表示は以下のようになります。</p>
<figure>
<img src="images/00079.jpeg" />
<figcaption>ブラウザでの表示</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>style属性を使って文書の見た目が変わることを確認してみましょう。後述の「2-7-2 主なスタイル」にスタイル特性の例が書かれているので参考にしてください。</p>
<hr />
<p>　ただ、このような指定方法は、見映えを文書中に埋め込んでいる点ではHTMLによる指定と変わらないので、あまりおすすめできません。そこで、次節では文書と見た目の分離を一段階進めてみましょう。</p>
</section>
</div>
<div id="calibre_link-10">
<section>
<hgroup>
<h1 id="calibre_link-147"><b>2-3　style要素内にCSSを記述する</b></h1>
</hgroup>
</section>
</div>
<div id="calibre_link-67">
<section>
<h2 id="calibre_link-219"><b>2-3-1　基本的な書式</b></h2>
<p>　まずは具体例を示しましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;style&gt;</code>
<code>        h1 {</code>
<code>            font-style: italic;</code>
<code>        }</code>
<code>        p {</code>
<code>            color: white;</code>
<code>            background-color: blue;</code>
<code>        }</code>
<code>    &lt;/style&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>    &lt;h1&gt;１章：HTML&lt;/h1&gt;</code>
<code>    &lt;p&gt;テキストの例&lt;/p&gt;</code>
<code></code>
<code>    &lt;h1&gt;２章：CSS&lt;/h1&gt;</code>
<code>    &lt;p&gt;テキストの例&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00012.jpeg" />
<figcaption>ブラウザでの表示</figcaption>
</figure>
<p>　この方法ではstyle要素の中に、見た目に関するルールを記述していきます。書き方は以下の通りです。</p>
<section>
<p>
<strong><b>セレクタ ｛</b></strong>
</p>
<p>
<strong><b>　　プロパティ名：値；</b></strong>
</p>
<p>
<strong><b>｝</b></strong>
</p>
</section>
<p>　「セレクタ」とは「どの要素にスタイルを適用するか」を記述するルールです。h1やpのようにタグ名を書いた場合、そのタグにスタイルが適用されます。実際に適用するプロパティとその値は「プロパティ名:値;」のように記述します。プロパティ名と値の間は「：」（コロン）で区切ります。</p>
<p>　複数のプロパティを適用したい場合は、</p>
<section>
<p>
<strong><b>セレクタ ｛</b></strong>
</p>
<p>
<strong><b>　　プロパティ名1：値1；</b></strong>
</p>
<p>
<strong><b>　　プロパティ名2：値2；</b></strong>
</p>
<p>
<strong><b>｝</b></strong>
</p>
</section>
<p>のように、値のうしろに「;」（セミコロン）を書いて区切ります。</p>
<p>　こうすると、style要素の中を修正するだけで、文書全体の見た目を一括して更新できるようになります。たとえば、タグのテキストの色を白から黄色に変えたいと思った場合には「color: white;」を「color: yellow;」に書き換えるだけで済むのです。</p>
</section>
</div>
<div id="calibre_link-19">
<section>
<h2 id="calibre_link-220"><b>2-3-2　主なセレクタ</b></h2>
<p>　先ほどの例ではタグ名をセレクタとして使いました。しかし、実際に文書を作成してみると、もっといろいろと柔軟な設定をしたくなるはずです。じつはセレクタにはさまざまなルールが指定できます。ここでは代表的な使い方をご紹介します。</p>
<h3 id="calibre_link-221">■全称セレクタ「*」</h3>
<p>　文書中のすべての要素に適用する場合に使用します。</p>
<p>
<br />
</p>
<pre>
<code>* {</code>
<code>    font-size: 12px;</code>
<code>}</code>
</pre>
<h3 id="calibre_link-222">■タイプセレクタ 「要素名」</h3>
<p>　同じ種類のタグにスタイルを適用する場合に使用します。</p>
<p>
<br />
</p>
<pre>
<code>h1 {</code>
<code>    font-style: italic;</code>
<code>}</code>
</pre>
<h3 id="calibre_link-223">■IDセレクタ「#id」</h3>
<p>　文書中の特定の要素にのみスタイルを適用する場合に使用します。すべての要素はid属性を指定することができます。id属性の値は文書中で一意（ほかに同じ値を持つ要素があってはならない）でなくてはならないことに注意してください。</p>
<p>
<br />
</p>
<pre>
<code>#score {</code>
<code>    color: yellow;</code>
<code>}</code>
<code>...</code>
<code>&lt;p&gt;スコア：&lt;span id="score"&gt;50&lt;/span&gt;点&lt;/p&gt;</code>
</pre>
<p>　この例では、「50」のみが黄色となります。</p>
<h3 id="calibre_link-224">■クラスセレクタ「.クラス名」</h3>
<p>　文書中のいくつかの要素にスタイルを適用したい場合に使用します。class属性はHTMLの任意の要素に指定することができ、それらに対して一括してスタイルを適用することができます。id属性と異なり、class属性は同じ値を重複して指定してもかまいません。たとえば、以下の例では、最初と3番目のh1要素のみ青色で表示されます。</p>
<p>
<br />
</p>
<pre>
<code>.bluetitle {</code>
<code>    color: blue;</code>
<code>}</code>
<code>&lt;h1 class="bluetitle"&gt;HTMLの基礎&lt;/h1&gt;</code>
<code>&lt;h1&gt;CSSの基礎&lt;/h1&gt;</code>
<code>&lt;h1 class="bluetitle"&gt;JavaScriptの基礎&lt;/h1&gt;</code>
</pre>
<p>　これらのセレクタをいろいろと使ってみた例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;style&gt;</code>
<code>* {    /* 文書全体のフォントサイズを12pxにする */</code>
<code>    font-size: 12px;</code>
<code>}</code>
<code>h1 {    /* h1要素のフォントサイズを22pxにする */</code>
<code>    font-size: 22px;</code>
<code>}</code>
<code>#comment {    /* IDがcommentの要素を緑色にする */</code>
<code>    color: green;</code>
<code>}</code>
<code>.even {    /* class="even"というクラス属性が指定されている要素を紫にする */</code>
<code>    color: purple;</code>
<code>}</code>
<code>.odd {    /* class="odd"というクラス属性が指定されている要素を赤にする */</code>
<code>    color: red;</code>
<code>}</code>
<code>    &lt;/style&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>    &lt;h1&gt;１章：HTML&lt;/h1&gt;</code>
<code></code>
<code>    &lt;p id="comment"&gt;</code>
<code>        HTMLはタグを使って文書を構成します。</code>
<code>    &lt;/p&gt;</code>
<code></code>
<code>    &lt;ul&gt;</code>
<code>        &lt;li class="even"&gt;見出し&lt;/li&gt;</code>
<code>        &lt;li class="odd"&gt;パラグラフ&lt;/li&gt;</code>
<code>        &lt;li class="even"&gt;箇条書き&lt;/li&gt;</code>
<code>        &lt;li class="odd"&gt;表&lt;/li&gt;</code>
<code>    &lt;/ul&gt;</code>
<code>    &lt;p&gt;見た目はスタイルを使って指定します&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00048.jpeg" />
<figcaption>ブラウザで表示</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>style要素を使ってスタイルを指定してみましょう。タイプセレクタ、IDセレクタ、クラスセレクタを使って、その効果を実感してください。文書の内容は何でもかまいませんが、好きな食べ物、科目など箇条書きできる内容や表を使うとセレクタを適用しやすいかもしれません。</p>
<hr />
</section>
</div>
<div id="calibre_link-97">
<section>
<hgroup>
<h1 id="calibre_link-148"><b>2-4　link要素でCSSファイルを参照する</b></h1>
</hgroup>
<p>　style要素のセレクタという仕組みを使うことで、要素に適用されるスタイルをまとめて修正できるようになりました。しかし、まだHTML文書の中に見た目に関する指定が含まれています。そこで、もう一段分離を進めてみましょう。</p>
<p>　link要素を使うと、別のファイルのスタイルを参照することができます。先ほどの例でstyle要素の部分を別のファイル（「LinkElement.css」としました）に保存し、その内容をlink要素から参照した例を以下に示します。href属性で参照先のファイルを指定します。</p>
<p>LinkElement.html</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;link rel="stylesheet" href="LinkElement.css" /&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>    &lt;h1&gt;１章：HTML&lt;/h1&gt;</code>
<code></code>
<code>    &lt;p id="comment"&gt;</code>
<code>        HTMLはタグを使って文書を構成します。</code>
<code>    &lt;/p&gt;</code>
<code></code>
<code>    &lt;ul&gt;</code>
<code>        &lt;li class="even"&gt;見出し&lt;/li&gt;</code>
<code>        &lt;li class="odd"&gt;パラグラフ&lt;/li&gt;</code>
<code>        &lt;li class="even"&gt;箇条書き&lt;/li&gt;</code>
<code>        &lt;li class="odd"&gt;表&lt;/li&gt;</code>
<code>    &lt;/ul&gt;</code>
<code>    &lt;p&gt;見た目はスタイルを使って指定します&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>LinkElement.css</p>
<pre>
<code>* {</code>
<code>    font-size: 12px;</code>
<code>}</code>
<code>h1 {</code>
<code>    font-size: 22px;</code>
<code>}</code>
<code>#comment {</code>
<code>    color: green;</code>
<code>}</code>
<code>.even {</code>
<code>    color: purple;</code>
<code>}</code>
<code>.odd {</code>
<code>    color: red;</code>
<code>}</code>
</pre>
<p>　これで、ようやく文書とスタイルが完全に分離されました。実際に文書を記述していく際には、このようにCSSファイルとHTMLファイルを分離し、それらをlink要素で関連付ける習慣をつけておくとよいでしょう。</p>
</section>
</div>
<div id="calibre_link-123">
<section>
<hgroup>
<h1 id="calibre_link-149"><b>2-5　ページのレイアウト</b></h1>
</hgroup>
<p>　理想的には、文書とスタイルが完全に分離され、その見た目であるレイアウトはすべてCSSで記述できるのが望ましいでしょう。しかし、実際にはレイアウトはCSSだけでなく要素との共同作業として行われます。ここでは、レイアウトがどのように行われるか、その大まかな仕組みについて説明しましょう。</p>
</section>
</div>
<div id="calibre_link-0">
<section>
<h2 id="calibre_link-225"><b>2-5-1　ブロックレベル要素とインライン要素</b></h2>
<p>　HTMLでは要素を使って文書の構造を記述していきますが、その要素はインライン要素とブロックレベル要素とに分類されます。</p>
<h3 id="calibre_link-226">■インライン要素 &lt;a&gt;、&lt;span&gt;、&lt;button&gt;、&lt;input&gt;、&lt;img&gt;など</h3>
<p>　インライン要素は横方向に配置されていきます。親要素の幅（もしくはページ幅）に到達すると改行され、また行の先頭から追加されていきます。</p>
<figure>
<img src="images/00026.jpeg" />
<figcaption>インライン要素の配置</figcaption>
</figure>
<h3 id="calibre_link-227">■ブロックレベル要素 &lt;h1&gt;、&lt;h2&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;li&gt;など</h3>
<p>　矩形としての領域を確保し、縦方向に追加されていきます。</p>
<figure>
<img src="images/00124.jpeg" />
<figcaption>ブロックレベル要素の配置</figcaption>
</figure>
<p>　ページをレイアウトするときは、まずブロックレベル要素を使って大まかなレイアウトを整え、その中にインライン要素を流し込んでいきます。</p>
<figure>
<img src="images/00050.jpeg" />
<figcaption>ページレイアウト例</figcaption>
</figure>
<p>　ページを作成してみると「スタイルを指定しているのに、思ったような場所やサイズに配置されない」という状況に何度も遭遇することになるでしょう。その多くはインライン要素とブロックレベル要素を混同していることが原因です。</p>
<p>　たとえば、span要素に高さや幅を指定しても有効になりません。これは、インライン要素に高さを指定しても無視されるためです。一方、p要素に高さを指定するとその指定は有効になります。これはp要素がブロックレベル要素だからです。次に例を示しましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;body&gt;</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>The quick brown fox &lt;span style="background-color:yellow;height:100px;"&gt;jumps&lt;/span&gt; over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00147.jpeg" />
<figcaption>span要素に背景色と高さを指定した例</figcaption>
</figure>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;body&gt;</code>
<code>The quick brown fox jumps over the lazy dog</code>
<code>The quick brown fox &lt;p style="background-color:yellow;height:100px;"&gt;jumps&lt;/p&gt; over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00076.jpeg" />
<figcaption>p要素に背景色と高さを指定した例</figcaption>
</figure>
<p>　どの要素がブロックレベルで、どの要素がインラインかすべて覚えるのは大変です。そこで、大きさと場所を指定する必要がある場合は</p>
<ul>
<li>p要素＝子要素として主にテキストを含む場合</li>
<li>div要素＝子要素としていろいろな要素を含む場合</li>
</ul>
<p>という2つの要素を使えばよいと覚えておけばよいでしょう。</p>
</section>
</div>
<div id="calibre_link-186">
<section>
<h2 id="calibre_link-228"><b>2-5-2　ボックスモデル</b></h2>
<p>　HTMLでのレイアウトの基本は「ボックス」という矩形です。文書内のすべての要素はボックスと呼ばれる矩形を形成します。このボックスモデルでのスタイルを指定できるのは基本的にブロックレベル要素のみです。</p>
<p>　ボックスモデルには、margin（マージン）、border（枠線）、padding（余白）、height（縦サイズ）、width（横サイズ）といろいろなスタイルを指定できます。</p>
<figure>
<img src="images/00001.jpeg" />
<figcaption>ボックスモデルのスタイル</figcaption>
</figure>
<p>　マージンはほかの要素との距離を調整するものなので、背景色は透明となります。margin、border、paddingは上下左右別々の値を指定することも可能です。</p>
<table>
<caption>paddingの設定例</caption>
<tbody>
<tr>
  <th>スタイル例</th>
  <th>説明</th>
</tr>
<tr>
  <td>padding:10px;</td>
  <td>上下左右のパディングを一括指定</td>
</tr>
<tr>
  <td>padding:10px 20px 30px 40px;</td>
  <td>上、右、下、左のパディングを個別に指定</td>
</tr>
<tr>
  <td>padding-top: 10px;</td>
  <td>上のパディングを指定</td>
</tr>
<tr>
  <td>padding-bottom: 30px;</td>
  <td>下のパディングを指定</td>
</tr>
<tr>
  <td>padding-left: 40px;</td>
  <td>左のパディングを指定</td>
</tr>
<tr>
  <td>padding-right: 20px;</td>
  <td>右のパディングを指定</td>
</tr>
</tbody>
</table>
<table>
<caption>marginの設定例</caption>
<tbody>
<tr>
  <th>スタイル例</th>
  <th>説明</th>
</tr>
<tr>
  <td>margin:10px;</td>
  <td>上下左右のマージンを一括指定</td>
</tr>
<tr>
  <td>margin:10px 20px 30px 40px;</td>
  <td>上、右、下、左のマージンを個別に指定</td>
</tr>
<tr>
  <td>margin-top: 10px;</td>
  <td>上のマージンを指定</td>
</tr>
<tr>
  <td>margin-bottom: 30px;</td>
  <td>下のマージンを指定</td>
</tr>
<tr>
  <td>margin-left: 40px;</td>
  <td>左のマージンを指定</td>
</tr>
<tr>
  <td>margin-right: 20px;</td>
  <td>右のマージンを指定</td>
</tr>
</tbody>
</table>
<table>
<caption>borderの設定例</caption>
<tbody>
<tr>
  <th>スタイル例</th>
  <th>説明</th>
</tr>
<tr>
  <td>border-width: 2px;</td>
  <td>ボーダー幅</td>
</tr>
<tr>
  <td>border-style: solid;</td>
  <td>ボーダースタイル、solid, dotted, dashedなど</td>
</tr>
<tr>
  <td>border-color: red;</td>
  <td>ボーダー色</td>
</tr>
<tr>
  <td>border: 2px solid blue;</td>
  <td>幅、スタイル、色をまとめて指定。border-top-style, border-left-color等の個別指定も可能</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　ボックスモデルを意識してスタイルを指定した例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;style&gt;</code>
<code>    p {</code>
<code>        width: 200px;</code>
<code>        height: 50px;</code>
<code>        margin: 50px;</code>
<code>        padding: 20px;</code>
<code>        background-color: lightgreen;</code>
<code>        overflow: hidden;</code>
<code>        border: 2px solid blue;</code>
<code>    }</code>
<code>&lt;/style&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>&lt;p&gt;</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>&lt;/p&gt;</code>
<code>The quick brown fox jumps over the lazy dog.</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00162.jpeg" />
<figcaption>ブラウザでの表示</figcaption>
</figure>
<p>　「overflow: hidden;」は、はみ出した領域を非表示にする指定です。</p>
</section>
</div>
<div id="calibre_link-90">
<section>
<h2 id="calibre_link-229"><b>2-5-3　ボックスの位置指定</b></h2>
<p>　ブロックレベル要素のtopとleftスタイルを使って、ボックスの位置を調整することも可能です。その際、topとleftは親要素からの距離で指定することに注意してください。</p>
<figure>
<img src="images/00042.jpeg" />
<figcaption>ボックスの位置指定</figcaption>
</figure>
<p>　ただし、topとleftを使用する際には、「position: absolute;」というスタイルを指定する必要があることに注意してください。実際の例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;style&gt;</code>
<code>    div {</code>
<code>        position: absolute;    /* すべてのdivをtop/leftで絶対位置指定 */</code>
<code>    }</code>
<code>    #panel {    /* 質問用パネルの大きさと位置の指定 */</code>
<code>        left: 100px;</code>
<code>        top: 50px;</code>
<code>        width: 300px;</code>
<code>        height: 100px;</code>
<code>        background-color: lightgreen;</code>
<code>    }</code>
<code>    .button {    /* パネル上のボタンに共通なスタイル指定 */</code>
<code>        width: 50px;</code>
<code>        height: 25px;</code>
<code>        color: white;</code>
<code>        background-color: blue;</code>
<code>        border: 5px solid yellow;</code>
<code>        text-align: center;</code>
<code>        font-size: 24px;</code>
<code>    }</code>
<code>    .yes {    /* Yesボタン固有の指定 */</code>
<code>        top: 20px; left: 70px;</code>
<code>    }</code>
<code>    .no {    /* Noボタン固有の指定 */</code>
<code>        top: 20px; left: 200px;</code>
<code>    }</code>
<code>&lt;/style&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>&lt;div id="panel"&gt;</code>
<code>    &lt;div class="button yes"&gt;Yes&lt;/div&gt;</code>
<code>    &lt;div class="button no"&gt;No&lt;/div&gt;</code>
<code>&lt;/div&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00043.jpeg" />
<figcaption>ブラウザでの表示</figcaption>
</figure>
<p>　クラス属性の値は、「class="button yes"」のように空白で区切ることで複数の値を指定することができます。また、「text-align: center;」と指定すると文字が中央寄せで配置されます。</p>
<p>　このように、「position:absolute;」を指定すると、top、left、width、heightを使って好きなところに好きな大きさのブロックレベル要素を配置することができるようになります。</p>
<p>　ちなみに、テレビのリモコンのdボタンを押下して表示されるデータ放送はすべてこの手法でレイアウトされています。</p>
<p>　このように「position: absolute;」は便利な手法ですが、ディスプレイのサイズは人によって異なるため、あるディスプレイでは適当な大きさで表示されていても、ほかのディスプレイでは大きすぎたり小さすぎたりしてしまうことがあるので「position: absolute;」に過度に依存するのは好ましくありません。なお、CSS3ではGridレイアウト、Flexboxレイアウト、マルチカラムレイアウトなど、画面のサイズの変更に柔軟に対応できるスタイルが追加されています。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>「position:absolute;」とボックスモデルを活用し、以下のような絵をHTMLとCSSだけで描いてください。</p>
<figure>
<img src="images/00151.jpeg" />
<figcaption>HTMLとCSSでこの絵を描く</figcaption>
</figure>
<p>以下はソースコードの例です。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;style&gt;</code>
<code>    * {</code>
<code>        position:absolute;</code>
<code>    }</code>
<code>    #face {</code>
<code>        width:200px;</code>
<code>        height:200px;</code>
<code>        background-color:#fce2c4;</code>
<code>    }</code>
<code>    .eye {</code>
<code>        top:50px;</code>
<code>        width:20px;</code>
<code>        height:30px;</code>
<code>        background-color:black;</code>
<code>    }</code>
<code>    .cheek {</code>
<code>        top:100px;</code>
<code>        width:40px;</code>
<code>        height:40px;</code>
<code>        background-color:red;</code>
<code>    }</code>
<code>    .nose {</code>
<code>        top:90px;</code>
<code>        width:60px;</code>
<code>        height:60px;</code>
<code>        background-color:yellow;</code>
<code>    }</code>
<code>&lt;/style&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body&gt;</code>
<code>&lt;div id="face"&gt;</code>
<code>    &lt;div class="eye" style="left:50px;"&gt;&lt;/div&gt;</code>
<code>    &lt;div class="eye" style="left:130px;"&gt;&lt;/div&gt;</code>
<code>    &lt;div class="cheek" style="left:30px;"&gt;&lt;/div&gt;</code>
<code>    &lt;div class="cheek" style="left:130px;"&gt;&lt;/div&gt;</code>
<code>    &lt;div class="nose" style="left:70px;"&gt;&lt;/div&gt;</code>
<code>&lt;/div&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>
<strong><b>ちなみに、div要素に「border-radius:」を指定すると、矩形の角を丸めることが可能です。</b></strong>
</p>
<figure>
<img src="images/00119.jpeg" />
<figcaption>border-radius:で角を丸める</figcaption>
</figure>
<p>　いろいろな実装方法がありますが、「&lt;div id="face"&gt;」の中にすべて別の部品が含まれていることに注目してください。じつは、以下のように記述しても結果は同じになります。</p>
<p>
<br />
</p>
<pre>
<code>&lt;div id="face"&gt;&lt;/div&gt;</code>
<code>&lt;div class="eye" style="left:50px;"&gt;&lt;/div&gt;</code>
<code>&lt;div class="eye" style="left:130px;"&gt;&lt;/div&gt;</code>
<code>&lt;div class="cheek" style="left:30px;"&gt;&lt;/div&gt;</code>
<code>&lt;div class="cheek" style="left:130px;"&gt;&lt;/div&gt;</code>
<code>&lt;div class="nose" style="left:70px;"&gt;&lt;/div&gt;</code>
</pre>
<p>　しかし、「id="face"」の場所を移動させたときに、その違いが明らかになります。前者で「&lt;div id="face"&gt;」に「left:100px;」を指定すると、絵全体が右に移動します。しかし、後者に同じ指定をすると、以下のようになってしまいます。</p>
<figure>
<img src="images/00155.jpeg" />
<figcaption>顔のパーツだけずれる</figcaption>
</figure>
<p>　topやleftといったスタイルが親要素からの差分であることがよくわかると思います。</p>
<hr />
</section>
</div>
<div id="calibre_link-62">
<section>
<hgroup>
<h1 id="calibre_link-150"><b>2-6　色や長さの指定</b></h1>
</hgroup>
<p>　これまで、ボックスレベル要素の位置やサイズは「100px」のようにピクセル単位の値で指定してきました。スタイルを指定するときは、このほかにもさまざまな単位が利用できます。</p>
</section>
</div>
<div id="calibre_link-129">
<section>
<h2 id="calibre_link-230"><b>2-6-1　長さの指定</b></h2>
<p>　以下に使用できる単位をまとめます。</p>
<table>
<caption>長さの単位</caption>
<tbody>
<tr>
  <th>単位</th>
  <th>説明</th>
</tr>
<tr>
  <td>px</td>
  <td>ピクセル。画面を構成する点1つ分</td>
</tr>
<tr>
  <td>pt</td>
  <td>ポイント。1pt＝1/72インチ</td>
</tr>
<tr>
  <td>cm</td>
  <td>センチメートル</td>
</tr>
<tr>
  <td>vw</td>
  <td>ビューポートの幅。画面全体の幅を100とした値</td>
</tr>
<tr>
  <td>vh</td>
  <td>ビューポートの高さ。画面全体の高さを100とした値</td>
</tr>
<tr>
  <td>em</td>
  <td>「m」のサイズ。フォントの「m」の大きさの何倍かで指定</td>
</tr>
<tr>
  <td>%</td>
  <td>パーセント。親要素のサイズの何パーセント分かで指定</td>
</tr>
</tbody>
</table>
</section>
</div>
<div id="calibre_link-109">
<section>
<h2 id="calibre_link-231"><b>2-6-2　色の指定</b></h2>
<p>　これまでの例では、white、lightgreen、yellowといった名前で色を指定してきました。名前での色指定は便利な方法ですが、名前が思い浮かばなかったり、微妙なニュアンスを表現できなかったりといった問題があります。</p>
<p>　「光の三原色」は、赤（Red）、緑（Green）、青（Blue）の3つの光を組み合わせていろいろな色を表現する手法ですが、この手法は直感的にもわかりやすいのでコンピュータの世界でも広く使用されています。スタイルでも、3つの原色を使って色を指定することが可能です。赤、緑、青のそれぞれの色を0～255までの16進数で指定し、「＃RRGGBB」という文字列にします。文字は大文字でも小文字でもかまいません。</p>
<h3 id="calibre_link-232">■16進数について</h3>
<p>　10進数では0～9までの文字を使って数値を表現しますが、16進数では0～Fまでの文字を使用します。10進数と16進数の対応表を以下に示します。</p>
<figure>
<img src="images/00020.jpeg" />
<figcaption>10進数と16進数の対応</figcaption>
</figure>
<p>　10進数では、8、9、10、11...と数値が増えていきますが、16進数では8、9、A、B...と数値が増えていきます。16進数では、Fが一番大きな文字なので、そこから1つ増えると10となります。</p>
<p>　10進数の165から16進数のA5への変換は以下のように、16で割った商と余りから簡単に求めることができます。コンピュータの世界では16進は非常に多用されるので、慣れていない方はこれを機に16進数に親しむようにしてください。</p>
<figure>
<img src="images/00097.jpeg" />
<figcaption>10進数から16進数への変換</figcaption>
</figure>
<p>　以下に＃RRGGBBで色を指定した例を示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;body style="background-color: #00ff33"&gt;</code>
<code>&lt;p style="color:#ff0000"&gt;赤&lt;/p&gt;</code>
<code>&lt;p style="color:#ffffff"&gt;白&lt;/p&gt;</code>
<code>&lt;p style="color:#0000ff"&gt;青&lt;/p&gt;</code>
<code>&lt;p style="color:#ffff00"&gt;黄&lt;/p&gt;</code>
<code>&lt;p style="color:#ff00ff"&gt;紫&lt;/p&gt;</code>
<code>&lt;/body&gt;</code>
</pre>
<figure>
<img src="images/00018.jpeg" />
<figcaption>ブラウザでの表示</figcaption>
</figure>
<p>　なお、Microsoft Visual Studioでは、色を指定する際に、「#」と入力すると、以下のような色選択ダイアログを表示することができます。</p>
<figure>
<img src="images/00158.jpeg" />
<figcaption>Microsoft Visual Studioの色選択ダイアログ</figcaption>
</figure>
<ol>
<li value="1">
<a href="http://www.microsoft.com/ja-jp/dev/">http://www.microsoft.com/ja-jp/dev/</a>
</li>
</ol>
<p>　ちなみに、Paint.NETというアプリでは、以下のようなダイアログで色の指定を行います。Paint.NETはフリーのグラフィックソフトで以下のURLから入手することが可能です。</p>
<ol>
<li value="1">
<a href="http://www.getpaint.net/">http://www.getpaint.net/</a>
</li>
</ol>
<figure>
<img src="images/00044.jpeg" />
<figcaption>Paint.NETの色選択ダイアログ</figcaption>
</figure>
<p>　R、G、Bのスライダーを動かすことで色を調整できます。そのときの16進数の値は「Hex」というフィールドに表示されます。</p>
</section>
</div>
<div id="calibre_link-118">
<section>
<hgroup>
<h1 id="calibre_link-151"><b>2-7　主なスタイル</b></h1>
</hgroup>
<p>　スタイルにはさまざまなものが定義されており、すべてを紹介するとそれだけで本1冊になってしまう位の量があります。すべてのスタイルを覚えるのはとても大変ですし、そこに多大な労力を費やすのは、あまり効率的ではありません。</p>
</section>
</div>
<div id="calibre_link-41">
<section>
<h2 id="calibre_link-233"><b>2-7-1　Microsoft Visual Studioの活用</b></h2>
<p>　前節の最後で少し紹介したMicrosoft Visual Studioは、スタイルの種類を列挙してくれるだけでなく、取りうる値も選択肢として表示してくれます。さらに、そのスタイルの説明まで簡単なコメントとして表示されるという徹底ぶりです。</p>
<ol>
<li value="1">
<a href="http://www.microsoft.com/ja-jp/dev/">http://www.microsoft.com/ja-jp/dev/</a>
</li>
</ol>
<p>　以下は、style要素の中で「ba」と入力したときの状態です。スタイルの一覧が選択肢として表示されています。しかも、「ba」から始まるスタイルが自動で選択されます。項目を選ぶだけなので非常に簡単です。</p>
<figure>
<img src="images/00037.jpeg" />
<figcaption>Visual Studioではスタイルが選択肢として表示される</figcaption>
</figure>
<p>　さらに、そのスタイルを選択すると、今度は値を選ぶための選択肢が表示されます。コメントで具体例も表示されているので非常に直観的です。</p>
<figure>
<img src="images/00069.jpeg" />
<figcaption>Visual Studioではスタイルを選択すると値の一覧が表示される</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-110">
<section>
<h2 id="calibre_link-234"><b>2-7-2　主なスタイル</b></h2>
<p>　このようにVisual Studioを使えばスタイルの名称や機能を覚えていなくても簡単に設定できます。とはいえ、主要なスタイルは覚えておくと作業がはかどることも確かです。以下、よく使うと思われるスタイルの例を列挙しておきます。スタイルの完全なリストは書籍やWebページを参照してください。</p>
<table>
<caption>色のスタイル</caption>
<tbody>
<tr>
  <th>スタイル</th>
  <th>説明</th>
</tr>
<tr>
  <td>color: green;</td>
  <td>文字色を緑にする</td>
</tr>
<tr>
  <td>color: #00ff33</td>
  <td>文字色を明るい緑にする</td>
</tr>
<tr>
  <td>background-color: #00ff33;</td>
  <td>背景色を明るい緑にする</td>
</tr>
<tr>
  <td>opacity: 0.6;</td>
  <td>半透明の度合いを0～1の範囲で指定</td>
</tr>
</tbody>
</table>
<table>
<caption>文字のスタイル</caption>
<tbody>
<tr>
  <th>スタイル</th>
  <th>説明</th>
</tr>
<tr>
  <td>font-size: 12px;</td>
  <td>文字のサイズを12px（ピクセル）にする</td>
</tr>
<tr>
  <td>font-size: 24pt;</td>
  <td>文字のサイズを24pt（ポイント：1/72インチ）にする</td>
</tr>
<tr>
  <td>font-size: larger;</td>
  <td>文字のサイズを大きめの文字（相対的に）にする</td>
</tr>
<tr>
  <td>font-family: Meiryo;</td>
  <td>フォントを「メイリオ」にする</td>
</tr>
<tr>
  <td>font-family: 'MS Gothic';</td>
  <td>フォントを「MSゴシック」にする</td>
</tr>
<tr>
  <td>font-style: italic;</td>
  <td>文字を斜体にする</td>
</tr>
<tr>
  <td>text-align: left;</td>
  <td>文字を左寄せにする</td>
</tr>
<tr>
  <td>text-align: center;</td>
  <td>文字を中央寄せにする</td>
</tr>
<tr>
  <td>text-align: right;</td>
  <td>文字を右寄せにする</td>
</tr>
<tr>
  <td>line-height: 20px;</td>
  <td>行間を20pxにする</td>
</tr>
<tr>
  <td>line-height: 2em;</td>
  <td>行間を2文字分にする</td>
</tr>
</tbody>
</table>
<table>
<caption>ボックスモデルのスタイル</caption>
<tbody>
<tr>
  <th>スタイル</th>
  <th>説明</th>
</tr>
<tr>
  <td>width: 200px;</td>
  <td>幅を200pxにする</td>
</tr>
<tr>
  <td>width: 50%;</td>
  <td>幅を親要素の半分にする</td>
</tr>
<tr>
  <td>width: 30vw;</td>
  <td>幅をウィンドウ幅の30％にする</td>
</tr>
<tr>
  <td>height: 50px;</td>
  <td>高さを50pxにする</td>
</tr>
<tr>
  <td>height: 10%;</td>
  <td>高さを親要素の10％にする</td>
</tr>
<tr>
  <td>height: 15vh;</td>
  <td>高さをウィンドウの高さの15％にする</td>
</tr>
<tr>
  <td>top: 20px;</td>
  <td>上端からの距離を20pxにする</td>
</tr>
<tr>
  <td>top: 20%;</td>
  <td>上端からの距離を親要素の高さの20％にする</td>
</tr>
<tr>
  <td>left: 20px;</td>
  <td>左端からの距離を20pxにする</td>
</tr>
<tr>
  <td>left: 20%;</td>
  <td>左端からの距離を親要素の幅の20％にする</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
</section>
</div>
<div id="calibre_link-47">
<div>
<h1 id="calibre_link-152"><b>第3章　JavaScript入門</b></h1>
<h2 id="calibre_link-235"><b>Webには欠かせないプログラミング言語JavaScript</b></h2>
</div>
<section>
<p><b>　プログラミング言語には、C、C++、Java、JavaScript、C#、Ruby、Perl、VB、COBOL、FORTRAN、BASIC、LISP、TCL...など多くの言語があります。各言語には得意なこと、不得意なことがあるので、状況に応じて使い分けられるのが理想です。とはいっても、一度にいろいろな言語を覚えるのも大変です。プログラミング言語は、その本質的なところでは多くの共通点があるものなので、まずはどれか1つの言語をしっかりとマスターしましょう。本書ではその中でも最近人気のJavaScriptを取り上げます。</b></p>
</section>
</div>
<div id="calibre_link-71">
<section>
<hgroup>
<h1 id="calibre_link-153"><b>3-1　プログラミング言語とは</b></h1>
</hgroup>
<p>　そもそもプログラミング言語とは何でしょうか？いろいろな定義があると思いますが、ここでは「コンピュータに命令するための言葉」と思ってください。英語を話せると多くの人とコミュニケーションできるようになります。同じように、プログラミング言語をマスターすると、コンピュータに命令できるようになるのです。</p>
<p>　たとえば、一般的なゲームの処理手順は以下のようになります。</p>
<ol>
<li value="1">(1) いろいろな用意（初期化）をする</li>
<li value="2">(2) 画面をクリアする</li>
<li value="3">(3) ユーザーからのキー入力をチェックする</li>
<li value="4">(4) キー入力があったらキャラクターを移動する</li>
<li value="5">(5) 敵のキャラクターを移動する</li>
<li value="6">(6) 衝突したかチェックする</li>
<li value="7">(7) 衝突していたらゲームオーバーで終了</li>
<li value="8">(8) 背景、キャラクター、敵などを画面に描画する</li>
<li value="9">(9) 手順（2）に戻る</li>
</ol>
<p>　上記の処理手順は日本語で書かれていますが、これをコンピュータにわかるように表現するのがプログラミング言語です。</p>
<p>　プログラミング言語を駆使すると非常に複雑なことができますが、その構成要素は非常にシンプルな命令です。主な処理命令は以下の通りです。</p>
<ul>
<li>代入：「変数」という箱に数値や文字を格納する</li>
<li>演算（計算）：四則演算（足し算、引き算、掛け算、割り算）を行う</li>
<li>比較：2つの値が同じかどうか、大小関係を比べる</li>
<li>条件分岐：比較した結果で処理の手順を変える</li>
<li>繰り返し：同じ処理を繰り返す</li>
</ul>
<p>　それでは、これらの基本的な命令をJavaScriptでどのように記述するか見ていくことにしましょう。</p>
</section>
</div>
<div id="calibre_link-94">
<section>
<hgroup>
<h1 id="calibre_link-154"><b>3-2　変数</b></h1>
</hgroup>
<p>　変数とは値を格納する入れものです。入れもの＝変数には名前を付けられますが、それを「変数名」と言います。</p>
<figure>
<img src="images/00114.jpeg" />
<figcaption>変数とは値を格納する入れもの</figcaption>
</figure>
<p>　プログラムではvarというキーワードのあとに変数名を書きます。複数の変数を指定する場合は、カンマで変数名を区切ります。これを「変数の宣言」と言います。</p>
<p>
<br />
</p>
<pre>
<code>var s;</code>
<code>var r, score, point;</code>
</pre>
<p>　変数を宣言するときには、「＝ 値」と書くことで、初期値（最初の値）を設定することができます。変数には、数値、文字などいろいろなものを格納することができます。</p>
<p>
<br />
</p>
<pre>
<code>var a = 3;</code>
<code>var b = 5;</code>
<code>var c = a + b;  // c = 8</code>
</pre>
<p>
<br />
</p>
<pre>
<code>var x = "hello";</code>
<code>var y = "world";</code>
<code>var z = x + y;  // z = "helloworld"</code>
</pre>
<p>　上記のように数値の場合は四則演算が可能です。文字列の場合、足し算をすると文字列が連結されます（「//」以降はコメントです。「3-3 コメント」参照）。</p>
<figure>
<img src="images/00095.jpeg" />
<figcaption>計算結果も変数に格納</figcaption>
</figure>
<p>　変数とは、方程式のxやyのようなものだと思うとわかりやすいかもしれません。あとで見直すときのことを考えて、変数名にはわかりやすい名前を付けるようにしてください。</p>
</section>
</div>
<div id="calibre_link-26">
<section>
<hgroup>
<h1 id="calibre_link-155"><b>3-3　コメント</b></h1>
</hgroup>
<p>　コメントは文字通り注釈という意味です。プログラムの実行には影響を与えません。ほかの人への説明だったり、自分が忘れないためのメモ書きだったり、いろいろな用途に利用できます。コメントからリファレンスマニュアルを作るシステムも存在します。</p>
<p>　JavaScriptでのコメントの書き方は以下の2通りがあります。</p>
<p>1行コメント</p>
<pre>
<code>// このうしろから行末までがコメントになります</code>
</pre>
<p>複数行コメント</p>
<pre>
<code>/* ここに複数行にわたるコメントを書きます。ここに複数行にわたるコメントを書きます。ここに複数行にわたるコメントを書きます。 */</code>
</pre>
<p>　コメントの書き方の例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>var a = 3;  // 行末までがコメントになります</code>
<code></code>
<code>/*</code>
<code>    これは複数行にわたるコメントです。</code>
<code>    例)initialize：初期化を行います。</code>
<code>*/</code>
<code>function initialize() {</code>
<code>    //...</code>
<code>}</code>
</pre>
<p>　ただし、コメントを濫用しないよう注意してください。シンプルで誰が見てもよくわかる、コメントがなくてもその意図がはっきり伝わる、そんなコードが理想です。当たり前のことをコメントで記述したり、コメントがないと理解不能な複雑なコードだったり、というような状況に陥らないように気をつけてください。</p>
</section>
</div>
<div id="calibre_link-189">
<section>
<hgroup>
<h1 id="calibre_link-156"><b>3-4　配列</b></h1>
</hgroup>
<p>　変数には1つの値だけでなく、複数の値をまとめて格納することも可能です。これを「配列」と呼びます。pointという変数にいくつかの数値を、namesという変数に複数の名字を格納する例を以下に示します。</p>
<figure>
<img src="images/00016.jpeg" />
<figcaption>配列は複数の値を格納する</figcaption>
</figure>
<p>　配列は、[ ]で括って宣言します。その中のデータはカンマ「，」で区切ります。</p>
<p>
<br />
</p>
<pre>
<code>var point = [1, 5, 3, 6, 8, 2];</code>
<code>var names = ["tanaka", "suzuki", "kato", "sato"];</code>
</pre>
<p>　個々の要素にアクセスするときは、変数のあとに「[数字]」を添えます。これを「添え字」と言います。添え字は0から始まることに注意してください。</p>
<p>
<br />
</p>
<pre>
<code>var a = point[0];   // a = 1</code>
<code>var b = point[1];   // b = 5</code>
<code>var c = point[2];   // c = 3</code>
</pre>
<p>
<br />
</p>
<pre>
<code>var x = names[0];   // "tanaka"</code>
<code>var y = names[1];   // "suzuki"</code>
<code>var z = names[2];   // "kato"</code>
</pre>
<p>　配列に含まれている要素の個数は、「配列の変数名.length」とすると取得できます。</p>
<p>
<br />
</p>
<pre>
<code>var p = point.length;   // p = 6</code>
<code>var q = names.length;   // q = 4</code>
</pre>
</section>
</div>
<div id="calibre_link-8">
<section>
<hgroup>
<h1 id="calibre_link-157"><b>3-5　演算子</b></h1>
</hgroup>
<p>　加算は「+」記号、減算は「-」記号です。これらは問題ないでしょう。掛け算の×はプログラムでは「*」（アスタリスク）、割り算の÷は「/」（スラッシュ）という記号を使います。「=」はイコールで値を代入するときに使います。</p>
<p>
<br />
</p>
<pre>
<code>var a = 6, b = 2;</code>
<code>var c = a * b;  // c = 12</code>
<code>var d = a / b;  // c = 3</code>
</pre>
<p>　余りを求める場合は「％」を使用します。</p>
<p>
<br />
</p>
<pre>
<code>var a = 5, b = 2;</code>
<code>var c = a % b;  // c = 1</code>
</pre>
<p>　また、プログラムでは値を1増やしたり、逆に1減らしたりすることをよく行います。そこで、専用の書き方が用意されています。</p>
<p>
<br />
</p>
<pre>
<code>var a = 5, b = 3;</code>
<code>a++;    // aの値を1増やす→aは6になる</code>
<code>b--;    // bの値を1減らす→bは2になる</code>
</pre>
<p>　ほとんどの場合、計算結果は変数に代入することになります。そのようなことを鑑みて、より簡便な書き方が用意されています。</p>
<p>
<br />
</p>
<pre>
<code>var a = 3, b = 3, c = 3, d = 3;</code>
<code>a += 2;     // a = a + 2; aは5になる</code>
<code>b -= 1;     // b = b - 1; bは2になる</code>
<code>c *= 4;     // c = c * 4; cは12になる</code>
<code>d /= 2;     // d = d / 2; dは1.5になる</code>
</pre>
</section>
</div>
<div id="calibre_link-74">
<section>
<hgroup>
<h1 id="calibre_link-158"><b>3-6　条件式</b></h1>
</hgroup>
</section>
</div>
<div id="calibre_link-185">
<section>
<h2 id="calibre_link-236"><b>3-6-1　条件式を利用した処理の繰り返し</b></h2>
<p>　プログラムはいろいろな場面で比較を行います。よく使われるのは値を比較して、条件を満たせば処理を繰り返すという処理です。</p>
<p>　たとえば、「functionA()」という処理を10回繰り返したいとします。単に同じ命令を10回書くこともできますが、効率的ではありません。</p>
<p>
<br />
</p>
<pre>
<code>functionA();</code>
<code>functionA();</code>
<code>functionA();</code>
<code>...</code>
<code>functionA();</code>
</pre>
<p>　このような処理はコンピュータに任せるべきです。今何回目かという情報を変数に格納し、繰り返すたびにその変数の値を増加させ、その値が10になったら次の処理に移行します。図に書くと以下のようになります。</p>
<figure>
<img src="images/00056.jpeg" />
<figcaption>処理を10回繰り返す</figcaption>
</figure>
<p>ソースは以下のようになります。</p>
<p>
<br />
</p>
<pre>
<code>for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>    // 何らかの処理</code>
<code>}</code>
<code>// 次の処理</code>
</pre>
<p>　先の図のひし形の部分で、「今何回目の実行か」という比較をします。このように値を比較して判断することを「条件式を評価する」と言います。</p>
</section>
</div>
<div id="calibre_link-82">
<section>
<h2 id="calibre_link-237"><b>3-6-2　代表的な条件式</b></h2>
<p>代表的な条件式を以下に示します。</p>
<table>
<caption>代表的な条件式</caption>
<tbody>
<tr>
  <th>条件式</th>
  <th>説明</th>
</tr>
<tr>
  <td>a == b</td>
  <td>aとbの値が同じ</td>
</tr>
<tr>
  <td>a != b</td>
  <td>aとbの値が違う</td>
</tr>
<tr>
  <td>a &lt; b</td>
  <td>aよりbのほうが大きい</td>
</tr>
<tr>
  <td>a &gt; b</td>
  <td>aのほうがbより大きい</td>
</tr>
<tr>
  <td>a &lt;= b</td>
  <td>aはb以下</td>
</tr>
<tr>
  <td>a &gt;= b</td>
  <td>bはa以下</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　条件式は成立するかしないかの二者択一です。成立するときは「真」(true)、成立しないときは「偽」(false)という値が返されます。条件式の実例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function init() {</code>
<code>                var a = 3, b = 3, c = 5;</code>
<code>                var x = (a == b);</code>
<code>                var y = (a != b);</code>
<code>                var z = (a &lt; b);</code>
<code>                var p = (a &gt; b);</code>
<code>                var q = (a &lt;= b);</code>
<code>                var r = (a &gt;= b);</code>
<code>                var str = "x=" + x + ",y=" + y + ",z=" + z;</code>
<code>                document.getElementById("info").textContent = str;</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;p id="info"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00041.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　aとbの値が等しいので、xの「(a == b)」はtrue、yの「(a != b)」はfalse、zの「(a &lt; b)」はfalseとなります。</p>
<p>　ちなみに、プログラム実行中の値を確認したい場合、上記のように画面上に表示することもできますが、コンソールと呼ばれる領域に出力することもできます。</p>
<p>
<br />
</p>
<pre>
<code>console.log(str)</code>
</pre>
<p>と実行すると、strの内容がコンソールに表示されます。コンソールを表示するにはデバッグツールを使用します。</p>
<hr />
<p>【演習】console.log()命令を使って、上記のリストの引数の内容をコンソールに出力してみましょう。</p>
<ol>
<li value="1">（1）前述のHTMLで、変数strを初期化している次の行に「console.log(str);」を挿入し、Internet Explorerで実行し、F12を押してデバッグツールを起動します。</li>
<li value="2">（2）スクリプトタブを表示し、スクリプトの最後の行の左側をクリックしてブレークポイント（「3-9-2 ブレークポイントの設定」参照）を設定します。</li>
<li value="3">（3）デバッグ開始ボタンを押して、F5で文書をリロードします。</li>
<li value="4">（4）右にある「ローカル」タブを開いて、x～rの値を確認します。</li>
</ol>
<figure>
<img src="images/00129.jpeg" />
<figcaption>Internet Explorerで実行</figcaption>
</figure>
<hr />
<h3 id="calibre_link-238">■押されたキーの判定</h3>
<p>　ほかの例を示しましょう。以下は「5-5 シューティングゲーム（1）」からの抜粋です。右キーか左キーが押されたことを判定するためにif文を使用しています。</p>
<p>
<br />
</p>
<pre>
<code>function keyDown(evt){</code>
<code>    if(evt.keyCode == 37) ship.moveL = true;</code>
<code>    if(evt.keyCode == 39) ship.moveR = true;</code>
<code>}</code>
</pre>
<p>　functionは、いくつかの処理をまとめるJavaScriptの命令で、「関数」と呼びます。詳しくは、「3-8 関数」を参照してください</p>
<p>　左キーは37、右キーは39というように、すべてのキーにはキーコードが割り当てられており、押下されたキーのコードがevt.keyCodeに格納されます。evt.keyCodeが37（左矢印キー）であれば変数ship.moveLに「true」を、evt.keyCodeが39（右矢印キー）であれば変数ship.moveRに「true」を代入しています。</p>
</section>
</div>
<div id="calibre_link-2">
<section>
<h2 id="calibre_link-239"><b>3-6-3　複数の条件式を組み合わせる－ANDとOR</b></h2>
<p>複数の条件式を組み合わせることもできます。</p>
<section>
<p>
<strong><b>AND（条件式1 &amp;&amp;  条件式2）</b></strong>
</p>
<p>
<strong><b>OR（条件式1 || 条件式2）</b></strong>
</p>
</section>
<p>　ANDは条件式1も真で、条件式2も真のときに全体が真に、それ以外のときに偽となります。ORは条件式1か条件式2のどちらかが真のときに全体が真となります。さらにANDとORを組み合わせることも可能です。</p>
<p>　たとえば、以下のコードでは、右矢印キーが押され、かつ、スコアscoreが100より大きい場合に条件式が成立します。</p>
<p>
<br />
</p>
<pre>
<code>if(evt.keyCode == 37 &amp;&amp; score &gt; 100) { ...</code>
</pre>
</section>
</div>
<div id="calibre_link-52">
<section>
<hgroup>
<h1 id="calibre_link-159"><b>3-7　制御式</b></h1>
</hgroup>
<p>　プログラムはいろいろな状況に応じて、実行する内容を変化させる必要があります。どんな命令があるのか見ていきましょう。</p>
</section>
</div>
<div id="calibre_link-133">
<section>
<h2 id="calibre_link-240"><b>3-7-1　if (条件式) then {式1} else {式2}</b></h2>
<p>　条件式が真のときに式1を実行し、偽のときに式2を実行します。else以降が不要な場合は省略してもかまいません。</p>
<section>
<p>
<strong><b>if (条件式) {</b></strong>
</p>
<p>
<strong><b>　　式1</b></strong>
</p>
<p>
<strong><b>} else {</b></strong>
</p>
<p>
<strong><b>　　式2</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>もしくは</p>
<section>
<p>
<strong><b>if (条件式) {</b></strong>
</p>
<p>
<strong><b>　　式1</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　以下は入力された値が数字かどうか判定するプログラムです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function checkEven() {</code>
<code>                var v = document.getElementById("number").value;</code>
<code>                var r = document.getElementById("result");</code>
<code>                if (isNaN(v)) {</code>
<code>                    r.textContent = v + "は数字ではありません";</code>
<code>                } else {</code>
<code>                    r.textContent = v + "は数字です";</code>
<code>                }</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;input id="number" /&gt;</code>
<code>        &lt;button onclick="checkEven()"&gt;入力判定&lt;/button&gt;</code>
<code>        &lt;p id="result"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　document.getElementById("number").valueで入力された値を取得します。</p>
<p>　「isNaN(v)」は「is Not a Number」という意味で、「vが数字ではないとき」に真を返す関数です。その結果によって、表示する文字列を変化させています。</p>
<p>　r.textContentに値を代入することで結果が画面に表示されます。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>上記のプログラムを入力・実行してみましょう</p>
<hr />
</section>
</div>
<div id="calibre_link-5">
<section>
<h2 id="calibre_link-241"><b>3-7-2　三項演算子</b></h2>
<p>　「i++;」「i--;」のような演算子を「単項演算子」と呼びます。「+」「-」「*」「/」「%」といった演算子は2つの数値の演算を行うので「二項演算子」と呼ばれます。三項演算子とは、「?」と「:」を組み合わせたもので、if～else文のような処理を簡単に記述するためのものです。以下のように、条件式が真のときに式1が実行され、偽のときに式2が実行されます。</p>
<section>
<p>
<strong><b>条件式 ？ 式1 : 式2</b></strong>
</p>
</section>
<p>　三項演算子を使って、偶数か奇数かも表示するように、先ほどの関数を修正してみました。以下にその様子を示します。</p>
<p>
<br />
</p>
<pre>
<code>function checkEven() {</code>
<code>    var v = document.getElementById("number").value;</code>
<code>    var r = document.getElementById("result");</code>
<code>    if (isNaN(v)) {</code>
<code>        r.textContent = v + "は数字ではありません";</code>
<code>    } else {</code>
<code>        r.textContent = (v % 2 == 0) ? "偶数" : "奇数";</code>
<code>    }</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-132">
<section>
<h2 id="calibre_link-242"><b>3-7-3　for (初期化式 ; ループ継続の条件式 ; カウンタ変数の更新) {式1}</b></h2>
<p>　for文はある条件下で処理を繰り返すときに使用します。</p>
<section>
<p>
<strong><b>for (初期化式 ; ループ継続の条件式 ; カウンタ変数の更新) {</b></strong>
</p>
<p>
<strong><b>　　式1</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　for文は以下のような手順で処理を行います。</p>
<ol>
<li value="1">(1) 初期化式を実行</li>
<li value="2">(2) ループ継続の条件式を見て、それが真であれば式1の実行、偽であれば終了</li>
<li value="3">(3) カウンタ変数の更新</li>
<li value="4">(4) ステップ（2）に戻る</li>
</ol>
<p>　たとえば、functionA()を10回実行するfor文は以下のようになります。</p>
<p>functionA()を10回実行するfor文（1）</p>
<pre>
<code>for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>    functionA();</code>
<code>}</code>
</pre>
<p>functionA()を10回実行するfor文（2）</p>
<pre>
<code>for (var i = 1 ; i &lt;= 10 ; i++) {</code>
<code>    functionA();</code>
<code>}</code>
</pre>
<p>　上下のどちらでも functionA()は10回実行されますが、配列の添え字が0から始まることもあり、（1）のほうがより一般的に使用されます。</p>
<p>　以下は、入力された値までの合計を求めるプログラムです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function sum() {</code>
<code>                var v = document.getElementById("number").value;</code>
<code>                var r = 0;</code>
<code>                for (var i = 1 ; i &lt;= v ; i++) {</code>
<code>                    r += i;</code>
<code>                }</code>
<code>                var s = "1から" + v + "の合計は" + r + "です";</code>
<code>                document.getElementById("result").textContent = s;</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;input id="number" /&gt;</code>
<code>        &lt;button onclick="sum()"&gt;合計&lt;/button&gt;</code>
<code>        &lt;p id="result"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<hr />
<p>
<strong><b>【演習】</b></strong>上記のプログラムを入力・実行してみましょう。</p>
<hr />
</section>
</div>
<div id="calibre_link-43">
<section>
<h2 id="calibre_link-243"><b>3-7-4　while (ループ継続の条件式) {式1}</b></h2>
<p>　while文はfor文とよく似ています。ループ継続の条件式が真である間、式1の実行を繰り返します。</p>
<section>
<p>
<strong><b>while (ループ継続の条件式) {</b></strong>
</p>
<p>
<strong><b>　　式1</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　先ほどのfor文を使ったfunctionA()を10回実行する例を、while文で書き直すと以下のようになります。</p>
<p>
<br />
</p>
<pre>
<code>var i = 0;</code>
<code>while (i &lt; 10) {</code>
<code>    functionA();</code>
<code>    i++;</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-4">
<section>
<h2 id="calibre_link-244"><b>3-7-5　switch～case</b></h2>
<p>　式の値に応じて、いくつかの処理に分岐させる場合に使用します。以下のような構文となります。</p>
<section>
<p>
<strong><b>switch (式) {</b></strong>
</p>
<p>
<strong><b>　　case 値1: 式1; break;</b></strong>
</p>
<p>
<strong><b>　　case 値2: 式2; break;</b></strong>
</p>
<p>
<strong><b>　　case 値3: 式3; break;</b></strong>
</p>
<p>
<strong><b>　　case 値4: 式4; break;</b></strong>
</p>
<p>
<strong><b>　　default:式5; break;</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　式を評価した値が「値1」のときは「式1」を実行、「値2」のときは「式2」を実行、「値3」のときは「式3」を実行、「値4」のときは式4を実行、それ以外のときは式5を実行という具合になります。</p>
<p>　以下は、switch文を利用して、どのキーが押下されたか表示するプログラムです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function keydown(e) {</code>
<code>                var s = "";</code>
<code>                switch (e.keyCode) {</code>
<code>                    case 37: s = "左"; break;</code>
<code>                    case 38: s = "上"; break;</code>
<code>                    case 39: s = "右"; break;</code>
<code>                    case 40: s = "下"; break;</code>
<code>                    default: s = "それ以外"; break;</code>
<code>                }</code>
<code>                document.getElementById("info").textContent = s;</code>
<code>            }</code>
<code>            window.addEventListener('keydown', keydown);</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;p id="info"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　「window.addEventListener('keydown', keydown);」の行は、キーが押下されたとき、keydown関数が実行されるようにするための命令です。</p>
<p>　switchの部分は以下のようにif～else文を使って記述することも可能です。</p>
<p>
<br />
</p>
<pre>
<code>function keydown(e) {</code>
<code>    var s = "";</code>
<code>    if (e.keyCode == 37) {</code>
<code>        s = "左";</code>
<code>    } else if (e.keyCode == 38) {</code>
<code>        s = "上";</code>
<code>    } else if (e.keyCode == 39) {</code>
<code>        s = "右";</code>
<code>    } else if (e.keyCode == 40) {</code>
<code>        s = "下";</code>
<code>    } else  {</code>
<code>        s = "それ以外";</code>
<code>    }</code>
<code></code>
<code>    document.getElementById("info").textContent = s;</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-23">
<section>
<h2 id="calibre_link-245"><b>3-7-6　continue、break</b></h2>
<p>　for文やwhile文といったループ処理において、その流れを変えるための命令です。</p>
<h3 id="calibre_link-246">■while文の場合</h3>
<section>
<p>
<strong><b>while (条件式1) {</b></strong>
</p>
<p>
<strong><b>　　if (条件式2) {</b></strong>
</p>
<p>
<strong><b>　　　　continue;　　　　// 条件式1へ</b></strong>
</p>
<p>
<strong><b>　　}</b></strong>
</p>
<p>
<strong><b>　　if (条件式3) {</b></strong>
</p>
<p>
<strong><b>　　　　break;　　　　　 // ループを抜ける</b></strong>
</p>
<p>
<strong><b>　　}</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　while文でcontinueが呼ばれると、continue文以降の処理は実行されることなく、「条件式1」の評価に戻り、while文の処理が継続されます。</p>
<p>　break文が呼び出されると、ループの処理が終わり、制御がwhile文の次に移動します。</p>
<h3 id="calibre_link-247">■for文の場合</h3>
<section>
<p>
<strong><b>for(初期化式; 条件式1; カウンタ更新) {</b></strong>
</p>
<p>
<strong><b>　　if (条件式2) {</b></strong>
</p>
<p>
<strong><b>　　　　continue;　　　　// カウンタ更新へ</b></strong>
</p>
<p>
<strong><b>　　}</b></strong>
</p>
<p>
<strong><b>　　if (条件式3) {</b></strong>
</p>
<p>
<strong><b>　　　　break;　　　　　 // ループを抜ける</b></strong>
</p>
<p>
<strong><b>　　}</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　一方、for文の場合は、continueが呼ばれると、continue文以降の処理は実行されることなく、カウンタ更新に処理が移動し、そのあと条件式1の評価が行われ、for文の処理が継続されます。</p>
<p>　break文が呼び出されると、ループの処理が終わり、制御がfor文の次に移動します。</p>
<p>　このようにcontinue、breakを使うと、ループ処理の中で細かい制御ができるようになります。ちなみに、以下のようにしても同じ処理を10回繰り返すことができます。</p>
<p>
<br />
</p>
<pre>
<code>var i = 0;</code>
<code>while (true) {</code>
<code>    if (i &gt;= 10) {</code>
<code>        break;</code>
<code>    }</code>
<code>    console.log("i="+i);</code>
<code>    i++;</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-21">
<section>
<hgroup>
<h1 id="calibre_link-160"><b>3-8　関数</b></h1>
</hgroup>
</section>
</div>
<div id="calibre_link-66">
<section>
<h2 id="calibre_link-248"><b>3-8-1　関数とは</b></h2>
<p>　関数とは、「引数」と呼ばれる入力値を受け取って、何らかの処理を行い、その結果を「戻り値」として返すものです。</p>
<figure>
<img src="images/00068.jpeg" />
<figcaption>関数は引数（入力値）を受け取って何らかの処理を行い戻り値（処理結果）を返す</figcaption>
</figure>
<p>　JavaScriptで関数を定義するには以下のように記述します。戻り値を返すときにはreturn文を使います。return文がない場合は、呼び出し元に値が返されません。</p>
<section>
<p>
<strong><b>function 関数名(引数1, 引数2, ...) {</b></strong>
</p>
<p>
<strong><b>　　何らかの処理</b></strong>
</p>
<p>
<strong><b>　　return 戻り値;</b></strong>
</p>
<p>
<strong><b>}</b></strong>
</p>
</section>
<p>　簡単な例を示しましょう。2つの数値を引数として受け取り、それらを足した結果を返す関数addは以下のようになります。</p>
<p>
<br />
</p>
<pre>
<code>function add(a, b) {</code>
<code>    return a + b;</code>
<code>}</code>
<code></code>
<code>var f = add(2, 5);       // f = 7</code>
</pre>
<p>　関数を呼び出す場合は、関数名のうしろに「(引数)」を付けます。引数の個数は自由に指定できます。また、関数によっては引数がないものや戻り値がないものもあります。</p>
</section>
</div>
<div id="calibre_link-9">
<section>
<h2 id="calibre_link-249"><b>3-8-2　変数のスコープ</b></h2>
<p>　変数はどこで宣言するかによって、使用できる範囲が変わってきます。関数の中で宣言した変数は関数の中からしか使用できません。一方、関数の外で宣言した変数は、どこからでも使用することができます。このような変数を「広域変数」もしくは「グローバル変数」と呼びます。</p>
<p>
<br />
</p>
<pre>
<code>//グローバルスコープ</code>
<code></code>
<code>var a = 0;    // aはグローバル変数</code>
<code></code>
<code>function init() {    // 関数initのスコープ</code>
<code>    var s = "";    // sはローカル変数</code>
<code>    //...</code>
<code>    a += 3;</code>
<code>}    // 関数initのスコープここまで</code>
<code></code>
<code>function keydown(e) {    // 関数keydownのスコープ、eはローカル変数</code>
<code>    var c = e.keyCode;    // cはローカル変数</code>
<code>    a += c;</code>
<code>    //...</code>
<code>}    // 関数keydownのスコープここまで</code>
</pre>
<p>　変数はaグローバルスコープで宣言されているので（関数の外側で宣言されているので）、グローバル変数となります。関数の中からでも外からでもアクセスすることができます。一方、変数sは関数init()の中で宣言されているので、関数init()の中でしか使えません。同様に、変数cと引数eは関数keydown() の中で宣言されているので、関数keydown()の中でしか使えません。</p>
<p>　グローバル変数はどこからでも使えるので便利なのですが、プログラムの規模が大きくなってくると、どこで何が行われるのか把握するのが困難になってしまいます。グローバル変数の使用はできるだけ控え、主な作業はローカル変数ですませるようにしてください。</p>
</section>
</div>
<div id="calibre_link-108">
<section>
<hgroup>
<h1 id="calibre_link-161"><b>3-9　デバッグ</b></h1>
</hgroup>
<p>　「デバッグ」とはプログラムの不具合を特定して、その問題を修正することです。最初に書いたプログラムがそのまま問題なく動作するということはまずありません。ほぼ間違いなくデバッグというプロセスが必要になります。</p>
<p>　昔は開発環境が充実していなかったので、デバッグは非常に大変な作業でしたが、最近はデバッグ用のツールも充実し、効率よくデバッグを行えるようになりました。デバッグツールを使いこなして効率よくデバッグを行えるというのは非常に重要なスキルです。ぜひ、この機会にツールに慣れるようにしてください。</p>
</section>
</div>
<div id="calibre_link-15">
<section>
<h2 id="calibre_link-250"><b>3-9-1　Internet Explorerのデバッガの使い方</b></h2>
<p>　ここでは、Internet Explorerに付属するデバッガ（デバッグ作業を支援するソフトウェア）の使い方を簡単に見てみましょう。題材とするプログラムは摂氏から華氏に変換するもので、ソースコードは以下の通りです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function c2f(c) {</code>
<code>                var f = (9 / 5) * c + 32;</code>
<code>                return Math.floor(f);</code>
<code>            }</code>
<code></code>
<code>            function convert() {</code>
<code>                var c = document.getElementById("celsius").value;</code>
<code>                var f = c2f(c);</code>
<code>                var s = "摂氏：" + c + "度　 華氏：" + f + "度";</code>
<code>                document.getElementById("result").textContent = s;</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;input id="celsius" type="range" min="0" max="100" onchange="convert()"/&gt;    &lt;!--（1）--&gt;</code>
<code>        &lt;p id="result"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　スライダーを操作すると、摂氏と華氏の温度が表示されます。</p>
<figure>
<img src="images/00031.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　input要素のtype属性にrangeと指定すると（リストの（1））、スライダーバーになります。値の範囲はminとmax属性で指定し、操作された際のイベントハンドラーはonchange属性で指定します。上記の例では、操作されるとconvert関数が呼び出されます。</p>
</section>
</div>
<div id="calibre_link-36">
<section>
<h2 id="calibre_link-251"><b>3-9-2　ブレークポイントの設定</b></h2>
<p>　F12キーを押下してデバッグツールを起動してください。「スクリプト」タブを選び、convert関数の行番号の左の領域をクリックして、関数にブレークポイントを設定します。正しく設定されると赤い丸が表示されます。</p>
<p>　ブレークポイントとは、そこに制御が来ると、すべての処理を一旦停止するポイントのことです。どのようにそこへ到達したのか、そのときの変数の値はどうなっているのか、など調べることができます。</p>
<p>　ブレークポイントを設定したら、「デバッグの開始」ボタンを押します。この状態にしてスライダーバーをクリックするとデバッグツールのブレークポイントがヒットします。</p>
<figure>
<img src="images/00092.jpeg" />
<figcaption>デバッグツールのブレークポイントがヒット</figcaption>
</figure>
<p>　ヒットした状態は黄色でハイライトされて表示されます。そのときに画面右のローカルタブを選択すると、ローカル変数の一覧とその値を見ることができます。</p>
<p>　ここでツールバーにある3つのボタンを使って処理を進めていきます。</p>
<figure>
<img src="images/00015.jpeg" />
<figcaption>デバッグ用のボタン</figcaption>
</figure>
<ul>
<li>ステップイン（F11）：次の行を実行します。次の行が関数の場合、その関数の最初の行へ制御を移します。</li>
<li>ステップオーバー（F10）：次の行を実行します。次の行が関数の場合、その関数を実行したあとで、関数の外で止まります。</li>
<li>ステップアウト（Shift+F11）：現在の関数を最後まで実行し、呼び出し元の関数に戻ります。</li>
</ul>
<p>　上記のブレークポイントがヒットしたあとでF11を押下すると、以下のように「var f = c2f(c);」の行にフォーカスが移動します。</p>
<figure>
<img src="images/00019.jpeg" />
<figcaption>「var f = c2f(c);」の行にフォーカス</figcaption>
</figure>
<p>　このあと、ステップインを実行すると、次のようになります。</p>
<figure>
<img src="images/00039.jpeg" />
<figcaption>ステップイン</figcaption>
</figure>
<p>　その後、ステップアウト、ステップオーバーと実行すると以下のようになります。</p>
<figure>
<img src="images/00054.jpeg" />
<figcaption>ステップアウト、ステップオーバーを実行</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>デバッガの使い方に慣れることは非常に大切です。いろいろな場所にブレークポイントを設定し、ステップイン、ステップアウト、ステップオーバーでどのように動くか確認してください。また、その際にローカル変数の値がどうなるか確認してください。</p>
<hr />
<p>　「デバッガを制する者はプログラムを制する」と言っても過言ではありません。そのくらいデバッガの習得は大切です。どの開発環境でもステップイン、ステップオーバー、ステップアウトなどの制御コマンドや、変数を見るための手段があるはずです。ぜひ、これを機会にデバッガに親しむようにしてください。</p>
</section>
</div>
<div id="calibre_link-7">
<section>
<hgroup>
<h1 id="calibre_link-162"><b>3-10　DOMの操作</b></h1>
</hgroup>
<p>　HTMLの章では、document.getElementById()を使ってJavaScriptからHTMLの要素を取得し、そのテキストを書き換える処理を行いました（「1-3-2 documentオブジェクト」参照）。ここでは、さらにさまざまな処理を見ていきましょう。</p>
</section>
</div>
<div id="calibre_link-79">
<section>
<h2 id="calibre_link-252"><b>3-10-1　要素の作成と挿入、既存の要素の削除</b></h2>
<p>　まず例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            function insertItem() {</code>
<code>                var container = document.getElementById("container");</code>
<code>                var item = document.createElement("li");    //（1）</code>
<code>                item.textContent = "hello";    //（2）</code>
<code>                container.appendChild(item);    //（3）</code>
<code>            }</code>
<code>            function removeItem() {</code>
<code>                var container = document.getElementById("container");</code>
<code>                var item = container.lastChild;    //（4）</code>
<code>                if (item) {</code>
<code>                    container.removeChild(item);    //（5）</code>
<code>                }</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;button onclick="insertItem()"&gt;insert&lt;/button&gt;</code>
<code>        &lt;button onclick="removeItem()"&gt;delete&lt;/button&gt;</code>
<code>        &lt;ol id="container"&gt;&lt;/ol&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　insertボタンを押下するとリストに項目が追加されていきます。deleteボタンを押下すると要素が削除されていきます。</p>
<figure>
<img src="images/00110.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<h3 id="calibre_link-253">■要素の作成と挿入</h3>
<ol>
<li value="1">（1）要素の作成は「document.createElement("タグ名")」で行います。戻り値itemがその要素となります。この時点ではまだ文書に追加されていないので、見た目は変化しないことに注意してください。</li>
<li value="2">（2）item要素に適切なプロパティを設定します。</li>
<li value="3">（3）そして、それを親要素containerのappendChildメソッドを使って文書に追加しています。これで、画面上に要素の追加が反映されます。</li>
</ol>
<h3 id="calibre_link-254">■既存の要素の削除</h3>
<ol>
<li value="1">（4）親要素containerへの参照を取得し、lastChildプロパティで一番うしろにある子要素itemを取得します。</li>
<li value="2">（5）もし子要素があった場合、「container.removeChild(item);」でその要素を文書から削除します。</li>
</ol>
<p>　このように、createElement()で要素を作り、親要素のappendChildメソッドを使って文書に挿入できます。削除する場合は、親要素のremoveChildを呼び出します。</p>
</section>
</div>
<div id="calibre_link-192">
<section>
<h2 id="calibre_link-255"><b>3-10-2　文書ツリーをたどるためのプロパティ</b></h2>
<p>　文書中のDOM要素からは、以下のようなプロパティでほかの要素への参照を取得できます。</p>
<table>
<caption>文書ツリーをたどるためのプロパティ</caption>
<tbody>
<tr>
  <th>プロパティ</th>
  <th>説明</th>
</tr>
<tr>
  <td>parentNode</td>
  <td>親要素</td>
</tr>
<tr>
  <td>firstChild</td>
  <td>子要素の中で先頭に位置する要素</td>
</tr>
<tr>
  <td>lastChild</td>
  <td>子要素の中で最後に位置する要素</td>
</tr>
<tr>
  <td>previousElementSibling</td>
  <td>同じ親要素を共有する要素の中で1つ前の要素</td>
</tr>
<tr>
  <td>nextElementSibling</td>
  <td>同じ親要素を共有する要素の中で1つうしろの要素</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　上記プロパティの関係図を次に示します。</p>
<figure>
<img src="images/00145.jpeg" />
<figcaption>文書ツリー</figcaption>
</figure>
<p>　以下のようにすると、getElementByIdで取得した要素を簡単に削除できます。</p>
<p>
<br />
</p>
<pre>
<code>var target = document.getElementById("target");</code>
<code>var parent = target.parentNode;</code>
<code>parent.removeChild(target);</code>
</pre>
<p>　デバッガを使用すると、DOM要素にはどんなプロパティやメソッドがあるか調べることができます。デバッガでブレークポイントがヒットした状態にして、「ウォッチ」ウィンドウに調べたい変数名を入力します。そのオブジェクトのプロパティやメソッドが表示されます。</p>
<figure>
<img src="images/00077.jpeg" />
<figcaption>デバッガでプロパティやメソッドを確認</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-65">
<section>
<h2 id="calibre_link-256"><b>3-10-3　スタイルの指定</b></h2>
<p>　要素のスタイルもJavaScriptから変更することができます。要素のスタイルは、background-color、color、top、leftといったCSSのスタイルを使って指定します。スクリプトからスタイルにアクセスする場合は</p>
<section>
<p>
<strong><b>DOM要素.style.プロパティ名</b></strong>
</p>
</section>
<p>でアクセスします。</p>
<p>　以下に、クリックするたびに色を変えるプログラムを以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            div {</code>
<code>                color: green;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var colors = ["red", "blue", "yellow", "green"];</code>
<code>            var index = 0;</code>
<code>            function changeColor() {</code>
<code>                document.getElementById("ufo").style.color = colors[index];</code>
<code>                if (++index &gt;= colors.length) {</code>
<code>                    index = 0;</code>
<code>                }</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;div id="ufo"&gt;&lt;(ooo)&gt;&lt;/div&gt;</code>
<code>        &lt;button onclick="changeColor()"&gt;click me&lt;/button&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　JavaScriptでスタイルを設定する際に注意すべき点があります。colorなどの1単語からなるスタイル名は、CSSでもJavaScriptでも同じ名前を使用することができます。しかし、「background-color」のようにハイフンを含むスタイルにJavaScriptからアクセスする場合には、「backgroundColor」のようにハイフンを削除して、そのうしろの文字を大文字に変更する必要があります。これはJavaScriptではハイフンはマイナス「-」と解釈されてしまうためです。たとえば、「margin-left」は「marginLeft」、「border-right-style」は「borderRightStyle」となります。</p>
<p>　また、スタイルを直接指定する代わりにクラス属性を指定することも可能です。たとえば、</p>
<p>
<br />
</p>
<pre>
<code>var td = document.createElement("td");</code>
<code>td.className = "cell";</code>
</pre>
<p>のように作成した要素にclassNameプロパティを指定すると、この要素に「&lt;td class="cell"&gt;」と記述したのと同じ効果が得られます。CSSのルールに、「td.cell {background-color:Gray;}」と書いておけば、この要素の背景がグレーになります。複数のスタイルを指定する場合はclassName属性を使ったほうが簡単かもしれません。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>兄弟でマルバツゲームがやりたいと駄々をこね始めました。勝敗の判定は自分たちでできるので、クリックすると〇と×が表示されれば満足なようです。</p>
<figure>
<img src="images/00103.jpeg" />
<figcaption>マルバツゲーム</figcaption>
</figure>
<p>　これはtable要素を利用して3×3のマスを作り、そのマスがクリックされたときに、偶数回目なら〇、奇数回目なら×を描画すればよいでしょう。tableの中のtdでは</p>
<p>
<br />
</p>
<pre>
<code>&lt;td class="cell" onclick="clickMe(this);"&gt;</code>
</pre>
<p>とすればよいでしょう。thisは要素自身を示すので、こうしておけば、関数clickMeの引数でクリックされた要素が取得できます。</p>
<p>　偶数奇数の判定は</p>
<p>
<br />
</p>
<pre>
<code>if (count++ % 2 == 0)</code>
</pre>
<p>で行えるでしょう。まずは皆さんで挑戦してみてください。</p>
<p>　以下は解答例です。いろいろな書き方があると思いますが、あくまでも一例としてご覧ください。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            .cell {</code>
<code>                width:100px;height:100px;</code>
<code>                font-size:60pt; text-align: center;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var count = 0;</code>
<code>            function clickMe(e) {</code>
<code>                if (count++ % 2 == 0) {</code>
<code>                    e.textContent = "○";</code>
<code>                } else {</code>
<code>                    e.textContent = "×";</code>
<code>                }</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>    &lt;table border="1"&gt;</code>
<code>        &lt;tr&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>        &lt;/tr&gt;</code>
<code>        &lt;tr&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt;　&lt;/td&gt;</code>
<code>        &lt;/tr&gt;</code>
<code>        &lt;tr&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt; &lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt; &lt;/td&gt;</code>
<code>            &lt;td class="cell" onclick="clickMe(this);"&gt; &lt;/td&gt;</code>
<code>        &lt;/tr&gt;</code>
<code>    &lt;/table&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<hr />
</section>
</div>
<div id="calibre_link-88">
<section>
<hgroup>
<h1 id="calibre_link-163"><b>3-11　オブジェクトの操作</b></h1>
</hgroup>
<p>　辞書で「オブジェクト」を調べると「物、物体、目的」などと説明されています。身の回りの「物」はすべてオブジェクトなのです。そのような物に共通する特徴を捉え、それをプログラムで表現することで問題の解決を図ろうとするのがオブジェクト指向プログラミングの考え方です。</p>
<p>　この説明ではピンとこないですよね？「オブジェクト」は、数字や文字のようにわかりやすい概念ではないので、最初はとっつき難いものです。ただ、プログラミングをするうえでオブジェクトを避けて通ることはできません。以降の説明を何度も読み返し、慣れるように頑張ってください！</p>
</section>
</div>
<div id="calibre_link-59">
<section>
<h2 id="calibre_link-257"><b>3-11-1　プロパティ、メソッド、インタフェース</b></h2>
<h3 id="calibre_link-258">■プロパティ</h3>
<p>　たとえば、家の中にある家電製品を見てみましょう。掃除機、炊飯器、テレビ、照明、コタツ、ドライヤーいろいろなものがあるでしょう。これらはみんなオブジェクトです。オブジェクトには、オブジェクトを区別する何らかの特徴があります。色、大きさ、重さ、これらはオブジェクトの特徴です。この特徴のことを「プロパティ」と呼びます。</p>
<h3 id="calibre_link-259">■メソッド</h3>
<p>　また、オブジェクトは何らかの方法で操作できます。テレビなら電源を入れて、チャンネルを変えて、音量を調節して、という具合です。車なら、エンジンをかけて、アクセルを踏んで、ブレーキを踏んで、と操作するでしょう。このようにオブジェクトに対して働きかける操作を「メソッド」と呼びます。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>ペンにはどんなプロパティ、どんなメソッドがあるでしょうか？また、自動車にはどんなメソッドとプロパティがあるでしょうか？</p>
<hr />
<h3 id="calibre_link-260">■インタフェース</h3>
<p>　新しくテレビを買ったとしましょう。どのメーカーのテレビでも説明書を読まなくても使えるのは、テレビの使い方を知っているからです。新しい車を買ったとしましょう。どのメーカーの車でも直ぐに運転できるのは、車の運転方法を知っているからです。テレビの操作、車の運転といった操作には共通点があります。この意味のある操作方法のまとまりのことを「インタフェース」と呼びます。テレビのインタフェースには、電源のオン／オフ、音量のアップ／ダウンという操作があり、車のインタフェースにはエンジンのオン／オフ、ブレーキ、アクセル、ハンドル操作といったものがあります。前述したように個々の操作のことを「メソッド」と呼びますが、意味のあるメソッドの集合が「インタフェース」となります。</p>
<h3 id="calibre_link-261">■カプセル化</h3>
<p>　私たちがテレビのチャンネルを変えると、テレビの中では、受信周波数を変える、パケットを取り出す、画像をデコードする、というように、非常に複雑な処理が行われます。車も、アクセルを踏むと、ガソリンがエンジンに送られ燃焼系でピストンが動いてと、こちらも大変な作業が行われます。しかし、ユーザーの立場からすると、このようにテレビや車の中で起きていることを意識する必要はありません。このように中で起きていることを隠すことを「カプセル化」と呼びます。</p>
<p>
<br />
</p>
<p>　ここまでの説明をまとめてみると以下のような図になります。</p>
<figure>
<img src="images/00011.jpeg" />
<figcaption>オブジェクトのメソッド、プロパティ、インタフェース</figcaption>
</figure>
<p>　例が日常的過ぎて、プログラムの話とはうまくむすびつかなかったかもしれません。では、実際のプログラムで、オブジェクト指向的な考え方がどのように利用されるのかを見てみましょう。</p>
</section>
</div>
<div id="calibre_link-1">
<section>
<h2 id="calibre_link-262"><b>3-11-2　JavaScriptでのオブジェクト実装例</b></h2>
<p>　UFOを画面上で動かすようなプログラムを作る場合を想定してみましょう。UFOは画面上のどこかに表示されるので、x、yといった座標値が必要です。これらはプロパティとなります。コンピュータの世界では、画面の左上が座標系の原点（0,0）となり、右方向をx、下方向をyで表現します。</p>
<p>　さらにUFOを左右に動かすのであれば、moveRight、moveLeftといったメソッドも用意するのがよさそうです。</p>
<figure>
<img src="images/00125.jpeg" />
<figcaption>UFOゲーム</figcaption>
</figure>
<p>　JavaScriptでこのUFOオブジェクトを定義して使ってみましょう。プログラムは以下の通りです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            div {</code>
<code>                position: absolute;</code>
<code>                width: 60px;</code>
<code>                height: 25px;</code>
<code>                color: green;</code>
<code>                top: 50px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ufo;</code>
<code>            function init() {</code>
<code>                window.addEventListener("keydown", keydown);</code>
<code>                ufo = new UFO(document.getElementById("ufo"), 100);</code>
<code>            }</code>
<code></code>
<code>            function keydown(e) {</code>
<code>                if (e.keyCode == 37) {</code>
<code>                    ufo.moveLeft();</code>
<code>                } else if (e.keyCode == 39) {</code>
<code>                    ufo.moveRight();</code>
<code>                }</code>
<code>            }</code>
<code></code>
<code>            function UFO(_elem, _xpos) {</code>
<code>                this.elem = _elem;</code>
<code>                this.xpos = _xpos;</code>
<code>                this.moveLeft = function () {</code>
<code>                    this.xpos -= 10;</code>
<code>                    this.elem.style.left = this.xpos + "px";</code>
<code>                }</code>
<code>                this.moveRight = function () {</code>
<code>                    this.xpos += 10;</code>
<code>                    this.elem.style.left = this.xpos + "px";</code>
<code>                }</code>
<code>                this.elem.style.left = this.xpos + "px";</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;div id="ufo"&gt;&lt;(ooo)&gt;&lt;/div&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　左右のキーを押すと「ufo」（&lt;(ooo)&gt;）が画面上を左右に動きます。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>入力して実際に動かしてみましょう。keydownにブレークポイントを設定して、キーが押下されたときにどのように動くかも確認してみましょう。</p>
<hr />
<p>　body要素にonload属性があります。このonload属性に関数を指定すると、文書の読み込みが終了したときに、その関数が実行されます。今回の場合では「&lt;body onload="init()"&gt;」と指定しているので、文書の読み込みが終了するとinit()関数が実行されます。</p>
<p>
<br />
</p>
<pre>
<code>function init() {</code>
<code>    window.addEventListener("keydown", keydown);</code>
<code>    ufo = new UFO(document.getElementById("ufo"), 100);</code>
<code>}</code>
</pre>
<p>　initの1行目ではkeydownイベントのハンドラーを登録しています。これによりキーが押下されたときにkeydown関数が実行されるようになります。</p>
<p>　今回の肝は3行目です。この行でufoというオブジェクトを作成しています。次に、オブジェクトの作成方法について細かく見ていきましょう。</p>
</section>
</div>
<div id="calibre_link-48">
<section>
<h2 id="calibre_link-263"><b>3-11-3　JavaScriptでのオブジェクトのつくり方</b></h2>
<p>JavaScriptでのオブジェクトのつくり方は以下の通りです。</p>
<section>
<p>
<strong><b>オブジェクト = new 関数(引数1, 引数2, ...)</b></strong>
</p>
</section>
<p>　ここで多くの人が混乱するのですが、JavaScriptでは、以下の両方の目的でfunctionを使います。</p>
<ul>
<li>ある程度の処理をまとめる普通の関数</li>
<li>オブジェクトを作成する命令</li>
</ul>
<p>　オブジェクトを作成する場合には「new」というキーワードが必要になるので何とか区別はつくのですが、非常に紛らわしいのが現状です。ほかの言語では、これら2つを明確に区別するものが多いのですが、残念ながらJavaScriptはこのようなルールになってしまっています。これは慣れるしかありません。ちなみに、オブジェクトを作るための関数を「コンストラクタ」と呼びます。</p>
<p>　ともあれ、ufoオブジェクトができたので、操作するためにメソッドを呼ぶことができるようになります。今回の例ではufoにmoveLeftとmoveRightというメソッドが実装されているので、それらを呼び出すことが可能となります。</p>
<p>
<br />
</p>
<p>　オブジェクトのメソッドを呼ぶ場合は</p>
<section>
<p>
<strong><b>オブジェクト.メソッド()</b></strong>
</p>
</section>
<p>というように、オブジェクトのうしろに「．」ピリオドを付け、そのうしろでメソッドを呼び出します。このようにすることで、「どのオブジェクトで、どんなメソッドを実行したいのか」ということを表現しています。つまり、ufoオブジェクトのmoveLeftメソッドを呼ぶには、ufo.moveLeft()と記述します。メソッドを呼ぶことを「オブジェクトにメッセージを送る」と表現することもあります。</p>
<figure>
<img src="images/00118.jpeg" />
<figcaption>メソッドの呼び出し</figcaption>
</figure>
<p>　これで、ufo.moveLeft()と呼ぶだけでufoは左に動き、ufo.moveRight()と呼ぶだけで右に動くようになります。この様子はkeydown関数を見るとよくわかります。</p>
<p>
<br />
</p>
<pre>
<code>function keydown(e) {</code>
<code>    if (e.keyCode == 37) {</code>
<code>        ufo.moveLeft();</code>
<code>    } else if (e.keyCode == 39) {</code>
<code>        ufo.moveRight();</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　押されたキーが左(37)ならufo.moveLeft()を実行し、右ならufo.moveRight()を実行しているだけです。ufoの中で何が起きているか、呼び出し側は知る必要はありません。</p>
<p>　今回のようにオブジェクトを作る側と呼び出す側が同じ場合にはあまり恩恵を感じませんが、オブジェクトを作る側と呼び出す側が別の人の場合、これが非常に重要になります。多人数で協力してプログラムを作る場合、全部のコードを把握することは困難になります。たとえば、Windowsの開発者のことを考えてみましょう。Windowsのソースコードは巨大で、とても個人で全部を把握することはできません。そのような状況においては、中身を知らずにオブジェクトを使えることが特に重要になります。「中身を知らないと使えない」ということでは、オブジェクトを使用する側の負担が非常に大きくなってしまうからです。</p>
<p>
<br />
</p>
<p>　では、オブジェクトの宣言はどのようになっているかを見ていきましょう。</p>
<p>
<br />
</p>
<pre>
<code>function UFO(_elem, _xpos) {</code>
<code>    this.elem = _elem;</code>
<code>    this.xpos = _xpos;</code>
<code>    this.moveLeft = function () {</code>
<code>        this.xpos -= 10;</code>
<code>        this.elem.style.left = this.xpos + "px";</code>
<code>    }</code>
<code>    this.moveRight = function () {</code>
<code>        this.xpos += 10;</code>
<code>        this.elem.style.left = this.xpos + "px";</code>
<code>    }</code>
<code>    this.elem.style.left = this.xpos + "px";</code>
<code>}</code>
</pre>
<p>　一見すると普通の関数と変わりありません。しかし、よく見るとthisというキーワードが多用されていることに気づきます。このthisは「オブジェクト自分自身」を示しています。</p>
<p>　「this.elem = _elem;」という行は、「&lt;div id="ufo"&gt;&lt;(ooo)&gt;&lt;/div&gt;」という要素への参照をオブジェクトのelemプロパティに格納しています。同様に、「this.xpos = _xpos;」という行は、オブジェクトにxposというプロパティを登録し、その初期値として引数の_xposを使用するということを意味しています。</p>
<p>　じつはJavaScriptとしては、プロパティもメソッドも区別していません。プロパティは値、メソッドは関数というだけで、JavaScriptはそれらを特別扱いすることはありません。よって、メソッドもプロパティと同様に実装していきます。以下の部分がmoveLeftメソッドの宣言です。</p>
<p>
<br />
</p>
<pre>
<code>this.moveLeft = function () {</code>
<code>    this.xpos -= 10;</code>
<code>    this.elem.style.left = this.xpos + "px";</code>
<code>}</code>
</pre>
<p>　「function () {..}」というのは名前のない関数なので、「匿名メソッド」と呼ばれます。このように名前のない関数をmoveLeftというプロパティに代入しています。ufo.moveLeft()と呼び出したときに、この匿名関数の中身が実行されます。その中では、xposプロパティの値を10減らし、それを画面に反映させるために、elem要素のleftスタイルの値を更新しています。</p>
</section>
</div>
<div id="calibre_link-57">
<section>
<h2 id="calibre_link-264"><b>3-11-4　プロトタイプ</b></h2>
<p>　「プロトタイプ」はJavaScriptに特徴的な概念です。これも非常にとっつきにくい概念なので例を使って説明していきましょう。</p>
<p>　大きなプログラムを作成していると、いろいろなオブジェクトを沢山使用する必要があります。新しいオブジェクトが必要となるたびに、すべてを最初から作り直すのは面倒です。ソフトウェアの進化は「楽をしようと努力した結果」の歴史です。JavaScriptのようなオブジェクト指向言語では、オブジェクトを再利用する仕組みが用意されています。</p>
<p>　多少強引ですが、先ほどのUFOに上下に移動する機能を追加したNewUFOを作ることにしましょう。それには上下の場所を示すyposというプロパティや、moveUp、moveDownといったメソッドが必要になります。先ほどのUFOを作り直して実装することも可能ですが、ここではあえて楽をするため、先ほどのUFOはそのままとし、差分だけを実装するアプローチをとることにします。そこででてくるのが「プロトタイプ」です。</p>
<p>　もともとあったUFOに加え、NewUFOを作ります。NewUFOからUFOへはprototypeという関連付けをします。その方法はのちほど説明します。</p>
<figure>
<img src="images/00027.jpeg" />
<figcaption>UFOをもとにNewUFOを作成</figcaption>
</figure>
<p>　NewUFOのmoveUpを実行したと仮定します。moveUpはNewUFOで定義されているので、そのオブジェクトで処理が行われます。ちょうど、UFOオブジェクトでmoveLeftやmoveRightが呼ばれたときと同じように処理されます。</p>
<figure>
<img src="images/00055.jpeg" />
<figcaption>moveUpメソッドを実行</figcaption>
</figure>
<p>　次に、NewUFOに対してmoveLeftメソッドを実行した場合を見てみます。NewUFOにはmoveLeftというメソッドはありません。そこで、prototypeをたどってUFOオブジェクトのmoveLeftメソッドを実行します。</p>
<figure>
<img src="images/00105.jpeg" />
<figcaption>prototypeをたどってUFOオブジェクトのmoveLeftメソッドが実行される</figcaption>
</figure>
<p>　これがprototypeの仕組みです。差分だけを実装するだけですむのです。修正後のソースコードは以下の通りです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            div {</code>
<code>                position: absolute;</code>
<code>                width: 60px;</code>
<code>                height: 25px;</code>
<code>                color: green;</code>
<code>                top: 50px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ufo, newufo;</code>
<code>            function init() {</code>
<code>                window.addEventListener("keydown", keydown);</code>
<code>                var ufo = new UFO(document.getElementById("ufo"), 100);</code>
<code>                NewUFO.prototype = ufo;    //（1）</code>
<code>                newufo = new NewUFO(100);</code>
<code>            }</code>
<code></code>
<code>            function keydown(e) {</code>
<code>                if (e.keyCode == 37) {</code>
<code>                    newufo.moveLeft();</code>
<code>                } else if (e.keyCode == 39) {</code>
<code>                    newufo.moveRight();</code>
<code>                } else if (e.keyCode == 38) {</code>
<code>                    newufo.moveUp();</code>
<code>                } else if (e.keyCode == 40) {</code>
<code>                    newufo.moveDown();</code>
<code>                }</code>
<code>            }</code>
<code></code>
<code>            function UFO(_elem, _xpos) {</code>
<code>                this.elem = _elem;</code>
<code>                this.xpos = _xpos;</code>
<code>                this.moveLeft = function () {</code>
<code>                    this.xpos -= 10;</code>
<code>                    this.elem.style.left = this.xpos + "px";</code>
<code>                }</code>
<code>                this.moveRight = function () {</code>
<code>                    this.xpos += 10;</code>
<code>                    this.elem.style.left = this.xpos + "px";</code>
<code>                }</code>
<code>                this.elem.style.left = this.xpos + "px";</code>
<code>            }</code>
<code></code>
<code>            function NewUFO(_ypos) {</code>
<code>                this.ypos = _ypos;</code>
<code>                this.moveUp = function () {</code>
<code>                    this.ypos -= 10;</code>
<code>                    this.elem.style.top = this.ypos + "px";</code>
<code>                }</code>
<code>                this.moveDown = function () {</code>
<code>                    this.ypos += 10;</code>
<code>                    this.elem.style.top = this.ypos + "px";</code>
<code>                }</code>
<code>                this.elem.style.top = this.ypos + "px";</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;div id="ufo"&gt;&lt;(ooo)&gt;&lt;/div&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　init()の中に以下の行があります（1）。</p>
<p>
<br />
</p>
<pre>
<code>NewUFO.prototype = ufo;</code>
</pre>
<p>　この行こそが、UFOオブジェクトとNewUFOオブジェクトの間にprototypeという関連付けをしているところです。</p>
<p>　ここで、</p>
<ul>
<li>ufoはUFO関数で作られたオブジェクト</li>
<li>NewUFOはオブジェクトを作るための関数（コンストラクタ）</li>
</ul>
<p>であることに注意してください。つまり、</p>
<section>
<p>
<strong><b>コンストラクタ.prototype = オブジェクト</b></strong>
</p>
</section>
<p>と指定しているのです。図にすると以下のようになります。</p>
<figure>
<img src="images/00101.jpeg" />
<figcaption>NewUFOオブジェクトからUFOオブジェクトにprototypeという関連付けを設定</figcaption>
</figure>
<p>　もう一度整理してみましょう。</p>
<p>
<br />
</p>
<pre>
<code>NewUFO.prototype = ufo;</code>
</pre>
<p>　NewUFOはコンストラクタです。そのprototypeプロパティにufoオブジェクトを代入しています。上図における上側の点線矢印がこの処理に相当します。</p>
<p>
<br />
</p>
<pre>
<code>newufo = new NewUFO(100);</code>
</pre>
<p>とすると、新しいnewufoオブジェクトが作成されます。このオブジェクトには、自動的にprototypeというプロパティが設定され、その参照先がufoオブジェクトとなるのです。上図における下側の点線矢印がこの処理に相当します。</p>
<p>　この書き方は、理屈ではありません。JavaScriptでは、再利用をするためにこのようなルールが用意されていると理解してください。</p>
<p>　ゲームのキャラクターを考えてみましょう。何種類かの敵を用意する必要があったとき、プロトタイプの仕組みを使えば、敵の共通部分だけをprototypeとして用意しておき、あとは差分だけを実装するだけですみます。「5-4 ボールの反射を応用したゲーム」では、ブロックとパドル部分、どちらも矩形として描画しています。そこで、実際に後述するサンプルではこの部分をprototypeとしています。また、「5-9 落ちもの系ゲーム」では、いろいろな形のブロックがでてきますが、共通部分はprototypeとして実装しています。</p>
<h3 id="calibre_link-265">■配列の要素を乱数で並べ替える</h3>
<p>　prototypeを使った具体例をもう1つ紹介しておきましょう。ゲームを作るときには、配列の要素を乱数で並べ替える必要に迫られることが多々あります。Math.randomを使って自分で記述することも可能ですが、思いのほか面倒です。であれば、JavaScriptの配列に、要素を乱数で並べ替えるような機能を追加してしまいましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code></code>
<code>            Array.prototype.shuffle = function () {</code>
<code>                var i = this.length;</code>
<code>                while (i) {</code>
<code>                    var j = Math.floor(Math.random() * i);</code>
<code>                    var t = this[--i];</code>
<code>                    this[i] = this[j];</code>
<code>                    this[j] = t;</code>
<code>                }</code>
<code>                return this;</code>
<code>            }</code>
<code></code>
<code>            function shuffle() {</code>
<code>                var cards = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6];</code>
<code>                cards.shuffle();</code>
<code>                document.getElementById("result").textContent = cards.join(",");</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;button onclick="shuffle()"&gt;shuffle&lt;/button&gt;</code>
<code>        &lt;p id="result"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　Array.prototypeにshuffleというメソッドを追加しています。メソッドの中身はFisher-Yatesというアルゴリズムですが、ここは理解しなくてもかまいません。このようにArrayのprototypeに指定した内容はすべての配列オブジェクトからたどることができるので、すべての配列オブジェクトでshuffleというメソッドが使えることになります。上記のコードでは、以下のようにJavaScriptの配列cardsを宣言しています。</p>
<p>
<br />
</p>
<pre>
<code>var cards = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6];</code>
<code>cards.shuffle();</code>
</pre>
<p>　もともとのJavaScriptの配列にはshuffleというメソッドはありません。しかし、Array.prototypeに定義したので、shuffleメソッドを使って、配列の要素の順序を乱数で入れ替えることが可能になったのです。プロトタイプの威力を感じ取ってもらえたでしょうか？</p>
<p>　プロトタイプはJavaScriptの中で一番大きな壁になると思います。一度で理解する必要はありませんし、おそらくできないでしょう。いろいろなサンプルを読んで、自分で再利用する努力をすることで、そのうち自然とマスターできるようになるでしょう。あきらめずに頑張ってください。</p>
</section>
</div>
<div id="calibre_link-11">
<section>
<hgroup>
<h1 id="calibre_link-164"><b>3-12　組み込みオブジェクト</b></h1>
</hgroup>
<p>　JavaScriptには最初から用意されている便利な関数やオブジェクトがあります。ここではそのような機能について見ていきましょう。</p>
</section>
</div>
<div id="calibre_link-104">
<section>
<h2 id="calibre_link-266"><b>3-12-1　タイマー</b></h2>
<p>　文字通りタイマーの機能です。一定時間後に関数を実行する、もしくは定期的に関数を実行するといった機能を実現します。</p>
<table>
<caption>タイマー関連の主なメソッド</caption>
<tbody>
<tr>
  <th>メソッド</th>
  <th>説明</th>
</tr>
<tr>
  <td>setTimeout(関数名, ミリ秒)</td>
  <td>ミリ秒後に関数を1回呼び出す</td>
</tr>
<tr>
  <td>clearTimeout(timerId1)</td>
  <td>setTimeoutの処理を停止する。timerId1はsetTimeoutの戻り値</td>
</tr>
<tr>
  <td>setInterval(関数名, ミリ秒)</td>
  <td>ミリ秒間隔で関数を繰り返し呼び出す</td>
</tr>
<tr>
  <td>clearInterval(timerId2)</td>
  <td>setIntervalの処理を停止する。timerId2はsetIntervalの戻り値</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　setTimeoutで作成したタイマーはclearTimeoutでクリア、setIntervalで作成したタイマーはclearIntervalでクリア、のようにペアで使います。これらのメソッドを使った例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var timerId;</code>
<code></code>
<code>            function timeoutStart() {    // タイマーの開始</code>
<code>                timerId = setTimeout(whattime, 3000);</code>
<code>            }</code>
<code>            function timeoutStop() {    // タイマーの停止</code>
<code>                clearTimeout(timerId);</code>
<code>            }</code>
<code></code>
<code>            function intervalStart() {    // 定期的タイマーの開始</code>
<code>                timerId = setInterval(whattime, 2000);</code>
<code>            }</code>
<code>            function intervalStop() {    // 定期的タイマーの停止</code>
<code>                clearInterval(timerId);</code>
<code>            }</code>
<code></code>
<code>            function whattime() {    // 今何時かを画面に表示</code>
<code>                document.getElementById("info").textContent = new Date();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;button onclick="timeoutStart()"&gt;setTimeout&lt;/button&gt;</code>
<code>        &lt;button onclick="timeoutStop()"&gt;clearTimeout&lt;/button&gt;</code>
<code></code>
<code>        &lt;button onclick="intervalStart()"&gt;setInterval&lt;/button&gt;</code>
<code>        &lt;button onclick="intervalStop()"&gt;clearInterval&lt;/button&gt;</code>
<code>        &lt;p id="info"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00022.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　setTimeoutをクリックすると3秒後に、setIntervalをクリックすると2秒間隔で時刻が表示されます。setTimeoutをキャンセルする場合はclearTimeoutを呼び出します（すでにタイマー時刻が過ぎていた場合は何も起きません）。setIntervalによる更新を停止する場合はclearIntervalを呼び出します。</p>
<p>　ここで、setIntervalを連続してクリックすると、1秒間隔で更新され、clearIntervalをクリックしてもタイマーが止まらなくなります。これはsetIntervalを複数回実行することで、複数のタイマーが同時にスケジューリングされてしまうためです。</p>
<figure>
<img src="images/00122.jpeg" />
<figcaption>setIntervalを複数回実行するとタイマーが止まらなくなる</figcaption>
</figure>
<p>　このような状況に陥ると、clearIntervalを実行しても、最後のタイマーのみしかキャンセルされないので、タイマーが常時動き続けてしまいます。このような状況を避け、1つのタイマーしか動作しないようにしたいのであれば、以下のようにsetIntervalを呼ぶ前にタイマーをクリアするようにすればよいでしょう。</p>
<p>
<br />
</p>
<pre>
<code>function intervalStart() {</code>
<code>    clearInterval(timerId);</code>
<code>    timerId = setInterval(whattime, 2000);</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-70">
<section>
<h2 id="calibre_link-267"><b>3-12-2　Mathオブジェクト</b></h2>
<p>　各種計算を行うためのメソッドを提供しています。主なメソッドに以下のようなものがあります。</p>
<table>
<caption>計算を行う主なメソッド</caption>
<tbody>
<tr>
  <th>メソッド</th>
  <th>説明</th>
</tr>
<tr>
  <td>Math.min(a, b)</td>
  <td>aとbの小さいほうを返す</td>
</tr>
<tr>
  <td>Math.max(a, b)</td>
  <td>aとbの大きいほうを返す</td>
</tr>
<tr>
  <td>Math.random()</td>
  <td>0以上1未満の乱数を発生させる</td>
</tr>
<tr>
  <td>Math.floor(n)</td>
  <td>nを繰り下げた整数値を返す</td>
</tr>
<tr>
  <td>Math.ceil(n)</td>
  <td>nを切り上げた整数値を返す</td>
</tr>
<tr>
  <td>Math.round(n)</td>
  <td>nを四捨五入した整数値を返す</td>
</tr>
<tr>
  <td>Math.sqrt(n)</td>
  <td>nの平方根を返す</td>
</tr>
<tr>
  <td>Math.PI</td>
  <td>円周率（3.1415...）を返す</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　これらのメソッドを使った例を以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        function minmax() {</code>
<code>            var n = document.getElementById("randomRange").value;</code>
<code>            var a = Math.min(3, n);    // 3とnの小さいほうをaに代入</code>
<code>            var b = Math.max(3, n);    // 3とnの大きいほうをbに代入</code>
<code>            var c = Math.max(3, Math.min(6, n));    // 3以上6以下</code>
<code>            var s = "n=" + n + " min(3, n)=" + a + " max(3, n)=" + b + " c=" + c;</code>
<code>            document.getElementById("info").textContent = s;</code>
<code>        }</code>
<code>        function random() {</code>
<code>            var n = document.getElementById("randomRange").value;</code>
<code>            var a = Math.random();    // 0から1の乱数生成</code>
<code>            var b = Math.floor(a * n);    // n倍して切り捨て→整数化</code>
<code>            var s = "n=" + n + " a=" + a + " b=" + b;</code>
<code>            document.getElementById("info").textContent = s;</code>
<code>            Math.sqrt(n)</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body&gt;</code>
<code>        &lt;input type="range" min="0" max="10" id="randomRange" /&gt;</code>
<code>        &lt;button onclick="minmax()"&gt;min/max&lt;/button&gt;</code>
<code>        &lt;button onclick="random()"&gt;random&lt;/button&gt;</code>
<code>        &lt;p id="info"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　max、minはシンプルなので特に説明の必要はないと思います。この2つを組み合わせると、ある一定範囲に値を制限することが簡単に行えます。たとえば、</p>
<p>
<br />
</p>
<pre>
<code>var c = Math.max(3, Math.min(6, n));</code>
</pre>
<p>　このようにするとnがどのような値であろうと、cは3以上6以下の範囲に収まります。</p>
<p>　また、randomとfloorを組み合わせると、一定範囲に収まる乱数の整数を生成することができます。これもゲームではよく使用されます。</p>
</section>
</div>
<div id="calibre_link-20">
<section>
<h2 id="calibre_link-268"><b>3-12-3　Arrayオブジェクト</b></h2>
<p>　配列は、[ ]で括って宣言します。基本的な使い方は、「3-4 配列」で説明しました。配列にはプロトタイプが自動で設定されるために、非常に便利な使い方が可能です。以下の配列に対していろいろなメソッドを順番に呼んだときの例を列挙します。</p>
<section>
<p>
<strong><b>var data = [1, 8, 5, 7, 2, 6, 7, 4, 0];</b></strong>
</p>
</section>
<h3 id="calibre_link-269">■length</h3>
<p>　配列に含まれる要素の数を返します。</p>
<p>
<br />
</p>
<pre>
<code>var r0 = data.length;   // r0 = 9</code>
</pre>
<h3 id="calibre_link-270">■indexOf(検索対象[, 検索位置])</h3>
<p>　引数の検索対象と同じ内容を先頭から探し、その番号を返します。ない場合は-1を返します。どこから検索を始めるかという検索位置を指定することもできます。先頭の要素の番号は0です。戻り値は0から始まることに注意してください。</p>
<p>
<br />
</p>
<pre>
<code>var r1 = data.indexOf(2);   // r1 = 4</code>
</pre>
<h3 id="calibre_link-271">■lastIndexOf(検索対象[, 検索位置])</h3>
<p>　引数の検索対象と同じ内容をうしろから探し、その番号を返します。ない場合は-1を返します。どこから検索を始めるかという検索位置を指定することもできます。</p>
<p>
<br />
</p>
<pre>
<code>var r2 = data.lastIndexOf(7);   // r2 = 6</code>
</pre>
<h3 id="calibre_link-272">■splice(index, howMany [, e1, e2 ...])</h3>
<p>　indexからhowMany個分の古い要素を取り除き、必要に応じてその位置に新しい要素を追加します。</p>
<p>
<br />
</p>
<pre>
<code>var r3 = data.splice(2, 4); // r3 = [5,7,2,6]</code>
</pre>
<h3 id="calibre_link-273">■sort([func])</h3>
<p>　配列の内容をソートして、その結果を返します。ソートの方法を制御するfunc関数を指定することも可能です。</p>
<p>
<br />
</p>
<pre>
<code>var r4 = data.sort();   // r4 = [0, 1, 2, 4, 5, 6, 7, 7, 8]</code>
</pre>
<h3 id="calibre_link-274">■push(e1)</h3>
<p>　配列の最後に要素e1を追加します。</p>
<p>
<br />
</p>
<pre>
<code>var r5 = data.push(9); // r5 = 10</code>
</pre>
<h3 id="calibre_link-275">■pop()</h3>
<p>　配列の最後の要素を削除して返します。shift()は先頭の要素を削除して返します。</p>
<p>
<br />
</p>
<pre>
<code>var r6 = data.pop(); // r6 = 9</code>
</pre>
<h3 id="calibre_link-276">■forEach(callback)</h3>
<p>　配列の各要素を引数として、都度コールバック関数を実行します。コールバック関数とは、のちほど呼び出される関数で、事前に処理内容を定義しておくものです。このメソッドで指定するコールバック関数は、Arrayの各要素を引数として、要素の回数分呼び出される関数となります。</p>
<p>
<br />
</p>
<pre>
<code>data.forEach(function (n) {</code>
<code>    console.log("n=" + n);</code>
<code>});</code>
</pre>
<p>
<br />
</p>
<p>　もし「var data = [1,8,5,7,2,6,7,4,0]」と宣言されていた場合、このコールバック関数は、9回呼び出され</p>
<p>
<br />
</p>
<pre>
<code>n=1</code>
<code>n=8</code>
<code>n=5</code>
<code> ...</code>
<code>n=4</code>
<code>n=0</code>
</pre>
<p>とコンソールに出力されることになります。</p>
<h3 id="calibre_link-277">■every(callback)</h3>
<p>　配列の各要素を引数として、都度コールバック関数を実行します。すべてのコールバックでtrueが返されると、この呼び出しの結果としてtrueが返ります。</p>
<p>
<br />
</p>
<pre>
<code>// r7 = true; data = [0,1,4,7,8]</code>
<code>var r7 = data.every(function (n) {</code>
<code>    return n &lt; 10;</code>
<code>});</code>
<code></code>
<code>// r8 = false; data = [0,1,4,7,8]</code>
<code>var r8 = data.every(function (n) {</code>
<code>    return n &lt; 5;</code>
<code>});</code>
</pre>
<h3 id="calibre_link-278">■some(callback)</h3>
<p>　配列の各要素を引数として、都度コールバック関数を実行します。どれかのコールバックでtrueが返されると、この呼び出しの結果としてtrueが返ります。</p>
<p>
<br />
</p>
<pre>
<code>// r9 = true; data = [0,1,4,7,8]</code>
<code>var r9 = data.some(function (n) {</code>
<code>    return n == 4;</code>
<code>});</code>
<code></code>
<code>// r10 = false; data = [0,1,4,7,8]</code>
<code>var r10 = data.some(function (n) {</code>
<code>    return n == 3;</code>
<code>});</code>
</pre>
<h3 id="calibre_link-279">■filter(callback)</h3>
<p>　配列の各要素を引数として、都度コールバック関数を実行します。コールバックがtrueを返した値からなる新しい配列を返します。</p>
<p>
<br />
</p>
<pre>
<code>// r11 = [0,4,8] ; data = [0,1,4,7,8]</code>
<code>var r11 = data.filter(function (n) {</code>
<code>    return n % 2 == 0;</code>
<code>});</code>
</pre>
<p>　このほかにもメソッドがいろいろと用意されていますが、まずはこの程度で大丈夫でしょう。</p>
</section>
</div>
<div id="calibre_link-100">
<section>
<hgroup>
<h1 id="calibre_link-165"><b>3-13　JSON記法</b></h1>
</hgroup>
<p>　ここまでいろいろなJavaScriptオブジェクトについて学んできましたが、最近のJavaScriptではオブジェクトの作成が簡単にできるようにJSON（JavaScript Object Notation）という記法が用意されました。ここではその概要を簡単に紹介します。</p>
<p>　従来、オブジェクトを作成し、そのプロパティやメソッドをセットするのは面倒な処理でした。まずは例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>var person1 = new Object();</code>
<code>person1.age = 10;</code>
<code>person1.name = "Rinta";</code>
<code>var person2 = new Object();</code>
<code>person2.age = 8;</code>
<code>person2.name = "Yuwa";</code>
<code>var persons = new Array(person1, person2);</code>
</pre>
<p>　2つのオブジェクトを作成し、それぞれに年齢ageと名前nameプロパティを設定しています。そして、それらを配列Arrayの要素として参照しています。</p>
<p>　JSON記法を使ってこれを書き直すと以下のようになります。</p>
<p>
<br />
</p>
<pre>
<code>var persons = [</code>
<code>    {</code>
<code>        "age": 10,</code>
<code>        "name": "Rinta",</code>
<code>    },</code>
<code>    {</code>
<code>        "age": 8,</code>
<code>        "name": "Yuwa",</code>
<code>    },</code>
<code>];</code>
</pre>
<p>　JSONと聞くと難しそうなイメージを持たれるかもしれませんが、単にArrayを[ ]で、Objectを{ }で記述するというルールにすぎません。上の例では、personsという配列を[ ]で宣言し、その要素として2つのオブジェクトを{ }で指定しています。オブジェクトのプロパティやメソッド名は</p>
<section>
<p>
<strong><b>"プロパティ名"：プロパティの値</b></strong>
</p>
</section>
<p>のように記述します。複数ある場合はカンマ「，」で区切って記載します。やっていることは従来の例とまったく同じですが、シンプルでわかりやすい記述になった気がしませんか？</p>
<p>　JSONはその記述の簡潔さからいろいろなところで使用されるようになりました。専門用語的な響きがあり、難しそうなイメージを持たれるかもしれませんが、実際には単なる記法にすぎません。簡単にオブジェクトや配列を記述することができるので、慣れると重宝すると思います。</p>
</section>
</div>
<div id="calibre_link-125">
<div>
<h1 id="calibre_link-166"><b>第4章　Canvas</b></h1>
<h2 id="calibre_link-280"><b>HTML5の描画機能</b></h2>
</div>
<section>
<p><b>　CanvasはHTML5で新しく追加された機能です。文字通り、線、矩形、円、ポリゴン、画像などいろいろなものを描画することができます。CanvasによってWebページの可能性は飛躍的に広がり、特にゲームでは欠かせない要素となりました。本章では、このCanvasの使い方について説明していきます。</b></p>
</section>
</div>
<div id="calibre_link-61">
<section>
<hgroup>
<h1 id="calibre_link-167"><b>4-1　コンテキスト</b></h1>
</hgroup>
<p>　絵筆を使って絵を描く状況を想像してみてください。絵筆に絵の具をつけて色を変え、筆を交換して線の太さを変えます。筆を持つ手を同じように動かしても（同じような処理を行っても）、そのときの絵の具や筆の状態によって描画される内容が変わっていきます。この絵筆の状態をコンテキスト（文脈）と呼びます。</p>
<figure>
<img src="images/00047.jpeg" />
<figcaption>絵筆の色・線の太さなどの状態をコンテキストと呼ぶ</figcaption>
</figure>
<p>　線と矩形を描画するサンプルを以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>    var ctx;</code>
<code>    function init() {</code>
<code>        var canvas = document.getElementById("canvas");    //（1）</code>
<code>        ctx = canvas.getContext("2d");</code>
<code>        ctx.strokeStyle = "#FF0000";</code>
<code>        ctx.fillStyle = "#00FF00";</code>
<code>        ctx.lineWidth = 10;</code>
<code>        ctx.lineCap = "round";</code>
<code>        ctx.shadowColor = "#000000";</code>
<code>        ctx.shadowBlur = 20;</code>
<code></code>
<code>        // 線を引く</code>
<code>        ctx.beginPath();</code>
<code>        ctx.moveTo(100, 100);</code>
<code>        ctx.lineTo(300, 150);</code>
<code>        ctx.stroke();</code>
<code></code>
<code>        // 矩形を描く</code>
<code>        ctx.fillRect(100, 200, 200, 100);</code>
<code>        ctx.strokeRect(100, 200, 200, 100);</code>
<code>    }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00144.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　線を引く部分と矩形を描く処理は後述します。ここでは、コンテキストを取得し、その内容を設定する部分に注目してください。</p>
<p>　コンテキストは、（1）のように、いったんcanvasを取得し、そのgetContext("2d")メソッドを呼ぶことで取得します。これはお決まりの処理です。多くのプログラムでは、コンテキストをctxやcontextといったグローバル変数に格納しているようです。</p>
<p>　コンテキストの主なプロパティを以下に列挙します 。参照すると現在の値が取得でき、値を代入すると、コンテキストを変更することができます。</p>
<table>
<caption>コンテキストの主なプロパティ</caption>
<tbody>
<tr>
  <th>プロパティ</th>
  <th>説明</th>
</tr>
<tr>
  <td>ctx.strokeStyle</td>
  <td>線や輪郭の色</td>
</tr>
<tr>
  <td>ctx.fillStyle</td>
  <td>塗りつぶしの色</td>
</tr>
<tr>
  <td>ctx.lineWidth</td>
  <td>線の幅</td>
</tr>
<tr>
  <td>ctx.lineCap</td>
  <td>線の終端の形状で、butt、round、squareの値が使用可能</td>
</tr>
<tr>
  <td>ctx.shadowColor</td>
  <td>現在の影の色</td>
</tr>
<tr>
  <td>ctx.shadowBlur</td>
  <td>影に適用するぼかす範囲</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　なお、以下のサイトに詳しいレファレンスがあります。</p>
<ol>
<li value="1">
<a href="http://www.html5.jp/canvas/ref.html">http://www.html5.jp/canvas/ref.html</a>
</li>
</ol>
</section>
</div>
<div id="calibre_link-14">
<section>
<hgroup>
<h1 id="calibre_link-168"><b>4-2　描画の方法</b></h1>
</hgroup>
<p>　それではさっそくいろいろな描画を行っていきましょう。</p>
</section>
</div>
<div id="calibre_link-18">
<section>
<h2 id="calibre_link-281"><b>4-2-1　線の描画</b></h2>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code>            ctx.strokeStyle = "#FF0000";</code>
<code>            ctx.lineWidth = 5;</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.moveTo(100, 100);</code>
<code>            ctx.lineTo(150, 50);</code>
<code>            ctx.lineTo(200, 100);</code>
<code>            ctx.stroke();</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.strokeStyle = "#FF00FF";</code>
<code>            ctx.moveTo(300, 100);</code>
<code>            ctx.lineTo(350, 50);</code>
<code>            ctx.lineTo(400, 100);</code>
<code>            ctx.closePath();</code>
<code>            ctx.stroke();</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.fillStyle = "#FFFF00";</code>
<code>            ctx.moveTo(500, 100);</code>
<code>            ctx.lineTo(550, 50);</code>
<code>            ctx.lineTo(600, 100);</code>
<code>            ctx.fill();</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00072.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　このコードで行われていることをイメージ図で表すと以下のようになります。</p>
<figure>
<img src="images/00171.jpeg" />
<figcaption>サンプルコードのイメージ</figcaption>
</figure>
<p>　筆の動く軌跡を「パス」と呼びます。beginPath()はパスをクリアする命令です。まとまった描画を行うときには、その前にbeginPath()を呼ぶ習慣をつけておくとよいでしょう。</p>
<p>　moveToで最初に筆を下す場所を指定し、lineToで筆を動かしていきます。この時点ではパスを作っているだけで画面上に描画されないことに注意してください。closePath()はパスを閉じる処理を行います。最後にstroke()を呼ぶことで実際の描画が行われます。塗りつぶす場合はfill()を呼びます。線の色はstrokeStyleで、塗りつぶしの色はfillStyleで指定します。</p>
</section>
</div>
<div id="calibre_link-40">
<section>
<h2 id="calibre_link-282"><b>4-2-2　矩形の描画</b></h2>
<p>　moveToやlineToを使って4辺を描画してもかまいませんが、矩形は頻繁に描画されるため、便利なメソッドが用意されています。</p>
<section>
<p>
<strong><b>ctx.fillRect(x, y, width, height);</b></strong>
</p>
</section>
<p>　x,yを左上とする幅width、高さheightの大きさの矩形を塗りつぶします。</p>
<section>
<p>
<strong><b>ctx.strokeRect(x, y, width, height);</b></strong>
</p>
</section>
<p>　x,yを左上とする幅width、高さheightの矩形の枠線を描画します。</p>
<section>
<p>
<strong><b>ctx.clearRect(x, y, width, height);</b></strong>
</p>
</section>
<p>　x,yを左上とする幅width、高さheightの大きさの矩形領域をクリアします。クリアした部分は透明になります。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code>            ctx.strokeStyle = "#FF0000";</code>
<code>            ctx.fillStyle = "#00FFFF";</code>
<code>            ctx.lineWidth = 5;</code>
<code></code>
<code>            ctx.fillRect(100, 30, 80, 50);</code>
<code>            ctx.strokeRect(200, 30, 80, 50);</code>
<code>            ctx.fillRect(300, 30, 80, 50);</code>
<code>            ctx.clearRect(320, 50, 50, 20);</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00051.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　fillRectやstrokeRectでは明示的にfillやstrokeを呼び出す必要はありません。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>いろいろな矩形を描画してみましょう。</p>
<hr />
</section>
</div>
<div id="calibre_link-81">
<section>
<h2 id="calibre_link-283"><b>4-2-3　円の描画</b></h2>
<p>　円弧を書くためにメソッドが用意されています。</p>
<section>
<p>
<strong><b>ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</b></strong>
</p>
</section>
<p>　xとyは中心座標で、radiusが半径です。startAngleで円弧を描き始める角度を、endAngleで円弧を描き終る角度を指定します。</p>
<p>　角度は「ラジアン」という単位で指定します。これは1回転（360°）を、2×π（＝3.1415...×2）とする単位です。度数からラジアンへの変換は「度数×π÷180」で求められます。たとえば、60°は360°の1/6なので、これをラジアンで表すと「60×π÷180＝π÷3」となります。anticlockwiseにtrueを指定すると反時計回り、falseで時計回りとなります。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code>            ctx.strokeStyle = "#FF0000";</code>
<code>            ctx.fillStyle = "#00FFFF";</code>
<code>            ctx.lineWidth = 5;</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.arc(100, 50, 30, 0, 2 * Math.PI);</code>
<code>            ctx.closePath();</code>
<code>            ctx.fill();</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.moveTo(200, 50);</code>
<code>            ctx.arc(200, 50, 30, 0, Math.PI / 3);</code>
<code>            ctx.closePath();</code>
<code>            ctx.stroke();</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.moveTo(300, 50);</code>
<code>            ctx.arc(300, 50, 30, 0, Math.PI / 3, true);</code>
<code>            ctx.closePath();</code>
<code>            ctx.stroke();</code>
<code></code>
<code>            ctx.beginPath();</code>
<code>            ctx.moveTo(400, 50);</code>
<code>            ctx.arc(400, 50, 30, -1 * Math.PI / 6, Math.PI / 6, true);</code>
<code>            ctx.closePath();</code>
<code>            ctx.fill();</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　上記のサンプルにおけるパラメータと実際の描画の様子を以下に示します。</p>
<figure>
<img src="images/00023.jpeg" />
<figcaption>サンプルコードのイメージ</figcaption>
</figure>
<p>　円の場合は、開始角に0、終了角に2×πを指定します。円弧の場合は開始角と終了角を指定しますが、円弧を描画する方向によって結果が大きく異なることに注意してください。また、arcは単に円弧のパスを描くだけです。よって以下のようなコードではパスの部分しか塗りつぶされません。</p>
<p>
<br />
</p>
<pre>
<code>ctx.beginPath();</code>
<code>ctx.arc(500, 50, 30, 0, 2 * Math.PI / 3);</code>
<code>ctx.fill();</code>
</pre>
<figure>
<img src="images/00172.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<hr />
<p>
<strong><b>【演習】</b></strong>以下のようなサッカー場をCanvasで描画してみましょう。</p>
<figure>
<img src="images/00142.jpeg" />
<figcaption>サッカー場をCanvasで描画</figcaption>
</figure>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                var canvas = gobj("canvas");</code>
<code>                ctx = canvas.getContext("2d");</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.fillStyle = "green";</code>
<code>                ctx.fillRect(0, 0, 600, 300);</code>
<code></code>
<code>                ctx.strokeStyle = "white";</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(300, 0);</code>
<code>                ctx.lineTo(300, 300);</code>
<code>                ctx.stroke();</code>
<code></code>
<code>                ctx.beginPath();</code>
<code>                ctx.rect(0, 100, 50, 100);</code>
<code>                ctx.stroke();</code>
<code></code>
<code>                ctx.beginPath();</code>
<code>                ctx.rect(550, 100, 50, 100);</code>
<code>                ctx.stroke();</code>
<code></code>
<code>                ctx.beginPath();</code>
<code>                ctx.arc(300, 150, 50, 0, Math.PI * 2);</code>
<code>                ctx.stroke();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="600" height="300" id="canvas"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>
<br />
</p>
<p>
<strong><b>【演習】</b></strong>ステップ1：以下のような絵をCanvasで描画してみましょう。</p>
<figure>
<img src="images/00141.jpeg" />
<figcaption>ステップ1：上図を描画する</figcaption>
</figure>
<p>■ステップ1のソース例</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx, x = 150, y = 150;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                var canvas = gobj("canvas");</code>
<code>                ctx = canvas.getContext("2d");</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.fillStyle = "black";</code>
<code>                ctx.fillRect(0, 0, 300, 300);</code>
<code>                ctx.fillStyle = "yellow";</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(x, y);</code>
<code>                ctx.arc(x, y, 30, -Math.PI / 4, Math.PI / 4, true);</code>
<code>                ctx.fill();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>
<strong><b>【演習】</b></strong>ステップ2：setIntervalを使って口をパクパク動かしてみましょう。</p>
<p>■ステップ2のソース例</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx, x = 150, y = 150, isOpen = true;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                var canvas = gobj("canvas");</code>
<code>                ctx = canvas.getContext("2d");</code>
<code>                setInterval(tick, 200);</code>
<code>            }</code>
<code></code>
<code>            function tick() {</code>
<code>                isOpen = !isOpen;</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.fillStyle = "black";</code>
<code>                ctx.fillRect(0, 0, 300, 300);</code>
<code>                ctx.fillStyle = "yellow";</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(x, y);</code>
<code>                if (isOpen) {</code>
<code>                    ctx.arc(x, y, 30, -Math.PI / 4, Math.PI / 4, true);</code>
<code>                } else {</code>
<code>                    ctx.arc(x, y, 30, 0, Math.PI * 2, true);</code>
<code>                }</code>
<code>                ctx.fill();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>
<strong><b>【演習】</b></strong>ステップ3：上下左右キーの押下に応じて、パクパクする口の向きを変えてみましょう。</p>
<p>■ステップ3のソース例</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx, x = 150, y = 150, isKeyDown, isOpen = true, rotate = 0;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                var canvas = gobj("canvas");</code>
<code>                ctx = canvas.getContext("2d");</code>
<code>                document.onkeydown = mykeydown;</code>
<code>                document.onkeyup = keyup;</code>
<code>                setInterval(tick, 200);</code>
<code>            }</code>
<code></code>
<code>            function tick() {</code>
<code>                if (isKeyDown) {</code>
<code>                    isOpen = !isOpen;</code>
<code>                }</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function mykeydown(e) {</code>
<code>                switch (e.keyCode) {</code>
<code>                    case 37: rotate = Math.PI;</code>
<code>                        break; // left</code>
<code>                    case 38: rotate = -Math.PI / 2;</code>
<code>                        break; // up</code>
<code>                    case 39: rotate = 0;</code>
<code>                        break; // right</code>
<code>                    case 40: rotate = +Math.PI / 2;</code>
<code>                        break; // down</code>
<code>                }</code>
<code>                isKeyDown = true;</code>
<code>            }</code>
<code></code>
<code>            function keyup(e) {</code>
<code>                isKeyDown = false;</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.fillStyle = "black";</code>
<code>                ctx.fillRect(0, 0, 300, 300);</code>
<code>                ctx.fillStyle = "yellow";</code>
<code>                ctx.beginPath();</code>
<code>                ctx.save();</code>
<code>                ctx.translate(x, y);</code>
<code>                ctx.rotate(rotate);</code>
<code>                ctx.moveTo(0, 0);</code>
<code>                if (isOpen) {</code>
<code>                    ctx.arc(0, 0, 30, -Math.PI / 4, Math.PI / 4, true);</code>
<code>                } else {</code>
<code>                    ctx.arc(0, 0, 30, 0, Math.PI * 2, true);</code>
<code>                }</code>
<code>                ctx.restore();</code>
<code>                ctx.fill();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="300" height="300" id="canvas"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<hr />
</section>
</div>
<div id="calibre_link-105">
<section>
<hgroup>
<h1 id="calibre_link-169"><b>4-3　文字</b></h1>
</hgroup>
<p>　フォントの指定はコンテキストのfontプロパティで行います。値はCSSのfontスタイルと同じ形式で指定します。実際の文字の描画には以下の2つのメソッドを利用します。</p>
<section>
<p>
<strong><b>ctx.fillText(text, x, y [, maxWidth]);</b></strong>
</p>
</section>
<p>　x,y座標を起点としてtextを塗りつぶして描画します。maxWidthで最大幅を指定することも可能です。</p>
<section>
<p>
<strong><b>ctx.strokeText(text, x, y [, maxWidth]);</b></strong>
</p>
</section>
<p>　x,y座標を起点としてtextの輪郭を描画します。maxWidthで最大幅を指定することも可能です。</p>
<p>　文字を描画するサンプルを以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code>            ctx.font = "32px 'ＭＳ ゴシック'";</code>
<code></code>
<code>            ctx.strokeStyle = "blue";</code>
<code>            ctx.strokeText("strokeTextによる文字", 10, 50);</code>
<code></code>
<code>            ctx.fillStyle = "green";</code>
<code>            ctx.fillText("fillTextによる文字", 10, 100);</code>
<code></code>
<code>            ctx.fillStyle = "red";</code>
<code>            ctx.fillText("ABCDEFGHIJKLMNOPQRSTUVWXYZ", 10, 150, 200);</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　描画の様子を以下に示します。</p>
<figure>
<img src="images/00093.jpeg" />
<figcaption>文字の塗りと輪郭線</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-24">
<section>
<hgroup>
<h1 id="calibre_link-170"><b>4-4　画像</b></h1>
</hgroup>
<p>　Canvasに画像を描画するには、以下の3つのメソッドのどれかを使用します。</p>
<p>
<br />
</p>
<section>
<p>
<strong><b>ctx.drawImage(image, dx, dy)</b></strong>
</p>
<p>
<strong><b>ctx.drawImage(image, dx, dy, dw, dh)</b></strong>
</p>
<p>
<strong><b>ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</b></strong>
</p>
</section>
<p>
<br />
</p>
<p>　上記のパラメータにおいて、dはdestination（＝描画対象となるCanvas）、sはsource（＝描画する元画像）を意味しています。xとyは座標、wは幅、hは高さを表しています。このパラメータを図にすると以下のようになります。</p>
<figure>
<img src="images/00167.jpeg" />
<figcaption>drawImageのパラメータ</figcaption>
</figure>
<p>　Canvasに画像を描画するサンプルを以下に示します。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code></code>
<code>            var ship = document.getElementById("ship");</code>
<code>            var photo = document.getElementById("photo");</code>
<code>            ctx.drawImage(ship, 10, 10);</code>
<code>            ctx.drawImage(ship, 10, 100, 50, 50);</code>
<code>            ctx.drawImage(photo, 260, 480, 200, 150, 150, 10, 200, 150);</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>        &lt;img id="photo" src="picture2.jpg" style="display:none" /&gt;    &lt;!--（1）--&gt;</code>
<code>        &lt;img id="ship" src="ship.png" style="display:none" /&gt;    &lt;!--（2）--&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>　表示結果は以下のようになります。</p>
<figure>
<img src="images/00038.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　drawImageの最初の引数はimg要素への参照です。img要素には「style="display:none"」のようにdisplay属性にnoneが指定されています（1）（2）。これによりimg要素はHTML文書中に表示されなくなります。今回、画像はすべてCanvas上に描画しています。img要素が描画されているわけではないので、これらを混乱しないよう注意してください。</p>
<p>　元の画像と表示結果との対応関係を以下の図に示します。</p>
<figure>
<img src="images/00017.jpeg" />
<figcaption>元の画像</figcaption>
</figure>
<figure>
<img src="images/00117.jpeg" />
<figcaption>実際に描画される画像</figcaption>
</figure>
<p>　drawImage(ship, 10, 10)では、元画像の大きさのまま、指定した場所に描画されています。drawImage(ship, 10, 100, 50, 50)では、元画像全体が、指定した場所に指定された大きさで描画されています。drawImage(photo, 260, 480, 200, 150, 150, 10, 200, 150)では、元画像の特定の領域が、指定した場所に指定された大きさで描画されています。</p>
</section>
</div>
<div id="calibre_link-115">
<section>
<hgroup>
<h1 id="calibre_link-171"><b>4-5　座標系</b></h1>
</hgroup>
<p>　Canvasを使うと、文字や図形、画像などいろいろと描画できることがわかりました。Canvasにはさらに座標系を変換するという強力な機能が用意されています。</p>
<p>　たとえば、次のような時計の文字盤を描画する必要があったとします。これは、それぞれの座標を求めて、moveToやlineToを使って線を引くことで描画できます。</p>
<figure>
<img src="images/00130.jpeg" />
<figcaption>時計の文字盤</figcaption>
</figure>
<p>　しかし、実際にみなさんが手書きで紙に描いていくときは、おそらく、下図のように紙を回転させるのではないでしょうか？</p>
<figure>
<img src="images/00107.jpeg" />
<figcaption>紙を回転させて描く</figcaption>
</figure>
<p>　これこそが座標系の変換にほかなりません。実際の例を見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code></code>
<code>            for (var i = 0 ; i &lt; 12 ; i++) {</code>
<code>                ctx.save();</code>
<code>                var r = Math.PI / 6 * i;</code>
<code>                ctx.translate(100, 100);</code>
<code>                ctx.rotate(r);</code>
<code></code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(0, -60);</code>
<code>                ctx.lineTo(0, -50);</code>
<code>                ctx.stroke();</code>
<code></code>
<code>                ctx.restore();</code>
<code>            }</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00081.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　このプログラムで肝となるのは以下の4つのメソッドです。</p>
<ol>
<li value="1">（1）ctx.save() ...... コンテキスト（座標系）を保存</li>
<li value="2">（2）ctx.translate(100, 100) ...... 座標系の原点をx方向に100、y方向に100移動</li>
<li value="3">（3）ctx.rotate(r) ...... 座標系をr回転</li>
<li value="4">（4）ctx.restore() ...... コンテキストを手順（1）で保存したものに復元</li>
</ol>
<p>　translate(100, 100)で原点を移動し、この状態で、(0, ‐60)→(0,‐50)へ</p>
<p>
<br />
</p>
<pre>
<code>ctx.moveTo(0, -60);</code>
<code>ctx.lineTo(0, -50);</code>
</pre>
<p>と線を引くと、下図の中央のように線が引かれます。さらに、これを原点に中心に回転させて同じように線を引くと右図のようになります。これを繰り返していくことで放射状に線を引くことができます。</p>
<figure>
<img src="images/00165.jpeg" />
<figcaption>原点に中心に回転させると放射状に線を引くことができる</figcaption>
</figure>
<p>　ほかの例も見てみましょう。</p>
<p>
<br />
</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;script&gt;</code>
<code>        var ctx;</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById("canvas");</code>
<code>            ctx = canvas.getContext("2d");</code>
<code>            ctx.fillStyle = "red";</code>
<code>            ctx.fillRect(10, 10, 80, 50);    //（1）</code>
<code></code>
<code>            ctx.save();</code>
<code>            ctx.translate(100, 0);</code>
<code>            ctx.scale(1.5, 0.5);</code>
<code>            ctx.fillStyle = "green";</code>
<code>            ctx.fillRect(10, 10, 80, 50);    //（2）</code>
<code>            ctx.restore();</code>
<code></code>
<code>            ctx.save();</code>
<code>            ctx.transform(0.8, -0.2, -0.3, 0.8, 250, 50);</code>
<code>            ctx.fillStyle = "blue";</code>
<code>            ctx.fillRect(10, 10, 80, 50);    //（3）</code>
<code>            ctx.restore();</code>
<code>        }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<figure>
<img src="images/00024.jpeg" />
<figcaption>ブラウザーでの表示</figcaption>
</figure>
<p>　3つの矩形を描画していますが、いずれも「ctx.fillRect(10, 10, 80, 50)」という同じ命令を実行しています（1）～（3）。しかしながら、座標系を変換しているために、このように描画結果が異なっています。</p>
<p>　ctx.scale(1.5, 0.5)は座標系をX軸方向に1.5倍、Y軸方向に0.5倍しています。その結果として描画される矩形が横方向に伸びています。</p>
<p>　なお、「ctx.transform(0.8, -0.2, -0.3, 0.8, 250, 50)」は、行列を使って座標系を変更していますが、少し内容が高度になるので詳細は省略します。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>実際にアナログ時計を作ってみましょう。まず、rotateをうまく使って文字盤だけ描画します。</p>
<p>ソース例</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                ctx = gobj("clock").getContext("2d");</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.clearRect(0, 0, 300, 300);</code>
<code></code>
<code>                ctx.save();</code>
<code>                ctx.translate(150, 150);</code>
<code>                ctx.strokeStyle = "black";</code>
<code>                var pitch = Math.PI * 2 / 60;</code>
<code>                for (var i = 0 ; i &lt; 60 ; i++) {</code>
<code>                    ctx.beginPath();</code>
<code>                    ctx.lineWidth = (i % 5) == 0 ? 3 : 1;</code>
<code>                    ctx.moveTo(0, -120);</code>
<code>                    ctx.lineTo(0, -140);</code>
<code>                    ctx.stroke();</code>
<code>                    ctx.rotate(pitch);</code>
<code>                }</code>
<code>                ctx.restore();</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="300" height="300" id="clock"&gt;&lt;/canvas&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<p>
<strong><b>【演習】</b></strong>次に短針、長針、秒針を描画します。描画はsetIntervalを使います。</p>
<figure>
<img src="images/00002.jpeg" />
<figcaption>ブラウザーでの表示（左がIE、右がChrome）</figcaption>
</figure>
<pre>
<code>var now = new Date()</code>
</pre>
<p>で現在時刻を取得できます。また、時はnow.getHours()で、分はnow.getMinutes()で、秒はnow.getSeconds()で取得できます。</p>
<p>ソース例</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>    &lt;head&gt;</code>
<code>        &lt;style&gt;</code>
<code>            #clock {</code>
<code>                width:300px;</code>
<code>                height:300px;</code>
<code>            }</code>
<code>        &lt;/style&gt;</code>
<code>        &lt;script&gt;</code>
<code>            var ctx, h, m, s;</code>
<code></code>
<code>            function gobj(id) { return document.getElementById(id); }</code>
<code></code>
<code>            function init() {</code>
<code>                ctx = gobj("clock").getContext("2d");</code>
<code>                setInterval(tick, 1000);</code>
<code>            }</code>
<code></code>
<code>            function tick() {</code>
<code>                var now = new Date();</code>
<code>                h = now.getHours() % 12;</code>
<code>                m = now.getMinutes();</code>
<code>                s = now.getSeconds();</code>
<code>                gobj("time").textContent = now.toTimeString();</code>
<code>                paint();</code>
<code>            }</code>
<code></code>
<code>            function drawHand(rotation, length, width, color) {</code>
<code>                ctx.save();</code>
<code>                ctx.lineWidth = width;</code>
<code>                ctx.strokeStyle = color;</code>
<code>                ctx.translate(150, 150);</code>
<code>                ctx.rotate(rotation);</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(0, 0);</code>
<code>                ctx.lineTo(0, -length);</code>
<code>                ctx.stroke();</code>
<code>                ctx.restore();</code>
<code>            }</code>
<code></code>
<code>            function paint() {</code>
<code>                ctx.clearRect(0, 0, 300, 300);</code>
<code></code>
<code>                ctx.save();</code>
<code>                ctx.translate(150, 150);</code>
<code>                ctx.strokeStyle = "black";</code>
<code>                var pitch = Math.PI * 2 / 60;</code>
<code>                for (var i = 0 ; i &lt; 60 ; i++) {</code>
<code>                    ctx.beginPath();</code>
<code>                    ctx.lineWidth = (i % 5) == 0 ? 3 : 1;</code>
<code>                    ctx.moveTo(0, -120);</code>
<code>                    ctx.lineTo(0, -140);</code>
<code>                    ctx.stroke();</code>
<code>                    ctx.rotate(pitch);</code>
<code>                }</code>
<code>                ctx.restore();</code>
<code></code>
<code>                var radH = (Math.PI * 2) / 12 * h + (Math.PI * 2) / 12 * (m / 60);</code>
<code>                var radM = (Math.PI * 2) / 60 * m;</code>
<code>                var radS = (Math.PI * 2) / 60 * s;</code>
<code></code>
<code>                drawHand(radH, 80, 6, "blue");</code>
<code>                drawHand(radM, 120, 4, "blue");</code>
<code>                drawHand(radS, 140, 2, "red");</code>
<code>            }</code>
<code>        &lt;/script&gt;</code>
<code>    &lt;/head&gt;</code>
<code>    &lt;body onload="init()"&gt;</code>
<code>        &lt;canvas width="300" height="300" id="clock"&gt;&lt;/canvas&gt;</code>
<code>        &lt;p id="time"&gt;&lt;/p&gt;</code>
<code>    &lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
<hr />
<p>　ここまで、Canvasでの描画機能や座標変換についてみてきました。基本的なゲームを実装するには十分な準備ができたと思います。それでは、実際のゲームのコードを読んでみることにしましょう！</p>
</section>
</div>
<div id="calibre_link-37">
<div>
<h1 id="calibre_link-172"><b>第5章　ゲームプログラミングに挑戦</b></h1>
<h2 id="calibre_link-284"><b>定番ゲーム、懐かしのゲームで楽しく学ぼう</b></h2>
</div>
<section>
<p><b>　第1章から第4章までの基礎知識をもとに、ゲームプログラミングに挑戦してみましょう。JavaScriptやCanvasなど、まだよくわからないことがあるかもしれませんが、習うより慣れろです。サンプルのソースコードはこれまでと比べてかなり長くなりますが、頑張って自分でタイプしてみましょう。タイプしていくうちに記述方法に慣れてきますし、タイプ後は設定をあれこれ変えて試してみると、少しづつ理解が深まっていくでしょう。</b></p>
</section>
</div>
<div id="calibre_link-96">
<section>
<hgroup>
<h1 id="calibre_link-173"><b>5-1　Canvasを使った基礎的なゲーム</b></h1>
</hgroup>
<p>　Canvasを使ったゲームとして、SnakeBite風のゲームを紹介しましょう。上下左右キーで蛇を操作し、餌を食べさせます。餌を食べるたびに体が伸びていきます。四方の壁にぶつかるか自分にぶつかるとゲームオーバーです。ただ、これだけのゲームですが、思いのほか夢中で遊んでしまうことでしょう。</p>
<figure>
<img src="images/00115.jpeg" />
<figcaption>蛇（***）を操作して餌（+）を食べさせると＊が増える</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-127">
<section>
<h2 id="calibre_link-285"><b>5-1-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。入力ミスがあると期待通りには動作しませんが、頑張ってデバッグしてください。動いたら思う存分遊んでみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;SnakeBite&lt;/title&gt;</code>
<code>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>        var W, H, S = 20;</code>
<code>        var snake = [], foods = [];</code>
<code>        var keyCode = 0;</code>
<code>        var point = 0;</code>
<code>        var timer = NaN;</code>
<code>        var ctx;</code>
<code></code>
<code>        // Pointオブジェクト</code>
<code>        function Point(x, y) {</code>
<code>            this.x = x;</code>
<code>            this.y = y;</code>
<code>        }</code>
<code></code>
<code>        // 初期化関数</code>
<code>        function init() {</code>
<code>            var canvas = document.getElementById('field');</code>
<code>            W = canvas.width / S;</code>
<code>            H = canvas.height / S;</code>
<code>            ctx = canvas.getContext('2d');</code>
<code>            ctx.font = "20px sans-serif";</code>
<code></code>
<code>            // 蛇の初期化</code>
<code>            snake.push(new Point(W / 2, H / 2));</code>
<code></code>
<code>            // 餌の初期化</code>
<code>            for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>                addFood();</code>
<code>            }</code>
<code></code>
<code>            timer = setInterval("tick()", 200);</code>
<code>            window.onkeydown = keydown;</code>
<code>        }</code>
<code></code>
<code>        // 餌の追加</code>
<code>        function addFood() {</code>
<code>            while (true) {</code>
<code>                var x = Math.floor(Math.random() * W);</code>
<code>                var y = Math.floor(Math.random() * H);</code>
<code></code>
<code>                if (isHit(foods, x, y) || isHit(snake, x, y)) {</code>
<code>                    continue;</code>
<code>                }</code>
<code></code>
<code>                foods.push(new Point(x, y));</code>
<code>                break;</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        // 衝突判定</code>
<code>        function isHit(data, x, y) {</code>
<code>            for (var i = 0 ; i &lt; data.length ; i++) {</code>
<code>                if (data[i].x == x &amp;&amp; data[i].y == y) {</code>
<code>                    return true;</code>
<code>                }</code>
<code>            }</code>
<code>            return false;</code>
<code>        }</code>
<code></code>
<code>        function moveFood(x, y) {</code>
<code>            foods = foods.filter(function (p) {</code>
<code>                return (p.x != x || p.y != y);</code>
<code>            });</code>
<code>            addFood();</code>
<code>        }</code>
<code></code>
<code>        function tick() {</code>
<code>            var x = snake[0].x;</code>
<code>            var y = snake[0].y;</code>
<code></code>
<code>            switch (keyCode) {</code>
<code>                case 37: x--; break; // 左</code>
<code>                case 38: y--; break; // 上</code>
<code>                case 39: x++; break; // 右</code>
<code>                case 40: y++; break; // 下</code>
<code>                default: paint(); return;</code>
<code>            }</code>
<code></code>
<code>            // 自分 or 壁に衝突？</code>
<code>            if (isHit(snake, x, y) || x &lt; 0 || x &gt;= W || y &lt; 0 || y &gt;= H) {</code>
<code>                clearInterval(timer);</code>
<code>                paint();</code>
<code>                return;</code>
<code>            }</code>
<code></code>
<code>            // 頭を先頭に追加</code>
<code>            snake.unshift(new Point(x, y));</code>
<code></code>
<code>            if (isHit(foods, x, y)) {</code>
<code>                point += 10;    // 餌を食べた</code>
<code>                moveFood(x, y);</code>
<code>            } else {</code>
<code>                snake.pop();    // 食べてない→しっぽを削除</code>
<code>            }</code>
<code></code>
<code>            paint();</code>
<code>        }</code>
<code></code>
<code>        function paint() {</code>
<code>            ctx.clearRect(0, 0, W * S, H * S);</code>
<code>            ctx.fillStyle = "rgb(256,0,0)";</code>
<code>            ctx.fillText(point, S, S * 2);</code>
<code>            ctx.fillStyle = "rgb(0,0,255)";</code>
<code></code>
<code>            foods.forEach(function (p) {</code>
<code>                ctx.fillText("+", p.x * S, (p.y + 1) * S);</code>
<code>            });</code>
<code>            snake.forEach(function (p) {</code>
<code>                ctx.fillText("*", p.x * S, (p.y + 1) * S);</code>
<code>            });</code>
<code>        }</code>
<code></code>
<code>        function keydown(event) {</code>
<code>            keyCode = event.keyCode;</code>
<code>        }</code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;canvas id="field" width="400" height="400" style="background:#cccccc"&gt;</code>
<code>&lt;/canvas&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-117">
<section>
<h2 id="calibre_link-286"><b>5-1-2　ゲームの構成</b></h2>
<p>　ゲームにはいろいろな種類がありますが、多くは以下のような実装となっています。</p>
<ol>
<li value="1">（1） ゲーム開始後の初期化を行う</li>
<li value="2">（2） キー入力を判定する</li>
<li value="3">（3） キー入力の処理、キャラクター移動等の処理を行う</li>
<li value="4">（4） 描画を更新する</li>
<li value="5">（5） ゲーム終了か判定し、終了でなければ手順（2）に戻る</li>
</ol>
<p>　手順（2）から（5）までループを構成していますが、これを「メインループ」と呼びます。JavaScriptの場合は、メインループをsetIntervalやsetTimeoutといったタイマーで実装するのが一般的です。</p>
<figure>
<img src="images/00120.jpeg" />
<figcaption>ゲームプログラムの流れ</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-44">
<section>
<h2 id="calibre_link-287"><b>5-1-3　変数、オブジェクト</b></h2>
<p>　本ゲームで使用している主な変数のイメージを以下に示します。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>snake</td>
  <td>蛇の座標を保持する配列、Point型オブジェクトを格納、先頭が0</td>
</tr>
<tr>
  <td>foods</td>
  <td>餌の座標を保持する配列、Point型オブジェクトを格納</td>
</tr>
<tr>
  <td>keyCode</td>
  <td>現在押されているキーのキーコード</td>
</tr>
<tr>
  <td>point</td>
  <td>現在獲得した得点</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00096.jpeg" />
<figcaption>このゲームで使用している主な変数</figcaption>
</figure>
<p>　このゲームで使用しているオブジェクトはPointだけです。単にxとyの座標を保持するだけのシンプルなものです。</p>
</section>
</div>
<div id="calibre_link-42">
<section>
<h2 id="calibre_link-288"><b>5-1-4　HTML</b></h2>
<p>　body要素以下は以下の通りです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;canvas id="field" width="400" height="400" style="background:#cccccc"&gt;</code>
<code>&lt;/canvas&gt;</code>
<code>&lt;/body&gt;</code>
</pre>
<p>　単に1つのcanvas要素を含んでいるだけです。</p>
<p>　また、「onload="init()"」とあるので文書を読み込んだときにinit()が実行されます。</p>
</section>
</div>
<div id="calibre_link-64">
<section>
<h2 id="calibre_link-289"><b>5-1-5　関数</b></h2>
<p>　このゲームで使用する主な関数を見ていきます。</p>
<p>初期化関数</p>
<pre>
<code>// 初期化関数</code>
<code>function init() {</code>
<code>    var canvas = document.getElementById('field');</code>
<code>    W = canvas.width / S;</code>
<code>    H = canvas.height / S;</code>
<code>    ctx = canvas.getContext('2d');</code>
<code>    ctx.font = "20px sans-serif";</code>
<code></code>
<code>    // 蛇の初期化</code>
<code>    snake.push(new Point(W / 2, H / 2));</code>
<code></code>
<code>    // 餌の初期化</code>
<code>    for (var i = 0 ; i &lt; 10 ; i++) {</code>
<code>        addFood();</code>
<code>    }</code>
<code></code>
<code>    timer = setInterval("tick()", 200);</code>
<code>    window.onkeydown = keydown;</code>
<code>}</code>
</pre>
<p>　canvas.widthとcanvas.heightは400、Sは20と宣言されているので、WとHはともに20となります。つまり、20×20のマスがゲームの領域となります。その後、canvasのコンテキストをグローバル変数ctxに格納しています。</p>
<p>　また、画面の中心座標「Point(W/2, H/2)」を蛇の頭として追加しています。</p>
<p>　餌はfor文で10個追加しています。実際の餌を追加する処理は関数addFood()で行っています。</p>
<p>　また、setIntervalで200msecごとにtick()を呼び出しています。</p>
<p>addFood()関数</p>
<pre>
<code>// 餌の追加</code>
<code>function addFood() {</code>
<code>    while (true) {</code>
<code>        var x = Math.floor(Math.random() * W);</code>
<code>        var y = Math.floor(Math.random() * H);</code>
<code></code>
<code>        if (isHit(foods, x, y) || isHit(snake, x, y)) {</code>
<code>            continue;</code>
<code>        }</code>
<code></code>
<code>        foods.push(new Point(x, y));</code>
<code>        break;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　addFood()は餌の追加を行う関数です。xとyの値は乱数で求めています。</p>
<p>　ただし、この場所がすでに餌がある場所、もしくは蛇の上だと困るので、その判定をisHit()を使って行っています。</p>
<p>　もし、ヒットした場合は、やり直す必要があるので、continue文を使ってwhile文の先頭に戻っています。ヒットしない場合は、配列foodsに餌を追加して関数を抜けます。</p>
<p>衝突判定</p>
<pre>
<code>// 衝突判定</code>
<code>function isHit(data, x, y) {</code>
<code>    for (var i = 0 ; i &lt; data.length ; i++) {</code>
<code>        if (data[i].x == x &amp;&amp; data[i].y == y) {</code>
<code>            return true;</code>
<code>        }</code>
<code>    }</code>
<code>    return false;</code>
<code>}</code>
</pre>
<p>　isHitは第1引数の配列dataの中に、x,yという座標を含むPointオブジェクトの有無を返します。dataの長さをlengthプロパティで取得し、その回数分for文を実行しています。JavaScriptで配列の各要素に処理を行う場合の典型的な方法です。</p>
<p>moveFood関数</p>
<pre>
<code>function moveFood(x, y) {</code>
<code>    foods = foods.filter(function (p) {</code>
<code>        return (p.x != x || p.y != y);</code>
<code>    });</code>
<code>    addFood();</code>
<code>}</code>
</pre>
<p>　蛇が餌を食べたときは、その餌を別の場所に動かさなくてはなりません。そのため、与えられたx,y座標以外のオブジェクトからなる配列をArrayのfilterメソッドを使って取得しています。</p>
<p>　少し詳しく説明しましょう。たとえば、もともとのfoodsはPointオブジェクトの配列ですが、</p>
<ol>
<li value="1">　　(2,3), (5,9), (12, 7), (15, 3), ... (9, 5)</li>
</ol>
<p>という場所を保持していたとします。そのときに引数x=12、y=7としてこの関数が呼び出されたとします。filterメソッドでは、各Pointオブジェクトの要素を引数pとしてコールバック関数が呼び出されます。コールバック関数でtrueを返すと、そのpは戻り値の配列に含まれます。falseを返すと、そのpが含まれなくなります。</p>
<figure>
<img src="images/00123.jpeg" />
<figcaption>コールバック関数</figcaption>
</figure>
<p>　コールバック関数では、xが違う、もしくはyが違うときにtrueを返しています。つまり、xもyも一致したときにfalseを返すことになります。これにより、引数x,yと同じ座標を持つ要素のみが削除されるように動作します。その結果を元の配列foodsに代入しています。</p>
<p>　最後に、削除した分の餌をaddFood()で追加することで、餌の移動を実現しています。</p>
<p>メインループ</p>
<pre>
<code>function tick() {</code>
<code>    var x = snake[0].x;</code>
<code>    var y = snake[0].y;</code>
<code></code>
<code>    switch (keyCode) {</code>
<code>        case 37: x--; break; // 左</code>
<code>        case 38: y--; break; // 上</code>
<code>        case 39: x++; break; // 右</code>
<code>        case 40: y++; break; // 下</code>
<code>        default: paint(); return;</code>
<code>    }</code>
<code></code>
<code>    // 自分 or 壁に衝突？</code>
<code>    if (isHit(snake, x, y) || x &lt; 0 || x &gt;= W || y &lt; 0 || y &gt;= H) {</code>
<code>        clearInterval(timer);</code>
<code>        paint();</code>
<code>        return;</code>
<code>    }</code>
<code></code>
<code>    // 頭を先頭に追加</code>
<code>    snake.unshift(new Point(x, y));</code>
<code></code>
<code>    if (isHit(foods, x, y)) {</code>
<code>        point += 10;    // 餌を食べた</code>
<code>        moveFood(x, y);</code>
<code>    } else {</code>
<code>        snake.pop();    // 食べてない→しっぽを削除</code>
<code>    }</code>
<code></code>
<code>    paint();</code>
<code>}</code>
</pre>
<p>　tick()はメインループでゲームの中心となる関数です。まず、蛇の頭の座標をxとyに格納しています。次にswitch文を使って、keyCodeに応じて次の頭の位置を求めます。この時点でxとyは次に来る蛇の頭の位置を格納しています。その値を使って、自分にぶつかっていないかをisHitで、もしくは壁にぶつかっていないかを判定しています。ぶつかっている場合は、clearInterval(timer)でタイマーを止めてゲーム終了です。</p>
<p>　それ以外の場合は、配列のunshiftメソッドを使って先頭に新しいPoint(x, y)オブジェクトを追加します。餌を食べていたときはpointを増やし、その位置の餌をmoveFood(x, y)で別の場所へ移動します。そうでないときはsnake.pop()で配列snakeの最後尾を削除しています。最後にpaint()を呼んで画面を再描画しています。</p>
<p>paint()関数</p>
<pre>
<code>function paint() {</code>
<code>    ctx.clearRect(0, 0, W * S, H * S);</code>
<code>    ctx.fillStyle = "rgb(256,0,0)";</code>
<code>    ctx.fillText(point, S, S * 2);</code>
<code>    ctx.fillStyle = "rgb(0,0,255)";</code>
<code></code>
<code>    foods.forEach(function (p) {</code>
<code>        ctx.fillText("+", p.x * S, (p.y + 1) * S);</code>
<code>    });</code>
<code>    snake.forEach(function (p) {</code>
<code>        ctx.fillText("*", p.x * S, (p.y + 1) * S);</code>
<code>    });</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-84">
<section>
<hgroup>
<h1 id="calibre_link-174"><b>5-2　横方向にスクロールするゲーム</b></h1>
</hgroup>
<p>　横方向にスクロールするゲームは沢山ありますが、そのような例を示したかったので簡単なものを作ってみました。使用するキーは1つだけです。押下している間は自機が上へ移動し、離すと落下していきます。洞窟の壁にぶつかるとゲームオーバーです。洞窟はどんどん狭くなっていきます。</p>
<figure>
<img src="images/00132.jpeg" />
<figcaption>洞窟の壁に当たらないように宇宙船を操作する</figcaption>
</figure>
<p>【使用している画像】</p>
<p>　本ゲームで使用している画像とその用途です。画像はどんな絵でもかまいません。Windowsに標準でついてくる「ペイント」で作ることもできますので、自分の好きな絵を作成して、世界で唯一のオリジナルゲームを作り上げてください。</p>
<figure>
<img src="images/00049.jpeg" />
<figcaption></figcaption>
</figure>
</section>
</div>
<div id="calibre_link-126">
<section>
<h2 id="calibre_link-290"><b>5-2-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Cave&lt;/title&gt;</code>
<code>    &lt;style&gt;</code>
<code>        #main {</code>
<code>            width: 800px;</code>
<code>            height: 600px;</code>
<code>            background-color: #00cc00;</code>
<code>            position: absolute;</code>
<code>            overflow: hidden;</code>
<code>        }</code>
<code>        #ship {</code>
<code>            top: 250px;</code>
<code>            left: 0px;</code>
<code>            width: 150px;</code>
<code>            height: 97px;</code>
<code>            position: absolute;</code>
<code>            z-index: 100;</code>
<code>        }</code>
<code>        #bang {</code>
<code>            width: 200px;</code>
<code>            height: 200px;</code>
<code>            position: absolute;</code>
<code>            z-index: 101;</code>
<code>            visibility: hidden;</code>
<code>        }</code>
<code>    &lt;/style&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var y = 250, v = 0, keyDown = false, WALLS = 80, score = 0;</code>
<code>    var walls = [], slope = 0, timer, ship, main;</code>
<code></code>
<code>    function init() {</code>
<code>        main = document.getElementById('main');</code>
<code>        ship = document.getElementById('ship');</code>
<code></code>
<code>        for (var i = 0 ; i &lt; WALLS ; i++) {</code>
<code>            walls[i] = document.createElement("div");</code>
<code>            walls[i].style.position = "absolute";</code>
<code>            walls[i].style.top = "100px";</code>
<code>            walls[i].style.left = i * 10 + "px";</code>
<code>            walls[i].style.width = "10px";</code>
<code>            walls[i].style.height = "400px";</code>
<code>            walls[i].style.backgroundColor = "#333333";</code>
<code>            main.appendChild(walls[i]);</code>
<code>        }</code>
<code></code>
<code>        slope = Math.floor(Math.random() * 5) + 1;</code>
<code>        timer = setInterval(mainloop, 50);</code>
<code>        window.addEventListener('keydown', function () { keyDown = true; });</code>
<code>        window.addEventListener('keyup', function () { keyDown = false; });</code>
<code>    }</code>
<code></code>
<code>    function hitTest(){</code>
<code>        var st = parseInt(ship.style.top) + 10;</code>
<code>        var sh = parseInt(ship.style.height);</code>
<code>        var sb = st + sh - 20;</code>
<code></code>
<code>        var wt = parseInt(walls[14].style.top);</code>
<code>        var wh = parseInt(walls[14].style.height);</code>
<code>        var wb = wh + wt;</code>
<code></code>
<code>        return (st &lt; wt) || (sb &gt; wb );</code>
<code>    }</code>
<code></code>
<code>    function mainloop() {</code>
<code>        if (hitTest()) {</code>
<code>            clearInterval(timer);</code>
<code>            document.getElementById('bang').style.top = (y - 40) + "px";</code>
<code>            document.getElementById('bang').style.visibility = "visible";</code>
<code>            return;</code>
<code>        }</code>
<code></code>
<code>        score += 10;</code>
<code>        document.getElementById('score').innerHTML = score.toString();</code>
<code></code>
<code>        v += keyDown ? -3 : 3;</code>
<code>        y += v;</code>
<code>        ship.style.top = y + 'px';</code>
<code></code>
<code>        var edge = walls[WALLS - 1].style;</code>
<code>        var t = parseInt(edge.top);</code>
<code>        var h = parseInt(edge.height);</code>
<code>        var b = h + t;</code>
<code>        t += slope;</code>
<code>        b += slope;</code>
<code>        if ((t &lt; 0) &amp;&amp; (slope &lt; 0) || (b &gt; 600) &amp;&amp; (slope &gt; 0)) {</code>
<code>            slope = (Math.floor(Math.random() * 5) + 1) * (slope &lt; 0 ? 1 : -1);</code>
<code>            edge.top = (t + 10) + "px";</code>
<code>            edge.height = (h - 20) + "px";</code>
<code>        } else {</code>
<code>            edge.top = t + "px";</code>
<code>        }</code>
<code></code>
<code>        for (var i = 0 ; i &lt; WALLS - 1 ; i++) {</code>
<code>            walls[i].style.top = walls[i + 1].style.top;</code>
<code>            walls[i].style.height = walls[i + 1].style.height;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;h1&gt;Score:&lt;span id="score"&gt;&lt;/span&gt;&lt;/h1&gt;</code>
<code>&lt;div id="main"&gt;</code>
<code>    &lt;img id="ship" src="ship.png" style="height:97px;"/&gt;</code>
<code>    &lt;img id="bang" src="bang.png"/&gt;</code>
<code>&lt;/div&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-38">
<section>
<h2 id="calibre_link-291"><b>5-2-2　変数</b></h2>
<p>　使用している主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>y</td>
  <td>自機のY座標</td>
</tr>
<tr>
  <td>v</td>
  <td>自機の加速度</td>
</tr>
<tr>
  <td>keyDown</td>
  <td>キー押下中か否かを示すフラグ</td>
</tr>
<tr>
  <td>score</td>
  <td>現在のスコア</td>
</tr>
<tr>
  <td>walls</td>
  <td>洞窟の通り道をDOMで表現しているが、そのDOM要素を格納する配列</td>
</tr>
<tr>
  <td>slope</td>
  <td>勾配の度合いを示す変数</td>
</tr>
<tr>
  <td>timer</td>
  <td>メインループ実行用のタイマー</td>
</tr>
<tr>
  <td>ship</td>
  <td>自機のDOMオブジェクト</td>
</tr>
<tr>
  <td>main</td>
  <td>洞窟の通り道の親要素となるDOMオブジェクト</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　これらの変数が使用されている様子を以下の図に示します。</p>
<figure>
<img src="images/00173.jpeg" />
<figcaption>主な変数</figcaption>
</figure>
<p>　特に難しいところはないと思いますが、洞窟に見えるところが実は80個からなるDOMで構成されているのがポイントです。</p>
</section>
</div>
<div id="calibre_link-101">
<section>
<h2 id="calibre_link-292"><b>5-2-3　速度と加速度</b></h2>
<p>　今回のゲームでは自機は何もしないと落下し、キーを押すと上昇します。その変化に加速度を使うことで多少ゲームらしくしています。つまり押し続けるほど、上昇スピードがあがり、落下時には時間が経つほど落下分が大きくなるので操作が難しくなっています。</p>
<p>　速度は一定時間に進む距離で、加速度は速度の変化する度合いです。これらはまったく別のものなのですが、混乱する人も多いと思われるので簡単に説明しておきます。</p>
<p>　下の図をご覧ください。上段は10m/s（毎秒10メートル）の一定速度で進む飛行機です。速度は一定なので加速度は0です。一方下段は加速度がある場合です。</p>
<figure>
<img src="images/00146.jpeg" />
<figcaption>一定速度で進む場合と加速度がある場合</figcaption>
</figure>
<p>　最初は10m/sで進んでいますが、徐々に速度が増えています。速度の変化する割合が加速度です。1秒間に10m/s増えているとすれば、そのときの加速度は10m/s÷1秒＝10m/s<sup>2</sup>となります。</p>
<p>　xをx座標の値、vを速度とした場合、ゲームでこれらを表現すると、</p>
<ul>
<li>加速度がない場合：x += v;</li>
<li>加速度がある場合：v += 10;　x += v;</li>
</ul>
<p>のようになります。つまり、加速度を考慮する場合は、まず速度を変化させ、その速度を距離に反映させる必要があります。この点を意識しながらソースコードをご覧ください。</p>
</section>
</div>
<div id="calibre_link-184">
<section>
<h2 id="calibre_link-293"><b>5-2-4　関数</b></h2>
<h3 id="calibre_link-294">■init()関数</h3>
<p>　init()は文書読み込み時に実行される関数です。</p>
<p>init()関数</p>
<pre>
<code>function init() {</code>
<code>    main = document.getElementById('main');</code>
<code>    ship = document.getElementById('ship');</code>
<code></code>
<code>    for (var i = 0 ; i &lt; WALLS ; i++) {</code>
<code>        walls[i] = document.createElement("div");</code>
<code>        walls[i].style.position = "absolute";</code>
<code>        walls[i].style.top = "100px";</code>
<code>        walls[i].style.left = i * 10 + "px";</code>
<code>        walls[i].style.width = "10px";</code>
<code>        walls[i].style.height = "400px";</code>
<code>        walls[i].style.backgroundColor = "#333333";</code>
<code>        main.appendChild(walls[i]);</code>
<code>    }</code>
<code></code>
<code>    slope = Math.floor(Math.random() * 5) + 1;</code>
<code>    timer = setInterval(mainloop, 50);</code>
<code>    window.addEventListener('keydown', function () { keyDown = true; });</code>
<code>    window.addEventListener('keyup', function () { keyDown = false; });</code>
<code>}</code>
</pre>
<p>　mainはゲーム領域のdivです。この子要素として洞窟となるdivを追加していきます。一見するとわかりにくいかもしれませんが、この洞窟は80個からなるdivで構成されています。それを動的に構築しているのが上記のfor文です。positionに"absolute"を指定し、top、left、width、heightを指定しています。</p>
<p>　slopeは洞窟の勾配を保持する変数です。隣のdivとのy座標の差分を乱数で求めています。</p>
<p>あとは、「keydown」と「keyup」のイベントハンドラーを登録しています。</p>
<h3 id="calibre_link-295">■hitTest()関数</h3>
<p>　hitTest()は自機が壁に衝突しているか、洞窟の範囲に収まっているかを調べる関数です。</p>
<p>hitTest()関数</p>
<pre>
<code>function hitTest(){</code>
<code>    var st = parseInt(ship.style.top) + 10;</code>
<code>    var sh = parseInt(ship.style.height);</code>
<code>    var sb = st + sh - 20;</code>
<code></code>
<code>    var wt = parseInt(walls[14].style.top);</code>
<code>    var wh = parseInt(walls[14].style.height);</code>
<code>    var wb = wh + wt;</code>
<code></code>
<code>    return (st &lt; wt) || (sb &gt; wb );</code>
<code>}</code>
</pre>
<p>　以下の図を見るとわかりやすいでしょう。</p>
<p>　壁と自機のtopとheightからそれぞれの範囲を求めています。自機の上端stが洞窟の上端wtより小さい場合、もしくは、自機の下端sbが洞窟の下端wbより大きい場合は衝突と判断しています。</p>
<figure>
<img src="images/00034.jpeg" />
<figcaption>自機の上端stが洞窟の上端wtより小さいか、自機の下端sbが洞窟の下端wbより大きい場合は衝突</figcaption>
</figure>
<h3 id="calibre_link-296">■メインループ</h3>
<p>　mainloop()がメインループです。</p>
<p>mainloop()関数</p>
<pre>
<code>function mainloop() {</code>
<code>    if (hitTest()) {</code>
<code>        clearInterval(timer);</code>
<code>        document.getElementById('bang').style.top = (y - 40) + "px";</code>
<code>        document.getElementById('bang').style.visibility = "visible";</code>
<code>        return;</code>
<code>    }</code>
<code></code>
<code>    score += 10;</code>
<code>    document.getElementById('score').innerHTML = score.toString();</code>
<code></code>
<code>    v += keyDown ? -3 : 3;    //（1）</code>
<code>    y += v;</code>
<code>    ship.style.top = y + 'px';</code>
<code></code>
<code>    var edge = walls[WALLS - 1].style;</code>
<code>    var t = parseInt(edge.top);</code>
<code>    var h = parseInt(edge.height);</code>
<code>    var b = h + t;</code>
<code>    t += slope;</code>
<code>    if ((t &lt; 0) &amp;&amp; (slope &lt; 0) || (b &gt; 600) &amp;&amp; (slope &gt; 0)) {</code>
<code>        slope = (Math.floor(Math.random() * 5) + 1) * (slope &lt; 0 ? 1 : -1);</code>
<code>        edge.top = (t + 10) + "px";</code>
<code>        edge.height = (h - 20) + "px";</code>
<code>    } else {</code>
<code>        edge.top = t + "px";</code>
<code>    }</code>
<code></code>
<code>    for (var i = 0 ; i &lt; WALLS - 1 ; i++) {</code>
<code>        walls[i].style.top = walls[i + 1].style.top;</code>
<code>        walls[i].style.height = walls[i + 1].style.height;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　衝突している場合、すなわちhitTest()が真の場合は、タイマーを止めて爆発状態の画像を表示します。そのあとスコアを加算して表示に反映しています。</p>
<p>　（1）の「v += keyDown ? -3 : 3;」が速度を更新している箇所、すなわち加速度の処理です。キー押下時にvを3減らし、押していないときに3増加させています。更新された速度を距離に反映しているのが「y += v」の部分です。</p>
<p>　次に、勾配が上端か下端に到達したか判定しています。edgeは一番右端の洞窟です。そのtopとheightから上端と下端を求めています。衝突判定は</p>
<p>
<br />
</p>
<pre>
<code>if ((t &lt; 0) &amp;&amp; (slope &lt; 0) || (b &gt; 600) &amp;&amp; (slope &gt; 0))</code>
</pre>
<p>で行っています。以下の図はslopeが正の場合（下り勾配）の様子です。if文の条件式と見比べてみてください。</p>
<figure>
<img src="images/00075.jpeg" />
<figcaption>slopeが正の場合（下り勾配）</figcaption>
</figure>
<p>　衝突した場合は、slopeを更新し、topとheightの値を更新して、洞窟の幅を狭めています。</p>
<p>　以下に示す最後の部分で横スクロールを実現しています。</p>
<p>
<br />
</p>
<pre>
<code>for (var i = 0 ; i &lt; WALLS - 1 ; i++) {</code>
<code>    walls[i].style.top = walls[i + 1].style.top;</code>
<code>    walls[i].style.height = walls[i + 1].style.height;</code>
<code>}</code>
</pre>
<p>　洞窟を構成する壁を順番に左へコピーしているだけです。これを全部の壁に適用することで、1コマ画面が左に移動するように見えます。</p>
<figure>
<img src="images/00074.jpeg" />
<figcaption>横スクロール</figcaption>
</figure>
<p>　プログラムの解説は以上です。シンプルなゲームではありますが、スクロール系のゲームの基本的な要素が含まれています。今回はDOMを主に作ってみましたが、Canvasで実装する場合も、基本的には同じ考え方で実装することができるでしょう。</p>
</section>
</div>
<div id="calibre_link-93">
<section>
<hgroup>
<h1 id="calibre_link-175"><b>5-3　DOMを使ったパズルゲーム</b></h1>
</hgroup>
<p>　リアルタイムのゲームが主流ですが、パズルなどリアルタイム処理を必要としないゲームもたくさん存在します。</p>
<p>　パズルゲームには格子状のレイアウトを用いるものが少なくありません。今回はその一例としてマインスイーパー風の爆弾除去ゲームを作ってみました。DOMからTable要素を作ることで格子状のタイルを実装しています。</p>
<p>　リアルタイム系のゲームではないのでメインループはありません。JavaScriptからDOMを操作する例としてご覧ください。</p>
<figure>
<img src="images/00000.jpeg" />
<figcaption>数字は隣接する地雷の数。地雷（+）を開くとゲームオーバー</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-33">
<section>
<h2 id="calibre_link-297"><b>5-3-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。また、「//cell[x][y]. textContent = "*";」のコメントを外して実行してみてください。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Mine Land&lt;/title&gt;</code>
<code>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;</code>
<code>    &lt;style type="text/css"&gt;</code>
<code>        td.cell {width:20px;height:20px; background-color:Gray;}</code>
<code>        td.open {background-color: White;}</code>
<code>    &lt;/style&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var W = 10, H = 10, BOMB = 10, cell = [], opened = 0;</code>
<code></code>
<code>    function init() {</code>
<code>        var main = document.getElementById("main");</code>
<code></code>
<code>        for (var i = 0; i &lt; H; i++) {</code>
<code>            cell[i] = [];</code>
<code>            var tr = document.createElement("tr");</code>
<code>            for (var j = 0; j &lt; W; j++) {</code>
<code>                var td = document.createElement("td");</code>
<code>                td.addEventListener("click", click);</code>
<code>                td.className = "cell";</code>
<code>                td.y = i;</code>
<code>                td.x = j;</code>
<code>                cell[i][j] = td;</code>
<code>                tr.appendChild(td);</code>
<code>            }</code>
<code>            main.appendChild(tr);</code>
<code>        }</code>
<code></code>
<code>        for (var i = 0; i &lt; BOMB; i++) {</code>
<code>            while (true) {</code>
<code>                var x = Math.floor(Math.random() * W);</code>
<code>                var y = Math.floor(Math.random() * H);</code>
<code>                if (!cell[x][y].bomb) {</code>
<code>                    cell[x][y].bomb = true;</code>
<code>                    //cell[x][y].textContent = "*";</code>
<code>                    break;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function count(x, y) {</code>
<code>        var b = 0;</code>
<code>        for (var j = y - 1; j &lt;= y + 1; j++) {</code>
<code>            for (var i = x - 1; i &lt;= x + 1; i++) {</code>
<code>                if (cell[j] &amp;&amp; cell[j][i]) {</code>
<code>                    if (cell[j][i].bomb) b++;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>        return b;</code>
<code>    }</code>
<code></code>
<code>    function open(x, y) {</code>
<code>        for (var j = y - 1; j &lt;= y + 1; j++) {</code>
<code>            for (var i = x - 1; i &lt;= x + 1; i++) {</code>
<code>                if (cell[j] &amp;&amp; cell[j][i]) {</code>
<code>                    var c = cell[j][i];</code>
<code>                    if (c.opened || c.bomb) {</code>
<code>                        continue;</code>
<code>                    }</code>
<code>                    flip(c);</code>
<code>                    var n = count(i, j);</code>
<code>                    if (n == 0) {</code>
<code>                        open(i, j);</code>
<code>                    } else {</code>
<code>                        c.textContent = n;</code>
<code>                    }</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function flip(cell) {</code>
<code>        cell.className = "cell open";</code>
<code>        cell.opened = true;</code>
<code>        if (++opened &gt;= (W * H - BOMB)) {</code>
<code>            document.getElementById("title").textContent = "Good Job!";</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function click(e) {</code>
<code>        var src = e.currentTarget;</code>
<code>        if (src.bomb) {</code>
<code>            cell.forEach(function (tr) {</code>
<code>                tr.forEach(function (td) {</code>
<code>                    if (td.bomb) {</code>
<code>                        td.textContent = "+";</code>
<code>                    }</code>
<code>                })</code>
<code>            });</code>
<code>            document.getElementById("title").textContent = "Game Over";</code>
<code>        } else {</code>
<code>            open(src.x, src.y);</code>
<code>        }</code>
<code>    }</code>
<code>&lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;h1 id="title"&gt;Mine Land&lt;/h1&gt;</code>
<code>&lt;table id="main" border="1"&gt;&lt;/table&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-85">
<section>
<h2 id="calibre_link-298"><b>5-3-2　変数</b></h2>
<p>　変数は以下の1行です。</p>
<p>
<br />
</p>
<pre>
<code>var W = 10, H = 10, BOMB = 10, cell = [], opened = 0;</code>
</pre>
<p>　Wは幅、Hは高さ、BOMBは爆弾の数、cellはタイルを管理する2次元配列、openedはオープンしたタイルの数です。cellの2次元配列は以下の図のようになっています。</p>
<figure>
<img src="images/00112.jpeg" />
<figcaption>cellの2次元配列</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-91">
<section>
<h2 id="calibre_link-299"><b>5-3-3　HTML</b></h2>
<p>　body要素以下は以下の通りです。</p>
<p>
<br />
</p>
<pre>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;h1 id="title"&gt;Mine Land&lt;/h1&gt;</code>
<code>&lt;table id="main" border="1"&gt;&lt;/table&gt;</code>
<code>&lt;/body&gt;</code>
</pre>
<p>　単にh1とtableを含んでいるだけです。bodyに、「onload="init()"」とあるので文書を読み込んだときにinit()が実行されます。</p>
</section>
</div>
<div id="calibre_link-49">
<section>
<h2 id="calibre_link-300"><b>5-3-4　関数</b></h2>
<p>　このゲームで使用する主な関数を見ていきます。</p>
<h3 id="calibre_link-301">■init()関数</h3>
<p>　init()関数では、まずmainというIDを持つtable要素への参照を取得します。その後、最初のfor文で、tr要素とtd要素をcreateElementで動的に作成して、行と列を作っています。</p>
<p>init()関数</p>
<pre>
<code>function init() {</code>
<code>    var main = document.getElementById("main");</code>
<code></code>
<code>    for (var i = 0; i &lt; H; i++) {</code>
<code>        cell[i] = [];</code>
<code>        var tr = document.createElement("tr");</code>
<code>        for (var j = 0; j &lt; W; j++) {</code>
<code>            var td = document.createElement("td");</code>
<code>            td.addEventListener("click", click);</code>
<code>            td.className = "cell";</code>
<code>            td.y = i;</code>
<code>            td.x = j;</code>
<code>            cell[i][j] = td;</code>
<code>            tr.appendChild(td);</code>
<code>        }</code>
<code>        main.appendChild(tr);</code>
<code>    }</code>
<code></code>
<code>    for (var i = 0; i &lt; BOMB; i++) {</code>
<code>        while (true) {</code>
<code>            var x = Math.floor(Math.random() * W);</code>
<code>            var y = Math.floor(Math.random() * H);</code>
<code>            if (!cell[x][y].bomb) {</code>
<code>                cell[x][y].bomb = true;</code>
<code>                // cell[x][y].textContent = "*";</code>
<code>                break;</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　各マス目がtd要素で実装されていますが、以下のようにプロパティを指定しています。</p>
<p>
<br />
</p>
<pre>
<code>td.addEventListener("click", click);  // クリック時にclickを実行するようハンドラーを登録</code>
<code>td.className = "cell";// td.cell {width...というスタイルを適用するようclass属性を指定</code>
<code>td.y = i; // どこがクリックされたか判定用にyというプロパティを追加</code>
<code>td.x = j; // どこがクリックされたか判定用にxというプロパティを追加</code>
</pre>
<p>　後半のfor文では、cellに爆弾を配置しています。同じ場所に爆弾を配置しないようにしていることに注目してください。</p>
<h3 id="calibre_link-302">■count関数</h3>
<p>　count(x, y)は、その座標の周囲にいくつの爆弾があるか、その個数を返す関数です。</p>
<p>count関数</p>
<pre>
<code>function count(x, y) {</code>
<code>    var b = 0;</code>
<code>    for (var j = y - 1; j &lt;= y + 1; j++) {</code>
<code>        for (var i = x - 1; i &lt;= x + 1; i++) {</code>
<code>            if (cell[j] &amp;&amp; cell[j][i]) {</code>
<code>                if (cell[j][i].bomb) b++;</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    return b;</code>
<code>}</code>
</pre>
<p>　処理内容は以下の図を参考にしてください。「if (cell[j] &amp;&amp; cell[j][i])」は、iとjがマス目の外になった場合、たとえば、jが-1のような場合に、爆弾を数えないようにするための処理です。</p>
<figure>
<img src="images/00073.jpeg" />
<figcaption>count(x, y)の処理</figcaption>
</figure>
<h3 id="calibre_link-303">■open関数</h3>
<p>　open(x, y)は、x, yの場所のマスを開く処理を行います。</p>
<p>open関数</p>
<pre>
<code>function open(x, y) {</code>
<code>    for (var j = y - 1; j &lt;= y + 1; j++) {</code>
<code>        for (var i = x - 1; i &lt;= x + 1; i++) {</code>
<code>            if (cell[j] &amp;&amp; cell[j][i]) {</code>
<code>                var c = cell[j][i];</code>
<code>                if (c.opened || c.bomb) {</code>
<code>                    continue;</code>
<code>                }</code>
<code>                flip(c);</code>
<code>                var n = count(i, j);</code>
<code>                if (n == 0) {</code>
<code>                    open(i, j);</code>
<code>                } else {</code>
<code>                    c.textContent = n;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　すでに開かれている場合、もしくは爆弾があるセルだった場合、すなわち「(c.opened || c.bomb)」が真になった場合には、何もせずにcontinue文で処理を継続します。それ以外の場合は、flip関数でそのマスを開きます。そして、その座標の周囲にある爆弾の数をcount(i, j)関数で調べ、その数が0だったときには、その座標を中心に同じopen関数を呼び出します。0以外のときは、その数値を表示します。このようにすることで、爆弾のない範囲をオープンしていくように動作します。</p>
<h3 id="calibre_link-304">■flip関数</h3>
<p>　flip(cell)はそのマス目を開く処理を行います。</p>
<p>flip関数</p>
<pre>
<code>function flip(cell) {</code>
<code>    cell.className = "cell open";</code>
<code>    cell.opened = true;</code>
<code>    if (++opened &gt;= (W * H - BOMB)) {</code>
<code>        document.getElementById("title").textContent = "Good Job!";</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　className属性に「"cell open"」を代入することで、「td.cell {...}」と「td.open {...}」の両方のスタイルを適用しています。また、開いた数が爆弾を除いた数に到達したとき、すなわちすべてのマスをオープンできたときに「Good Job!」と表示しています。</p>
<p>
<br />
</p>
<h3 id="calibre_link-305">■click(e)関数</h3>
<p>　最後はclick(e)関数です。init()で各セルに登録していたイベントハンドラーです。</p>
<p>click(e)関数</p>
<pre>
<code>function click(e) {</code>
<code>    var src = e.srcElement;</code>
<code>    if (src.bomb) {</code>
<code>        cell.forEach(function (tr) {</code>
<code>            tr.forEach(function (td) {</code>
<code>                if (td.bomb) {</code>
<code>                    td.textContent = "+";</code>
<code>                }</code>
<code>            })</code>
<code>        });</code>
<code>        document.getElementById("title").textContent = "Game Over";</code>
<code>    } else {</code>
<code>        open(src.x, src.y);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　もし、その位置に爆弾があった場合、すなわちsrc.bombが真の場合、すべてのセルをチェックして、そこに爆弾がある場合に「+」を表示し、タイトルを「Game Over」に変更しています。それ以外の場合は、その座標のx,y座標を引数としてopen()を呼び出しています。</p>
<p>　プログラムの解説は以上です。なお、マインスイーパーは、Windows 8ではストアからインストールすることができます。それらのゲームをインストールして、どのように動いているのか想像しながら遊んでみると、より一層楽しめるかもしれません。</p>
<hr />
<p>
<strong><b>【演習】</b></strong>W、H、BOMBといった初期値を変更して、どのように挙動が変わるか確認してみてください。</p>
<hr />
</section>
</div>
<div id="calibre_link-190">
<section>
<hgroup>
<h1 id="calibre_link-176"><b>5-4　ボールの反射を応用したゲーム</b></h1>
</hgroup>
<p>　パドルを左右に移動させてブロックを崩していくゲームは、1976年アタリによるオリジナルの「ブレイクアウト」が原点とも言われています。その後さまざまな亜流ゲームが出現しましたが、ここでは、このゲームの一番基本的な部分をどのように実装できるかを見てみましょう。入射角、反射角に合わせてオブジェクトを移動させる、衝突判定を行う、といった処理が参考になるでしょう。</p>
<figure>
<img src="images/00148.jpeg" />
<figcaption>スペースキーでボールを発射、左右の矢印キーでパドルをボールに当てる</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-102">
<section>
<h2 id="calibre_link-306"><b>5-4-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Blocks&lt;/title&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var ctx, paddle, ball, timer, blocks = [];</code>
<code>    var balls = 3, score = 0, WIDTH = 600, HEIGHT = 600;</code>
<code>    var colors = ['red','orange','yellow','green','purple','blue'];</code>
<code></code>
<code>    function Ball() {</code>
<code>        this.x = 0;</code>
<code>        this.y = HEIGHT + this.r;    // out of the area</code>
<code>        this.dx = 0;</code>
<code>        this.dy = 0;</code>
<code>        this.r = 10;</code>
<code>        this.dir = 0;</code>
<code>        this.speed = 10;</code>
<code></code>
<code>        this.move = function () {</code>
<code>            this.x += this.dx;</code>
<code>            this.y += this.dy;</code>
<code>        }</code>
<code></code>
<code>        this.changeDir = function (dir) {</code>
<code>            this.dir = dir;</code>
<code>            this.dx = this.speed * Math.cos(dir);</code>
<code>            this.dy = - this.speed * Math.sin(dir);</code>
<code>        }</code>
<code></code>
<code>        this.draw = function (ctx) {</code>
<code>            drawBall(this.x, this.y, this.r);</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    Block.prototype = Paddle.prototype = {</code>
<code>        draw: function (ctx) {</code>
<code>            ctx.fillStyle = this.color;</code>
<code>            ctx.fillRect(this.x, this.y, this.w, this.h);</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function Block(x, y, i) {</code>
<code>        this.x = x;</code>
<code>        this.y = y;</code>
<code>        this.w = 50;</code>
<code>        this.h = 20;</code>
<code>        this.color = colors[i];</code>
<code>        this.point = (6 - i) * 10;</code>
<code>    }</code>
<code></code>
<code>    function Paddle() {</code>
<code>        this.w = 110;</code>
<code>        this.h = 20;</code>
<code>        this.x = (WIDTH - this.w) / 2;</code>
<code>        this.y = HEIGHT - 20;</code>
<code>        this.color = 'yellow'</code>
<code>        this.keyL = false;</code>
<code>        this.keyR = false;</code>
<code>    }</code>
<code></code>
<code>    function init() {</code>
<code>        ctx = document.getElementById('canvas').getContext('2d');</code>
<code>        ctx.font = "20pt Arial";</code>
<code></code>
<code>        // initialize event listener</code>
<code>        window.addEventListener('keydown', function (e) {</code>
<code>            toggleKey(e.keyCode, true);</code>
<code>        }, true);</code>
<code>        window.addEventListener('keyup', function (e) {</code>
<code>            toggleKey(e.keyCode, false);</code>
<code>        }, true);</code>
<code></code>
<code>        // initialize players</code>
<code>        paddle = new Paddle();</code>
<code>        ball = new Ball();</code>
<code>        start();</code>
<code></code>
<code>        if (isNaN(timer)) {</code>
<code>            timer = setInterval(mainLoop, 15);</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function toggleKey(code, flag) {</code>
<code>        switch (code) {</code>
<code>            case 37: paddle.keyL = flag; break;</code>
<code>            case 39: paddle.keyR = flag; break;</code>
<code>            case 32:</code>
<code>                if (!isPlaying()) {</code>
<code>                    ball.x = paddle.x + paddle.w / 2;</code>
<code>                    ball.y = paddle.y - ball.r;</code>
<code>                    ball.changeDir(Math.random() * Math.PI / 2 + Math.PI / 4);  // 45 - 135</code>
<code>                }</code>
<code>                break;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function start() {</code>
<code>        paddle.w = Math.max(20, paddle.w - 10);</code>
<code>        ball.speed = Math.min(20, ball.speed + 1);</code>
<code></code>
<code>        // layout blocks</code>
<code>        for (var i = 0 ; i &lt; 6 ; i++) {</code>
<code>            for (var j = 0 ; j &lt; 9 ; j++) {</code>
<code>                blocks.push(new Block(j * 60 + 35, i * 30 + 50, i));</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function mainLoop() {</code>
<code>        // move the paddle</code>
<code>        if (paddle.keyL) {</code>
<code>            paddle.x = Math.max(0, paddle.x - 10)</code>
<code>        }</code>
<code>        if (paddle.keyR) {</code>
<code>            paddle.x = Math.min(WIDTH - paddle.w, paddle.x + 10)</code>
<code>        }</code>
<code></code>
<code>        draw();</code>
<code></code>
<code>        if (!isPlaying()) {</code>
<code>            return;</code>
<code>        }</code>
<code></code>
<code>        if (ball.y &gt; HEIGHT - paddle.h) {</code>
<code>            // hit the paddle?</code>
<code>            if (paddle.x &lt; ball.x &amp;&amp; ball.x &lt; paddle.x + paddle.w &amp;&amp;</code>
<code>                paddle.y &lt; ball.y &amp;&amp; ball.y &lt; paddle.y + paddle.h) {</code>
<code>                var ratio = (paddle.x + paddle.w / 2 - ball.x) / paddle.w * 0.8;  // -0.4 to 0.4</code>
<code>                ball.changeDir(Math.PI / 2 + Math.PI * ratio);</code>
<code>            }</code>
<code>            else {</code>
<code>                if (--balls == 0) {   // game over</code>
<code>                    clearInterval(timer);</code>
<code>                    timer = NaN;</code>
<code>                    draw();</code>
<code>                    return;</code>
<code>                }</code>
<code>                ball.y = HEIGHT + ball.r;</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        var nx = ball.x + ball.dx;</code>
<code>        var ny = ball.y - ball.dy;</code>
<code></code>
<code>        // hit the wall?</code>
<code>        if (ny &lt; ball.r &amp;&amp; ball.dy &lt; 0) {</code>
<code>            ball.changeDir(ball.dir * -1);</code>
<code>        }</code>
<code>        else if (nx &lt; ball.r || nx + ball.r &gt; WIDTH) {</code>
<code>            ball.changeDir(Math.PI - ball.dir);</code>
<code>        }</code>
<code></code>
<code>        // hit a block?</code>
<code>        var hit = -1;</code>
<code>        blocks.some(function (block, i) {</code>
<code>            if (block.x - ball.r &lt; nx &amp;&amp; nx &lt; block.x + block.w + ball.r &amp;&amp;</code>
<code>                block.y - ball.r &lt; ny &amp;&amp; ny &lt; block.y + block.h + ball.r) {</code>
<code>                hit = i;</code>
<code>                return true;</code>
<code>            }</code>
<code>            return false;</code>
<code>        });</code>
<code></code>
<code>        if (hit &gt;= 0) {</code>
<code>            score += blocks[hit].point;</code>
<code>            blocks.splice(hit, 1);</code>
<code></code>
<code>            if (blocks.length &lt;= 0) { // cleared</code>
<code>                ball.y = HEIGHT + ball.r;</code>
<code>                start();</code>
<code>                return;</code>
<code>            }</code>
<code>            ball.changeDir(ball.dir * -1);</code>
<code>        }</code>
<code></code>
<code>        ball.move();</code>
<code>    }</code>
<code></code>
<code>    function isPlaying() {</code>
<code>        return ball.y &lt; HEIGHT + ball.r;</code>
<code>    }</code>
<code></code>
<code>    function drawBall(x, y, r) {</code>
<code>        ctx.fillStyle = 'yellow';</code>
<code>        ctx.beginPath();</code>
<code>        ctx.arc(x, y, r, 0, Math.PI * 2, true);</code>
<code>        ctx.fill();</code>
<code>    }</code>
<code></code>
<code>    function draw() {</code>
<code>        // fill background</code>
<code>        ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>        ctx.fillRect(0, 0, WIDTH, HEIGHT);</code>
<code></code>
<code>        // draw blocks</code>
<code>        blocks.forEach(function (block) {</code>
<code>            block.draw(ctx);</code>
<code>        });</code>
<code></code>
<code>        // draw paddle</code>
<code>        paddle.draw(ctx);</code>
<code></code>
<code>        // draw balls</code>
<code>        ball.draw(ctx);</code>
<code>        if (balls &gt; 2) { drawBall(80, 15, 10); }</code>
<code>        if (balls &gt; 1) { drawBall(50, 15, 10); }</code>
<code></code>
<code>        // draw score &amp; information</code>
<code>        ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>        ctx.fillText(('00000' + score).slice(-5), 500, 30);</code>
<code>        if (isNaN(timer)) {</code>
<code>            ctx.fillText('GAME OVER', 220, 250);</code>
<code>        }</code>
<code>    }</code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;canvas id="canvas" width="600" height="600"/&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-63">
<section>
<h2 id="calibre_link-307"><b>5-4-2　三角関数</b></h2>
<p>　このゲームではボールの反射角からx, y座標を求めるために三角関数を使用しています。「三角関数」と聞くと難しそうに聞こえるかもしれませんが、要は角度を座標に変換しているだけです。</p>
<p>　ボールが壁に当たったとき、入射角と反射角度が同じになります。</p>
<figure>
<img src="images/00021.jpeg" />
<figcaption>ボールの反射。入射角と反射角度が同じになる</figcaption>
</figure>
<p>　このようにボールの反射を考えるときは角度で考えるほうが簡単です。</p>
<p>　ゲームで座標を更新する場合は、x、yの座標を更新します。ボールがAからBの位置へ移動したとします。</p>
<figure>
<img src="images/00014.jpeg" />
<figcaption>ボールがAからBの位置へ移動</figcaption>
</figure>
<p>　そのときにAのボールの座標が(x,y)だとすると、Bのボールの座標は(x+dx, y-dy)となります。このようにθ（角度）からdx, dy（x,y座標）に変換するのが三角関数です。</p>
<figure>
<img src="images/00121.jpeg" />
<figcaption>θ（角度）からdx, dy（x,y座標）に変換</figcaption>
</figure>
<p>　皆さんの中には「三角関数は初めて」という人もいるかもしれませんが、単に角度を座標に変換するものだと思えば、それほど難しいものではありません。sin（サイン）とcos（コサイン）は以下のように角度を座標に変換します。</p>
<figure>
<img src="images/00052.jpeg" />
<figcaption>三角関数</figcaption>
</figure>
<ul>
<li>Math.sin(θ)＝ y軸方向の変化分</li>
<li>Math.cos(θ)＝ x軸方向の変化分</li>
</ul>
</section>
</div>
<div id="calibre_link-60">
<section>
<h2 id="calibre_link-308"><b>5-4-3　変数</b></h2>
<p>　使用している主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>paddle</td>
  <td>パドルオブジェクト</td>
</tr>
<tr>
  <td>ball</td>
  <td>ボールオブジェクト</td>
</tr>
<tr>
  <td>timer</td>
  <td>メインループのタイマー</td>
</tr>
<tr>
  <td>blocks = []</td>
  <td>ブロックオブジェクトの配列</td>
</tr>
<tr>
  <td>balls = 3</td>
  <td>残りのボールの数</td>
</tr>
<tr>
  <td>score = 0</td>
  <td>得点</td>
</tr>
<tr>
  <td>WIDTH = 600</td>
  <td>キャンバスの幅</td>
</tr>
<tr>
  <td>HEIGHT = 600</td>
  <td>キャンバスの高さ</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00046.jpeg" />
<figcaption>blockの主な変数</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-72">
<section>
<h2 id="calibre_link-309"><b>5-4-4　オブジェクト</b></h2>
<p>　このゲームでは、ボール、ブロック、パドルの3つのオブジェクトを作成しています。</p>
<p>Ballオブジェクト</p>
<pre>
<code>function Ball() {</code>
<code>    this.x = 0;</code>
<code>    this.y = HEIGHT + this.r;</code>
<code>    this.dx = 0;</code>
<code>    this.dy = 0;</code>
<code>    this.r = 10;</code>
<code>    this.dir = 0;</code>
<code>    this.speed = 10;</code>
<code></code>
<code>    this.move = function () {</code>
<code>        this.x += this.dx;</code>
<code>        this.y += this.dy;</code>
<code>    }</code>
<code></code>
<code>    this.changeDir = function (dir) {</code>
<code>        this.dir = dir;</code>
<code>        this.dx = this.speed * Math.cos(dir);</code>
<code>        this.dy = - this.speed * Math.sin(dir);</code>
<code>    }</code>
<code></code>
<code>    this.draw = function (ctx) {</code>
<code>        drawBall(this.x, this.y, this.r);</code>
<code>    }</code>
<code>}</code>
</pre>
<figure>
<img src="images/00091.jpeg" />
<figcaption>ボールの動き</figcaption>
</figure>
<p>　Ballオブジェクトはボールの動きを管理します。xとyプロパティはボールの中心座標、dxとdyはそれぞれ、x軸方向、y軸方向の変化分を格納します。rはボールの半径で、dirはボールの進む向きをラジアン単位で格納します。speedはスピードです。</p>
<p>　moveはボールを動かすメソッドで、現在の座標にdx, dyを加算します。</p>
<p>　changeDirは壁やブロック、パドルに当たったときに呼ばれるメソッドでボールの向きを変えます。先ほど説明した三角関数を使って、角度を座標の変化分に変換しています。</p>
<p>　drawはボールを描画するメソッドです。</p>
<p>　drawBall関数はあとで説明しますが、単に黄色の円を描画する関数です。</p>
<p>
<br />
</p>
<h3 id="calibre_link-310">■BlockオブジェクトとPaddleオブジェクト</h3>
<p>　これらは両方とも矩形を描画するという共通点を持つのでプロトタイプを使ってみました。</p>
<figure>
<img src="images/00143.jpeg" />
<figcaption>BlockオブジェクトとPaddleオブジェクト</figcaption>
</figure>
<p>　オブジェクトのcolorプロパティで色をコンテキストに指定し、fillRectで矩形を描画しています。</p>
<p>BlockオブジェクトとPaddleオブジェクト</p>
<pre>
<code>Block.prototype = Paddle.prototype = {</code>
<code>    draw: function (ctx) {</code>
<code>        ctx.fillStyle = this.color;</code>
<code>        ctx.fillRect(this.x, this.y, this.w, this.h);</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function Block(x, y, i) {</code>
<code>    this.x = x;</code>
<code>    this.y = y;</code>
<code>    this.w = 50;</code>
<code>    this.h = 20;</code>
<code>    this.color = colors[i];</code>
<code>    this.point = (6 - i) * 10;</code>
<code>}</code>
<code></code>
<code>function Paddle() {</code>
<code>    this.w = 110;</code>
<code>    this.h = 20;</code>
<code>    this.x = (WIDTH - this.w) / 2;</code>
<code>    this.y = HEIGHT - 20;</code>
<code>    this.color = 'yellow'</code>
<code>    this.keyL = false;</code>
<code>    this.keyR = false;</code>
<code>}</code>
</pre>
<p>　JavaScriptでは｛...｝でオブジェクトを定義することができます。Block.prototypeとPaddle.prototypeの両方が、このオブジェクトを参照することでプロトタイプの設定を行っています。</p>
<p>　BlockとPaddleはそれぞれ、xとy座標、幅wと高さh、色colorというプロパティを持っています。</p>
<p>　Blockはこれに加えて点数を格納するpointを、Paddleは左右のキーが押されているか否かを管理するkeyLとkeyRというプロパティを持っています。</p>
</section>
</div>
<div id="calibre_link-75">
<section>
<h2 id="calibre_link-311"><b>5-4-5　関数</b></h2>
<p>　関数init()から処理が開始されます。</p>
<p>init()関数</p>
<pre>
<code>function init() {</code>
<code>    ctx = document.getElementById('canvas').getContext('2d');    //（1）</code>
<code>    ctx.font = "20pt Arial";</code>
<code></code>
<code>    // initialize event listener</code>
<code>    window.addEventListener('keydown', function (e) {</code>
<code>        toggleKey(e.keyCode, true);</code>
<code>    }, true);</code>
<code>    window.addEventListener('keyup', function (e) {</code>
<code>        toggleKey(e.keyCode, false);</code>
<code>    }, true);</code>
<code></code>
<code>    // initialize players</code>
<code>    paddle = new Paddle();</code>
<code>    ball = new Ball();</code>
<code>    start();</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        timer = setInterval(mainLoop, 15);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　（1）でcanvasのコンテキストを取得し、それをctxに格納しています。またフォントを指定しています。</p>
<p>　そのあとで、keydownとkeyupのイベントハンドラーを登録しています。それぞれ、toggleKeyという関数を呼び出しています。</p>
<p>　次に「paddle = new Paddle()」でパドルオブジェクトを作り、「ball = new Ball()」でボールオブジェクトを作成しています。</p>
<p>　最後に、start()関数を呼んでゲーム開始時の処理を行い、タイマーを開始しています。これにより、mainLoop関数が15ミリ秒間隔で呼び出されます。</p>
<p>toggleKey関数</p>
<pre>
<code>function toggleKey(code, flag) {</code>
<code>    switch (code) {</code>
<code>        case 37: paddle.keyL = flag; break;</code>
<code>        case 39: paddle.keyR = flag; break;</code>
<code>        case 32:</code>
<code>            if (!isPlaying()) {</code>
<code>                ball.x = paddle.x + paddle.w / 2;</code>
<code>                ball.y = paddle.y - ball.r;</code>
<code>                ball.changeDir(Math.random() * Math.PI / 2 + Math.PI / 4);  // 45 - 135</code>
<code>            }</code>
<code>            break;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　37が左矢印キー、39が右矢印キー、32がスペースキーです。</p>
<p>　左右キー押下時は、その状態をオブジェクトのkeyL、keyRプロパティに格納しています。</p>
<p>　プレイ中でないとき（isPlaying()が偽であったとき）、つまりプレイ中でないときにスペースキーが押下された場合は、ボールの位置と向きを初期化します。</p>
<p>　ボールのx座標はパドルの中央、y座標はパドルの上にボールが来るようにします。</p>
<p>　また、最初の角度は乱数で求めています。角度の範囲はπ/4を起点として、π/2の範囲の乱数になるようにしています。すなわち、45度から135度の間になります。</p>
<figure>
<img src="images/00127.jpeg" />
<figcaption>角度の範囲</figcaption>
</figure>
<h3 id="calibre_link-312">■start()関数</h3>
<p>　start()はゲームを開始する関数です。init()や面をクリアしたときに呼ばれます。</p>
<p>start()関数</p>
<pre>
<code>function start() {</code>
<code>    paddle.w = Math.max(20, paddle.w - 10);</code>
<code>    ball.speed = Math.min(20, ball.speed + 1);</code>
<code></code>
<code>    // layout blocks</code>
<code>    for (var i = 0 ; i &lt; 6 ; i++) {</code>
<code>        for (var j = 0 ; j &lt; 9 ; j++) {</code>
<code>            blocks.push(new Block(j * 60 + 35, i * 30 + 50, i));</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　パドルの位置を10小さくします。ただし、小さくなりすぎないように20が最小値になるようにしています。またスピードを1だけ速くなるようにしていますが、こちらも速すぎないように上限を20に設定しています。</p>
<p>　そのあとで、2つのfor文を使ってブロックを配置しています。iが縦方向、jが横方向です。ブロックオブジェクトは「new Block(...)」で作成し、それを配列blocksに挿入しています。</p>
<h3 id="calibre_link-313">■メインループ</h3>
<p>　mainLoop()はメインループです。少し長いので、分割して説明します。</p>
<p>mainLoop()関数1</p>
<pre>
<code>function mainLoop() {</code>
<code>    // move the paddle</code>
<code>    if (paddle.keyL) {</code>
<code>        paddle.x = Math.max(0, paddle.x - 10)</code>
<code>    }</code>
<code>    if (paddle.keyR) {</code>
<code>        paddle.x = Math.min(WIDTH - paddle.w, paddle.x + 10)</code>
<code>    }</code>
<code></code>
<code>    draw();</code>
<code></code>
<code>    if (!isPlaying()) {</code>
<code>        return;</code>
<code>    }</code>
</pre>
<p>　まず、左右キーの押下状態に応じて、パドルの位置を更新しています。Math.maxやMath.minを使って画面をはみ出さないようにしています。その後、draw()で画面を描画します。プレイ中でない場合はこの段階で関数を抜けます。</p>
<p>　次は、ボールが一番下に来たときの処理です。ボールのy座標が「HEIGHT - paddle.h」より大きくなるか否かで判定しています。</p>
<p>mainLoop()関数2</p>
<pre>
<code>if (ball.y &gt; HEIGHT - paddle.h) {</code>
<code>    // hit the paddle?</code>
<code>    if (paddle.x &lt; ball.x &amp;&amp; ball.x &lt; paddle.x + paddle.w &amp;&amp;</code>
<code>        paddle.y &lt; ball.y &amp;&amp; ball.y &lt; paddle.y + paddle.h) {</code>
<code>        var ratio = (paddle.x + paddle.w / 2 - ball.x) / paddle.w * 0.8;</code>
<code> 　     ball.changeDir(Math.PI / 2 + Math.PI * ratio);</code>
<code>    }</code>
<code>    else {</code>
<code>        if (--balls == 0) {   // game over</code>
<code>            clearInterval(timer);</code>
<code>            timer = NaN;</code>
<code>            draw();</code>
<code>            return;</code>
<code>        }</code>
<code>        ball.y = HEIGHT + ball.r;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　パドルとボールのx、y座標、幅wと高さhを比較することで、パドルとボールが当たっているか判定しています。その場合は、ボールとパドルの位置関係に応じて、次の反射角を求めています。イメージを以下に示します。</p>
<figure>
<img src="images/00071.jpeg" />
<figcaption>ボールの反射角</figcaption>
</figure>
<p>　ボールがパドルにぶつからなかった場合は、ボールを1つ減らします。もし、それが0になったときはタイマーを止めて、再描画を行って関数を抜けます。0にならなかった場合、ボールの座標を画面の下端にして初期化します。</p>
<p>　ボールの次の座標nx、nyを求めて、壁やブロックにぶつかるか判定します。</p>
<p>mainLoop()関数3</p>
<pre>
<code>var nx = ball.x + ball.dx;</code>
<code>var ny = ball.y - ball.dy;</code>
<code></code>
<code>// hit the wall?</code>
<code>if (ny &lt; ball.r &amp;&amp; ball.dy &lt; 0) {</code>
<code>    ball.changeDir(ball.dir * -1);</code>
<code>}</code>
<code>else if (nx &lt; ball.r || nx + ball.r &gt; WIDTH) {</code>
<code>    ball.changeDir(Math.PI - ball.dir);</code>
<code>}</code>
<code></code>
<code>// hit a block?</code>
<code>var hit = -1;</code>
<code>blocks.some(function (block, i) {</code>
<code>    if (block.x - ball.r &lt; nx &amp;&amp; nx &lt; block.x + block.w + ball.r &amp;&amp;</code>
<code>        block.y - ball.r &lt; ny &amp;&amp; ny &lt; block.y + block.h + ball.r) {</code>
<code>        hit = i;</code>
<code>        return true;</code>
<code>    }</code>
<code>    return false;</code>
<code>});</code>
</pre>
<p>　壁にぶつかった場合は、ボールの向きを反転させます。ブロックに当たったか否かはblocks.someで判定しています。このsomeはblocksの各要素に対してコールバック関数を呼び出します。ブロックと衝突した場合は、その番号がhitに格納されます。</p>
<p>　ブロックと衝突していた場合、すなわち、「hit &gt;= 0」が真の場合、ブロックのポイントをスコアに加算し、そのブロックをblocks配列からspliceメソッドを使って削除します。</p>
<p>mainLoop()関数4</p>
<pre>
<code>    if (hit &gt;= 0) {</code>
<code>        score += blocks[hit].point;</code>
<code>        blocks.splice(hit, 1);</code>
<code></code>
<code>        if (blocks.length &lt;= 0) { // cleared</code>
<code>            ball.y = HEIGHT + ball.r;</code>
<code>            start();</code>
<code>            return;</code>
<code>        }</code>
<code>        ball.changeDir(ball.dir * -1);</code>
<code>    }</code>
<code></code>
<code>    ball.move();</code>
<code>}</code>
</pre>
<p>　blocksがすべて消去されたら、start()を呼んで次の面をスタートします。</p>
<p>　また、ブロックに当たったので向きを変えています。最後にball.move()でボールを移動します。</p>
<h3 id="calibre_link-314">■isPlaying関数</h3>
<p>　isPlayingはゲーム中か否かを返す関数です。単にボールのy座標の値で判定しています。</p>
<p>isPlaying関数</p>
<pre>
<code>function isPlaying() {</code>
<code>    return ball.y &lt; HEIGHT + ball.r;</code>
<code>}</code>
</pre>
<h3 id="calibre_link-315">■drawBall関数</h3>
<p>　drawBall(x, y, r)は、座標x,yに半径rでボールを描画する関数です。</p>
<p>drawBall関数</p>
<pre>
<code>function drawBall(x, y, r) {</code>
<code>    ctx.fillStyle = 'yellow';</code>
<code>    ctx.beginPath();</code>
<code>    ctx.arc(x, y, r, 0, Math.PI * 2, true);</code>
<code>    ctx.fill();</code>
<code>}</code>
</pre>
<h3 id="calibre_link-316">■draw()関数</h3>
<p>　draw()は画面全体を描画する関数です。全体を黒「rgb(0,0,0)」で塗りつぶしてクリアします。その後、ブロック、パドル、ボールと描画していきます。残りのボールの個数、現在の得点を描画します。ゲーム終了時には「GAME OVER」という文字列を描画します。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // fill background</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, WIDTH, HEIGHT);</code>
<code></code>
<code>    // draw blocks</code>
<code>    blocks.forEach(function (block) {</code>
<code>        block.draw(ctx);</code>
<code>    });</code>
<code></code>
<code>    // draw paddle</code>
<code>    paddle.draw(ctx);</code>
<code></code>
<code>    // draw balls</code>
<code>    ball.draw(ctx);</code>
<code>    if (balls &gt; 2) { drawBall(80, 15, 10); }</code>
<code>    if (balls &gt; 1) { drawBall(50, 15, 10); }</code>
<code></code>
<code>    // draw score &amp; information</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('00000' + score).slice(-5), 500, 30);</code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 220, 250);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　プログラムの解説は以上です。少し長めのソースコードでしたがリアルタイム系ゲームの基本が満載されています。デバッガを使って動作の様子を確認したり、パラメータを変更してみたりしてください。</p>
</section>
</div>
<div id="calibre_link-29">
<section>
<hgroup>
<h1 id="calibre_link-177"><b>5-5　シューティングゲーム（1）</b></h1>
</hgroup>
<p>　スペースインベーダーは株式会社タイトーが1978年に発表したアーケードゲームです。当時は社会現象となるほどの人気でした。そのすばらしいゲームに敬意を表して基本的な部分だけを作ってみました。バリケードがない、UFOが出てこない、効果音がないなど、本家のクオリティには遠く及びませんが、シューティングゲームの基本的なところをご紹介できればと思います。</p>
<figure>
<img src="images/00134.jpeg" />
<figcaption>敵をミサイルで撃ち落とすおなじみのゲーム</figcaption>
</figure>
<p>【使用している画像】</p>
<p>　本ゲームで使用している画像とその用途です。画像はどんな絵でもかまいません。Windowsに標準でついてくる「ペイント」で作ることもできますので、自分の好きな絵を作成して、世界で唯一のオリジナルゲームを作り上げてください。</p>
<figure>
<img src="images/00170.jpeg" />
<figcaption></figcaption>
</figure>
</section>
</div>
<div id="calibre_link-130">
<section>
<h2 id="calibre_link-317"><b>5-5-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;script type="text/javascript"&gt;</code>
<code>var ctx, ship, beam, aliens = [], bombs = [],</code>
<code>    score = 0, stage = 1, clock = 0, mainT = NaN, alienT = NaN;</code>
<code></code>
<code>function Beam() {</code>
<code>    this.x = 0;</code>
<code>    this.y = -100;</code>
<code>    this.offset = 0;</code>
<code>    this.even = false;</code>
<code>    this.isEven = function () { return this.even; }</code>
<code>}</code>
<code></code>
<code>function Bomb() {</code>
<code>    this.x = 0;</code>
<code>    this.y = 600;</code>
<code>    this.offset = 48;</code>
<code>    this.even = false;</code>
<code>    this.time = rand(200) + 50;</code>
<code>    this.isEven = function () { return this.even; }</code>
<code>}</code>
<code></code>
<code>function Alien(x, y, point, offset) {</code>
<code>    this.x = x;</code>
<code>    this.y = y;</code>
<code>    this.point = point;</code>
<code>    this.offset = offset;</code>
<code>    this.isEven = function () { return Alien.isEven; }</code>
<code>}</code>
<code></code>
<code>function Ship() {</code>
<code>    this.x = 0;</code>
<code>    this.y = 550;</code>
<code>    this.offset = 192;</code>
<code>    this.moveL = false;</code>
<code>    this.moveR = false;</code>
<code>    this.isEven = function () { return true; }</code>
<code>}</code>
<code></code>
<code>var bitmap = {</code>
<code>    draw: function (ctx) {</code>
<code>        if (!this.strip) {</code>
<code>            this.strip = document.getElementById('strip');</code>
<code>        }</code>
<code>        ctx.drawImage(this.strip,</code>
<code>            this.offset + (this.isEven() ? 0 : 24), 0, 24, 24,</code>
<code>            this.x, this.y, 24, 24);</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>Ship.prototype = Beam.prototype = Alien.prototype = Bomb.prototype = bitmap;</code>
<code></code>
<code>Alien.isEven = false;</code>
<code>Alien.isDown = false;</code>
<code>Alien.isLeft = false;</code>
<code>Alien.interval = 1000;</code>
<code></code>
<code>function rand(max) {</code>
<code>    return Math.floor(Math.random() * max);</code>
<code>}</code>
<code></code>
<code>function init() {</code>
<code>    ctx = document.getElementById('canvas').getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code>    score = 0, stage = 1;</code>
<code></code>
<code>    addEventListener('keydown', keyDown, true);</code>
<code>    addEventListener('keyup', keyUp, true);</code>
<code></code>
<code>    start();</code>
<code>}</code>
<code></code>
<code>function start() {</code>
<code>    ship = new Ship();</code>
<code>    beam = new Beam();</code>
<code>    clock = 0;</code>
<code>    Alien.interval = 1000 - stage * 50;</code>
<code></code>
<code>    for (var i = 0 ; i &lt; 4 ; i++) {</code>
<code>        var offset = (i &lt; 2) ? 96 : 144;</code>
<code>        for (var j = 0 ; j &lt; 10 ; j++) {</code>
<code>            aliens.push(new Alien(100 + j*50, i*50 + 50*stage, (4 - i) * 10, offset));</code>
<code>        }</code>
<code>        bombs.push(new Bomb());</code>
<code>    }</code>
<code></code>
<code>    if (isNaN(alienT)) {</code>
<code>        alienT = setTimeout(alienLoop, Alien.interval);</code>
<code>    }</code>
<code>    if (isNaN(mainT)) {</code>
<code>        mainT = setInterval(mainLoop, 50);</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function keyDown(evt) {</code>
<code>    if (evt.keyCode == 37) ship.moveL = true;</code>
<code>    if (evt.keyCode == 39) ship.moveR = true;</code>
<code>    if (evt.keyCode == 32 &amp;&amp; beam.y &lt; 0) {</code>
<code>        beam.y = 520; beam.x = ship.x;</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function keyUp(evt) {</code>
<code>    if (evt.keyCode == 37) ship.moveL = false;</code>
<code>    if (evt.keyCode == 39) ship.moveR = false;</code>
<code>}</code>
<code></code>
<code>function alienLoop() {</code>
<code>    var minX = Infinity, maxX = 0, maxY = 0;</code>
<code></code>
<code>    Alien.isEven = !Alien.isEven;</code>
<code></code>
<code>    // update aliens' position</code>
<code>    aliens.forEach(function (e) {</code>
<code>        e.x += Alien.isDown ? 0 : (Alien.isLeft ? -10 : 10);</code>
<code>        e.y += Alien.isDown ? 20 : 0;</code>
<code>    });</code>
<code></code>
<code>    aliens.forEach(function (e) {</code>
<code>        minX = Math.min(minX, e.x);</code>
<code>        maxX = Math.max(maxX, e.x);</code>
<code>        maxY = Math.max(maxY, e.y);</code>
<code>    });</code>
<code></code>
<code>    if (Alien.isDown) {</code>
<code>        Alien.isDown = false;</code>
<code>    } else if (minX &lt; 20) {</code>
<code>        Alien.isDown = true;</code>
<code>        Alien.isLeft = false;</code>
<code>    } else if (maxX &gt; 560) {</code>
<code>        Alien.isDown = true;</code>
<code>        Alien.isLeft = true;</code>
<code>    }</code>
<code></code>
<code>    if (maxY &gt; 550) {</code>
<code>        gameOver();</code>
<code>    } else {</code>
<code>        Alien.interval = Math.max(50, Alien.interval - 5);</code>
<code>        setTimeout(alienLoop, Alien.interval);</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function gameOver() {</code>
<code>    clearInterval(mainT); mainT = NaN;</code>
<code>    clearTimeout(alienT); alienT = NaN;</code>
<code>    draw();</code>
<code>}</code>
<code></code>
<code>function mainLoop() {</code>
<code>    clock++;</code>
<code></code>
<code>    if (aliens.length == 0) {</code>
<code>        if (clock &gt; 100) {</code>
<code>            stage++;</code>
<code>            start();</code>
<code>        }</code>
<code>        return;</code>
<code>    }</code>
<code></code>
<code>    // update beam and check if it hits an alien</code>
<code>    var hit = -1;</code>
<code>    if (beam.y &gt; -30) {</code>
<code>        beam.y -= 15;</code>
<code>        beam.even = !beam.even;</code>
<code>        aliens.forEach(function (e, i) {</code>
<code>            if (e.x - 15 &lt; beam.x &amp;&amp; beam.x &lt; e.x + 15 &amp;&amp;</code>
<code>                e.y - 10 &lt; beam.y &amp;&amp; beam.y &lt; e.y + 20) {</code>
<code>                hit = i; beam.y = -100; score += e.point;</code>
<code>                return;</code>
<code>            }</code>
<code>        });</code>
<code>    }</code>
<code>    if (hit &gt;= 0) {</code>
<code>        aliens.splice(hit, 1);</code>
<code></code>
<code>        // stage clear</code>
<code>        if (aliens.length == 0) {</code>
<code>            clock = 0;</code>
<code>            draw();</code>
<code>            return;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    // update bombs and check if it hits the ship</code>
<code>    bombs.forEach(function (b) {</code>
<code>        if (b.time &lt; clock) {</code>
<code>            var a = aliens[rand(aliens.length)];</code>
<code>            b.x = a.x, b.y = a.y + 30;</code>
<code>            b.time += rand(200) + 50;</code>
<code>        }</code>
<code>        else if (b.y &lt; 600) {</code>
<code>            b.y += 10</code>
<code>        }</code>
<code></code>
<code>        b.even = !b.even;</code>
<code>        if (b.x - 15 &lt; ship.x &amp;&amp; ship.x &lt; b.x + 15 &amp;&amp; 530 &lt; b.y &amp;&amp; b.y &lt; 550) {</code>
<code>            gameOver();</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    // move the ship</code>
<code>    if (ship.moveR) { ship.x = Math.min(ship.x + 5, 570); }</code>
<code>    if (ship.moveL) { ship.x = Math.max(ship.x - 5, 0); }</code>
<code></code>
<code>    draw();</code>
<code>}</code>
<code></code>
<code>function draw() {</code>
<code>    // fill background</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, 600, 600);</code>
<code></code>
<code>    // draw aliens</code>
<code>    aliens.forEach(function (a) { a.draw(ctx); });</code>
<code></code>
<code>    // draw ship</code>
<code>    ship.draw(ctx);</code>
<code></code>
<code>    // draw beam</code>
<code>    beam.draw(ctx);</code>
<code></code>
<code>    // draw bombs</code>
<code>    bombs.forEach(function (b) { b.draw(ctx); });</code>
<code></code>
<code>    // draw score</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('0000000' + score).slice(-7), 470, 30);</code>
<code></code>
<code>    if (aliens.length == 0) {</code>
<code>        ctx.fillText('STAGE CLEAR', 200, 150);</code>
<code>    }</code>
<code></code>
<code>    if (isNaN(mainT)) {</code>
<code>        ctx.fillText('GAME OVER', 220, 150);</code>
<code>    }</code>
<code>}</code>
<code>&lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body onload="init();"&gt;</code>
<code>&lt;canvas id="canvas" width="600" height="600"/&gt;</code>
<code>&lt;img id="strip" src="strip.png" style="display:none;" /&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-3">
<section>
<h2 id="calibre_link-318"><b>5-5-2　画像</b></h2>
<p>　このゲームではstrip.pngという幅が216px、高さが24pxの画像ファイルを1つ使用しています。このファイルには、次の図のように24px×24pxのサイズのキャラクターが9個含まれています。</p>
<figure>
<img src="images/00010.jpeg" />
<figcaption>strip.png</figcaption>
</figure>
<p>　個々の画像を別々のファイルにしてもよいのですが、ファイルの管理が面倒なので1つのファイルにまとめました。これは、インターネットで少しでもダウンロードのスピードを改善したいというような場合によく使われるテクニックです。</p>
<p>　このゲームでは、ビーム、爆弾、エイリアン1、エイリアン2、母船の5つのキャラクターが出てきますが、母船を除く4種類の画像は2つの画像を交互に切り替えて表示します。画像を切り替えて描画する方法についてはオブジェクトのところで説明します。</p>
</section>
</div>
<div id="calibre_link-22">
<section>
<h2 id="calibre_link-319"><b>5-5-3　変数</b></h2>
<p>　主な変数を以下に列挙します。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>ship</td>
  <td>母船のオブジェクト</td>
</tr>
<tr>
  <td>beam</td>
  <td>母船の発射するビームオブジェクト</td>
</tr>
<tr>
  <td>aliens</td>
  <td>エイリアンオブジェクトを管理する配列</td>
</tr>
<tr>
  <td>bombs</td>
  <td>爆弾オブジェクトを管理する配列</td>
</tr>
<tr>
  <td>score</td>
  <td>現在のスコア</td>
</tr>
<tr>
  <td>clock</td>
  <td>爆弾を落とすタイミングやステージクリア時のタイミングを処理するカウンタ</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00108.jpeg" />
<figcaption>Invaderの主な変数</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-31">
<section>
<h2 id="calibre_link-320"><b>5-5-4　オブジェクト</b></h2>
<p>　今回のゲームでは4つのオブジェクト、Beam、Bomb、Alien、Shipを使用しています。それらはすべて画面上に描画するという共通点を持つため、同じbitmapというオブジェクトをprototypeとして参照しています。このbitmapにはdrawというメソッドがあり、それぞれの画像を描画しています。個々のオブジェクトとprototypeの関係を以下の図に示します。</p>
<figure>
<img src="images/00032.jpeg" />
<figcaption>オブジェクトとprototypeの関係</figcaption>
</figure>
<p>　オブジェクトのソースは以下の通りです。それぞれのオブジェクトには座標を表すxとyプロパティがあります。offsetは元画像のstrip.pngのどこから描画するかという値です。isEvenは画像を切り替えるか否かを返す関数です。bitmapのdrawメソッドの中から呼び出されており、その値によって画像のオフセットが0か24ずれるように動作します。</p>
<p>
<br />
</p>
<pre>
<code>function Beam() {</code>
<code>    this.x = 0;</code>
<code>    this.y = -100;</code>
<code>    this.offset = 0;</code>
<code>    this.even = false;</code>
<code>    this.isEven = function () { return this.even; }</code>
<code>}</code>
<code></code>
<code>function Bomb() {</code>
<code>    this.x = 0;</code>
<code>    this.y = 600;</code>
<code>    this.offset = 48;</code>
<code>    this.even = false;</code>
<code>    this.time = rand(200) + 50;</code>
<code>    this.isEven = function () { return this.even; }</code>
<code>}</code>
<code></code>
<code>function Alien(x, y, point, offset) {</code>
<code>    this.x = x;</code>
<code>    this.y = y;</code>
<code>    this.point = point;</code>
<code>    this.offset = offset;</code>
<code>    this.isEven = function () { return Alien.isEven; }</code>
<code>}</code>
<code></code>
<code>function Ship() {</code>
<code>    this.x = 0;</code>
<code>    this.y = 550;</code>
<code>    this.offset = 192;</code>
<code>    this.moveL = false;</code>
<code>    this.moveR = false;</code>
<code>    this.isEven = function () { return true; }</code>
<code>}</code>
<code></code>
<code>var bitmap = {</code>
<code>    draw: function (ctx) {</code>
<code>        if (!this.strip) {</code>
<code>            this.strip = document.getElementById('strip');</code>
<code>        }</code>
<code>        ctx.drawImage(this.strip,</code>
<code>            this.offset + (this.isEven() ? 0 : 24), 0, 24, 24,</code>
<code>            this.x, this.y, 24, 24);</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>Ship.prototype = Beam.prototype = Alien.prototype = Bomb.prototype = bitmap;</code>
<code></code>
<code>Alien.isEven = false;</code>
<code>Alien.isDown = false;</code>
<code>Alien.isLeft = false;</code>
<code>Alien.interval = 1000;</code>
</pre>
<p>　BeamとBombはオブジェクトごとに描画を切り替えるので、「function () { return this.even; }」という関数で値を返しています。</p>
<p>　一方、Alienはすべてのエイリアンを同時に切り替えるので、「function () { return Alien.isEven; }」という関数になっています。</p>
<p>　Shipは画像を切り替える必要がないので、「function () { return true; }」と常に同じ値を返しています。</p>
<p>　Bombのtimeはいつ爆弾を落とし始めるかという時刻を保持しています。また、ShipのmoveLとmoveRはキーの押下状態を保持しています。</p>
<p>　Alienは同時に画像（isEven）を切り替えたり、同時に左右（isLeft）に動いたりします。下に降りるとき（isDown）もみんな同時で、動くスピード（interval）も同時です。これらをすべてグローバル変数で管理しています。</p>
</section>
</div>
<div id="calibre_link-95">
<section>
<h2 id="calibre_link-321"><b>5-5-5　関数</b></h2>
<h3 id="calibre_link-322">■rand関数、init()関数</h3>
<p>　randは0からmaxまでの整数を返す関数、initは初期化時に呼ばれる関数です。</p>
<p>rand関数とinit()関数</p>
<pre>
<code>function rand(max) {</code>
<code>    return Math.floor(Math.random() * max);</code>
<code>}</code>
<code></code>
<code>function init() {</code>
<code>    ctx = document.getElementById('canvas').getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code>    score = 0, stage = 1;</code>
<code></code>
<code>    addEventListener('keydown', keyDown, true);</code>
<code>    addEventListener('keyup', keyUp, true);</code>
<code></code>
<code>    start();</code>
<code>}</code>
</pre>
<p>　initではコンテキストを取得してctxに格納し、フォントを設定しています。またスコアscoreとステージstageを初期化し、'keydown'と'keyup'のイベントハンドラーを登録し、start()関数を呼び出しています。</p>
<h3 id="calibre_link-323">■start()関数</h3>
<p>　start()は各ステージを開始する処理を行います。</p>
<p>start()関数</p>
<pre>
<code>function start() {</code>
<code>    ship = new Ship();</code>
<code>    beam = new Beam();</code>
<code>    clock = 0;</code>
<code>    Alien.interval = 1000 - stage * 50;</code>
<code></code>
<code>    for (var i = 0 ; i &lt; 4 ; i++) {</code>
<code>        var offset = (i &lt; 2) ? 96 : 144;</code>
<code>        for (var j = 0 ; j &lt; 10 ; j++) {</code>
<code>            aliens.push(new Alien(100 + j*50, i*50 + 50*stage, (4-i)*10, offset));</code>
<code>        }</code>
<code>        bombs.push(new Bomb());</code>
<code>    }</code>
<code></code>
<code>    if (isNaN(alienT)) {</code>
<code>        alienT = setTimeout(alienLoop, Alien.interval);</code>
<code>    }</code>
<code>    if (isNaN(mainT)) {</code>
<code>        mainT = setInterval(mainLoop, 50);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　まず、ship、beamなどを初期化します。</p>
<p>　Alien.intervalはAlienを動かすタイマーの値ですが、ステージが進むごとに速くなるように初期化しています。</p>
<p>　そのあとのfor文でAlienオブジェクトを作り、配列aliensに格納しています。</p>
<p>　Alienのコンストラクタの引数は、x座標、y座標、撃ち落としたときの得点、画像のオフセットとなっています。ステージが進むごとに難しくなるようy座標を増やしています。</p>
<p>　また、Bombオブジェクトを4つ、bombs配列に格納しています。</p>
<p>　最後にAlien用とメインループ用に2つのタイマーを開始しています。前者は徐々にスピードをあげるためsetTimeoutを、後者は常に一定間隔でよいのでsetIntervalを使っています。</p>
<h3 id="calibre_link-324">■キー入力処理のkeyDown関数とkeyUp関数</h3>
<p>　次はキー入力処理のkeyDownとkeyUpです。</p>
<p>keyDown関数とkeyUp関数</p>
<pre>
<code>function keyDown(evt) {</code>
<code>    if (evt.keyCode == 37) ship.moveL = true;</code>
<code>    if (evt.keyCode == 39) ship.moveR = true;</code>
<code>    if (evt.keyCode == 32 &amp;&amp; beam.y &lt; 0) {</code>
<code>        beam.y = 520; beam.x = ship.x;</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function keyUp(evt) {</code>
<code>    if (evt.keyCode == 37) ship.moveL = false;</code>
<code>    if (evt.keyCode == 39) ship.moveR = false;</code>
<code>}</code>
</pre>
<p>　左キー（37）が押されたときにship.moveLをtrueに、右キー（39）が押されたときにship.moveRをtrueにしています。また、スペースキー（32）が押下されたときにbeamのy座標が0未満、すなわち画面の外にあるときはビーム発射OKとして、beamのx、y座標を初期化しています。</p>
<h3 id="calibre_link-325">■Alien用のループ関数</h3>
<p>　次はAlien用のループ関数です。少し長いので分割して説明します。</p>
<p>alienLoop()関数1</p>
<pre>
<code>function alienLoop() {</code>
<code>    var minX = Infinity, maxX = 0, maxY = 0;</code>
<code></code>
<code>    Alien.isEven = !Alien.isEven;</code>
<code></code>
<code>    // update aliens' position</code>
<code>    aliens.forEach(function (e) {</code>
<code>        e.x += Alien.isDown ? 0 : (Alien.isLeft ? -10 : 10);</code>
<code>        e.y += Alien.isDown ? 20 : 0;</code>
<code>    });</code>
<code></code>
<code>    aliens.forEach(function (e) {</code>
<code>        minX = Math.min(minX, e.x);</code>
<code>        maxX = Math.max(maxX, e.x);</code>
<code>        maxY = Math.max(maxY, e.y);</code>
<code>    });</code>
</pre>
<p>　Alienは個々に別のオブジェクトですが、移動するときは集団で行動します。その端の座標を管理しているのが、minXとmaxX、maxYです。</p>
<figure>
<img src="images/00131.jpeg" />
<figcaption>Alienの座標</figcaption>
</figure>
<p>　「Alien.isEven = !Alien.isEven」という処理で、false→true、true→false...と都度値が切り替わります。この処理によって、全Alienの画像を切り替えます。</p>
<p>alienLoop()関数2</p>
<pre>
<code>aliens.forEach(function (e) {</code>
<code>    e.x += Alien.isDown ? 0 : (Alien.isLeft ? -10 : 10);</code>
<code>    e.y += Alien.isDown ? 20 : 0;</code>
<code>});</code>
</pre>
<p>という行ですべてのAlienを動かしています。</p>
<p>　isDownが真のときx方向は変化せず、y方向に20移動します。</p>
<p>　isDownが偽のときはx方向はisLeftの値に応じて-10か10、y方向は変化なしとしています。</p>
<p>　これを配列aliensにあるすべてのAlienオブジェクトに適用しています。</p>
<p>　以下の処理は、minXとmaxX、maxYを求めています。Mathオブジェクトのメソッドを使って、一番小さい値、大きい値を求めていることに注意して読んでみてください。</p>
<p>alienLoop()関数3</p>
<pre>
<code>aliens.forEach(function (e) {</code>
<code>    minX = Math.min(minX, e.x);</code>
<code>    maxX = Math.max(maxX, e.x);</code>
<code>    maxY = Math.max(maxY, e.y);</code>
<code>});</code>
</pre>
<p>　次のif文は、Alienが下向きに動いたときは、次回は左右のどちらかへ、Alienの軍団が左端に到達したとき（minX &lt; 20）は右に向きを変えて一段下がり、右端に到達したとき（maxX &gt; 560）は左に向きを変えて一段下がる処理をしています。</p>
<p>alienLoop()関数4</p>
<pre>
<code>    if (Alien.isDown) {</code>
<code>        Alien.isDown = false;</code>
<code>    } else if (minX &lt; 20) {</code>
<code>        Alien.isDown = true;</code>
<code>        Alien.isLeft = false;</code>
<code>    } else if (maxX &gt; 560) {</code>
<code>        Alien.isDown = true;</code>
<code>        Alien.isLeft = true;</code>
<code>    }</code>
<code></code>
<code>    if (maxY &gt; 550) {</code>
<code>        gameOver();</code>
<code>    } else {</code>
<code>        Alien.interval = Math.max(50, Alien.interval - 5);</code>
<code>        setTimeout(alienLoop, Alien.interval);</code>
<code>    }</code>
</pre>
<p>　Alienが下まで到達すると（maxY &gt; 550）ゲームオーバーなので、gameOver()を呼び出しています。そうでない場合は、時間を5ミリ秒短くしてsetTimeoutを呼び出しています。呼び出し間隔が50ミリ秒より小さくならないようにMath.maxを使用しています。</p>
<h3 id="calibre_link-326">■gameOver()関数</h3>
<p>　gameOver()はゲームオーバー時の処理を行うものでタイマーを止めて再描画を行います。</p>
<p>gameOver()関数</p>
<pre>
<code>function gameOver() {</code>
<code>    clearInterval(mainT); mainT = NaN;</code>
<code>    clearTimeout(alienT); alienT = NaN;</code>
<code>    draw();</code>
<code>}</code>
</pre>
<h3 id="calibre_link-327">■メインループ</h3>
<p>　mainLoop()はメインループです。これも少々長いので分割して説明します。</p>
<p>mainLoop()関数1</p>
<pre>
<code>function mainLoop() {</code>
<code>    clock++;</code>
<code></code>
<code>    if (aliens.length == 0) {</code>
<code>        if (clock &gt; 100) {</code>
<code>            stage++;</code>
<code>            start();</code>
<code>        }</code>
<code>        return;</code>
<code>    }</code>
</pre>
<p>　aliensの残りが0になったときはステージクリアの処理を行います。</p>
<p>　以下は自分の発射したビームがAlienに当たっているか判定している部分です。</p>
<p>mainLoop()関数2</p>
<pre>
<code>    // update beam and check if it hits an alien</code>
<code>    var hit = -1;</code>
<code>    if (beam.y &gt; -30) {</code>
<code>        beam.y -= 15;</code>
<code>        beam.even = !beam.even;</code>
<code>        aliens.forEach(function (e, i) {</code>
<code>            if (e.x - 15 &lt; beam.x &amp;&amp; beam.x &lt; e.x + 15 &amp;&amp;</code>
<code>                e.y - 10 &lt; beam.y &amp;&amp; beam.y &lt; e.y + 20) {</code>
<code>                hit = i; beam.y = -100; score += e.point;</code>
<code>                return;</code>
<code>            }</code>
<code>        });</code>
<code>    }</code>
<code>    if (hit &gt;= 0) {</code>
<code>        aliens.splice(hit, 1);</code>
<code></code>
<code>        // stage clear</code>
<code>        if (aliens.length == 0) {</code>
<code>            clock = 0;</code>
<code>            draw();</code>
<code>            return;</code>
<code>        }</code>
<code>    }</code>
</pre>
<p>　ビームが画面の中にいる場合（beam.y &gt; -30）、すなわち発射中の場合、そのy座標を15減らし、画像を「beam.even = !beam.even;」で切り替えています。そのあとで、個々のAlienとビームの座標値を比較し、当たっているか判定しています。x軸方向での比較の様子を次の図に示します。y軸方向も同様の判定を行っています。</p>
<figure>
<img src="images/00058.jpeg" />
<figcaption>ビームが当たっているか（x軸方向での比較）</figcaption>
</figure>
<p>　X軸方向の場合、ビームのX座標とエイリアンのX座標を比較し、その差がプラスマイナス15に収まっていた場合に衝突と判定しました。15という数値は画像の内容を見て微調整しました。Y軸方向も同様に比較します。</p>
<p>　もし、当たっていた場合、そのインデックスをhitにいったん保存し、ビームのy座標を画面の外に設定して、画面から消します。また、そのAlienのpointをスコアに加算します。</p>
<p>　forEachメソッドを抜け、当たっていると判定された場合（hit &gt;= 0）、そのオブジェクトを「aliens.splice(hit, 1)」で配列から削除します。また、ステージクリアの場合はその処理を行います。</p>
<p>　次は、Alienからの爆弾Bombの処理です。爆弾は配列bombsに格納されています。</p>
<p>mainLoop()関数3</p>
<pre>
<code>    // update bombs and check if it hits the ship</code>
<code>    bombs.forEach(function (b) {</code>
<code>        if (b.time &lt; clock) {</code>
<code>            var a = aliens[rand(aliens.length)];</code>
<code>            b.x = a.x, b.y = a.y + 30;</code>
<code>            b.time += rand(200) + 50;</code>
<code>        }</code>
<code>        else if (b.y &lt; 600) {</code>
<code>            b.y += 10</code>
<code>        }</code>
<code></code>
<code>        b.even = !b.even;</code>
<code>        if (b.x - 15 &lt; ship.x &amp;&amp; ship.x &lt; b.x + 15 &amp;&amp; 530 &lt; b.y &amp;&amp; b.y &lt; 550) {</code>
<code>            gameOver();</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    // move the ship</code>
<code>    if (ship.moveR) { ship.x = Math.min(ship.x + 5, 570); }</code>
<code>    if (ship.moveL) { ship.x = Math.max(ship.x - 5, 0); }</code>
<code></code>
<code>    draw();</code>
<code>}</code>
</pre>
<p>　個々のBombオブジェクトを取り出し、その発射時間と現在時刻を比較し（b.time &lt; clock）、どのAlienから発射されたものかを乱数で求めています。そのAlienオブジェクトの座標でBombのxとy座標を初期化しています。そして、次に発射する時刻を乱数で求め、timeにセットしています。</p>
<p>　Bombが画面中にある場合（b.y &lt; 600）、そのy座標に10加算します。</p>
<p>　「b.even = !b.even;」で画像を切り替え、母船と衝突しているか判定し、衝突している場合はgameOver()を呼び出します。</p>
<p>　最後に左右キーの押下状態に応じて母船のx座標を更新しています。その際、画面をはみ出さないように、Math.minとMath.maxを利用しています。</p>
<h3 id="calibre_link-328">■draw()関数</h3>
<p>　最後はdraw()です。画面を描画します。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // fill background</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, 600, 600);</code>
<code></code>
<code>    // draw aliens</code>
<code>    aliens.forEach(function (a) { a.draw(ctx); });</code>
<code></code>
<code>    // draw ship</code>
<code>    ship.draw(ctx);</code>
<code></code>
<code>    // draw beam</code>
<code>    beam.draw(ctx);</code>
<code></code>
<code>    // draw bombs</code>
<code>    bombs.forEach(function (b) { b.draw(ctx); });</code>
<code></code>
<code>    // draw score</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('0000000' + score).slice(-7), 470, 30);</code>
<code></code>
<code>    if (aliens.length == 0) {</code>
<code>        ctx.fillText('STAGE CLEAR', 200, 150);</code>
<code>    }</code>
<code></code>
<code>    if (isNaN(mainT)) {</code>
<code>        ctx.fillText('GAME OVER', 220, 150);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　画面を黒でクリアし、エイリアン、母船、ビーム、爆弾と描画していきます。オブジェクトにしているので、それぞれのオブジェクトに対してdraw(ctx)を呼ぶだけで描画できることに注目してください。</p>
<p>　そしてスコアを表示します。エイリアンが0のときは「STAGE CLEAR」を、タイマーが止まっているときは「GAME OVER」を表示しています。</p>
<p>　プログラムの解説は以上です。UFOを追加したり、バリケードを追加したり、自分なりに改造して楽しんでみてください。</p>
</section>
</div>
<div id="calibre_link-68">
<section>
<hgroup>
<h1 id="calibre_link-178"><b>5-6　シューティングゲーム（2）</b></h1>
</hgroup>
<p>　空から降ってくるミサイルを、地上から迎え撃つというミサイルコマンド風ゲームです。家が全滅したらゲームオーバーです。</p>
<p>　ミサイルコマンドは1980年にアタリが発売したゲームです。トラックボールというデバイスで照準器を動かすのが当時新鮮だったことを覚えています。Canvas上に円、線、画像などを描画する練習題材として用意してみました。</p>
<figure>
<img src="images/00154.jpeg" />
<figcaption>空から降ってくるミサイルを撃ち落とす。家が全滅したらゲームオーバー</figcaption>
</figure>
<p>【使用している画像】</p>
<p>　本ゲームで使用している画像とその用途です。画像はどんな絵でもかまいません。Windowsに標準でついてくる「ペイント」で作ることもできますので、自分の好きな絵を作成して、世界で唯一のオリジナルゲームを作り上げてください。</p>
<figure>
<img src="images/00083.jpeg" />
<figcaption></figcaption>
</figure>
</section>
</div>
<div id="calibre_link-87">
<section>
<h2 id="calibre_link-329"><b>5-6-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>&lt;script type="text/javascript"&gt;</code>
<code>var houses = [], missiles = [], shoot, timer = NaN, count = 0, score = 0;</code>
<code></code>
<code>function House(x) {</code>
<code>    this.x = x;</code>
<code>    this.y = 550;</code>
<code>    this.w = 40;</code>
<code>    this.hit = false;</code>
<code>}</code>
<code></code>
<code>function Missle(){</code>
<code>    this.maxCount = 500;</code>
<code>    this.interval = 1000;</code>
<code></code>
<code>    this.reload = function(){</code>
<code>        this.sX = rand(800);</code>
<code>        this.eX = rand(800);</code>
<code>        this.interval = this.interval * 0.9;</code>
<code>        this.firetime = rand(this.interval) + count;</code>
<code>        this.x = 0;</code>
<code>        this.y = 0;</code>
<code>        this.r = 0;</code>
<code>    };</code>
<code></code>
<code>    this.draw = function(ctx){</code>
<code>        ctx.strokeStyle = ctx.fillStyle = 'rgb(0,255,255)';</code>
<code></code>
<code>        // 軌跡の描画</code>
<code>        line(ctx, this.sX, 0, this.x, this.y);</code>
<code></code>
<code>        // 爆発</code>
<code>        if(this.r &gt; 0){</code>
<code>            circle(ctx, this.x, this.y, this.r &lt; 50 ? this.r : (100 - this.r));</code>
<code>        }</code>
<code>    };</code>
<code></code>
<code>    this.reload();</code>
<code>}</code>
<code></code>
<code>function Shoot() {</code>
<code>    this.scopeX = 400;</code>
<code>    this.scopeY = 300;</code>
<code>    this.scopeW = 50;</code>
<code>    this.image = document.getElementById('scope');</code>
<code>    this.count = 0;</code>
<code>    this.shotX = 0;</code>
<code>    this.shotY = 0;</code>
<code>    this.shotR = 0;</code>
<code>    this.fire = false;</code>
<code>    this.draw = function (ctx) {</code>
<code>        ctx.strokeStyle = ctx.fillStyle = 'rgb(0,255,0)';</code>
<code></code>
<code>        // 照準器の描画</code>
<code>        ctx.drawImage(this.image,</code>
<code>            this.scopeX - this.scopeW / 2, this.scopeY - this.scopeW / 2);</code>
<code></code>
<code>        if (!this.fire) return;</code>
<code></code>
<code>        if (this.shotR == 0 &amp;&amp; this.count &lt; 100) {</code>
<code>            // 軌跡の描画</code>
<code>            var ratio = this.count / 100;</code>
<code></code>
<code>            var y = 600 - (600 - this.shotY) * ratio;</code>
<code></code>
<code>            // 左側レーザー</code>
<code>            line(ctx, 0, 600, (this.shotX * ratio), y);</code>
<code></code>
<code>            // 右側レーザー</code>
<code>            line(ctx, 800, 600, (800 - (800 - this.shotX) * ratio), y);</code>
<code></code>
<code>        } else if (this.shotR &gt; 0) {</code>
<code>            // 爆発</code>
<code>            circle(ctx, this.shotX, this.shotY, this.shotR);</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function rand(r) { return Math.floor(Math.random() * r) }</code>
<code></code>
<code>function explodeSound() {</code>
<code>    document.getElementById('explode').play();</code>
<code>}</code>
<code></code>
<code>function line(ctx, x0, y0, x1, y1) {</code>
<code>    ctx.beginPath();</code>
<code>    ctx.moveTo(x0, y0);</code>
<code>    ctx.lineTo(x1, y1);</code>
<code>    ctx.closePath();</code>
<code>    ctx.stroke();</code>
<code>}</code>
<code></code>
<code>function circle(ctx, x, y, r) {</code>
<code>    if (r &lt;= 0) return;</code>
<code>    ctx.beginPath();</code>
<code>    ctx.arc(x, y, r, 0, Math.PI * 2, true);</code>
<code>    ctx.fill();</code>
<code>}</code>
<code></code>
<code>function init() {</code>
<code>    shoot = new Shoot();</code>
<code></code>
<code>    var canvas = document.getElementById('canvas');</code>
<code>    ctx = canvas.getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code></code>
<code>    canvas.addEventListener('mousemove', mousemove);</code>
<code>    canvas.addEventListener('mousedown', mousedown);</code>
<code></code>
<code>    start();</code>
<code>}</code>
<code></code>
<code>function start() {</code>
<code>    score = 0;</code>
<code></code>
<code>    houses = [];</code>
<code>    for (var i = 0 ; i &lt; 13 ; i++) {</code>
<code>        houses.push(new House(i * 60 + 20));</code>
<code>    }</code>
<code></code>
<code>    missiles = [];</code>
<code>    for (var i = 0 ; i &lt; 8 ; i++) {</code>
<code>        missiles.push(new Missle());</code>
<code>    }</code>
<code></code>
<code>    timer = setInterval(mainLoop, 20);</code>
<code>}</code>
<code></code>
<code>function mainLoop() {</code>
<code>    count++;</code>
<code></code>
<code>    // 自分のミサイル発射時、その状態を更新</code>
<code>    if (shoot.fire) {</code>
<code>        shoot.count++;</code>
<code></code>
<code>        if (100 &lt;= shoot.count &amp;&amp; shoot.count &lt; 200) {</code>
<code>            shoot.shotR++;</code>
<code>        } else if (200 &lt;= shoot.count &amp;&amp; shoot.count &lt; 300) {</code>
<code>            shoot.shotR--;</code>
<code>        } else if (300 &lt;= shoot.count) {</code>
<code>            shoot.fire = false;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    // ミサイルの状態を更新</code>
<code>    missiles.forEach(function (m) {</code>
<code>        var c = count - m.firetime;</code>
<code>        if (c &lt; 0) {</code>
<code>            return;</code>
<code>        }</code>
<code>        if (m.r &gt; 0) { // 爆発</code>
<code>            if (m.r++ &gt; 100) {</code>
<code>                m.reload()</code>
<code>            }</code>
<code></code>
<code>        } else {</code>
<code>            // ミサイルの場所更新</code>
<code>            m.x = (m.eX - m.sX) * c / m.maxCount + m.sX;</code>
<code>            m.y = 600 * c / m.maxCount;</code>
<code></code>
<code>            // 自分の迎撃ミサイルとの衝突判定</code>
<code>            var dx = Math.pow(shoot.shotX - m.x, 2);</code>
<code>            var dy = Math.pow(shoot.shotY - m.y, 2);</code>
<code>            if ((dx + dy) &lt; Math.pow(shoot.shotR, 2)) {</code>
<code>                m.r = 1;</code>
<code>                score += 100;</code>
<code>                explodeSound();</code>
<code>                return;</code>
<code>            }</code>
<code></code>
<code>            // 地面に衝突時</code>
<code>            if (c &gt; m.maxCount) {</code>
<code></code>
<code>                // 家に衝突したか判定</code>
<code>                houses.forEach(function (house) {</code>
<code>                    if ((house.x + house.w &lt; m.x - 50) ||</code>
<code>                        (m.x + 50 &lt; house.x)) {</code>
<code>                    } else {</code>
<code>                        house.hit = true;</code>
<code>                    }</code>
<code>                });</code>
<code></code>
<code>                if (houses.every(function (house) {</code>
<code>                        return house.hit</code>
<code>                })) {</code>
<code>                    clearInterval(timer);</code>
<code>                    timer = NaN;</code>
<code>                }</code>
<code></code>
<code>                explodeSound();</code>
<code>                m.r = 1;</code>
<code>            }</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    draw();</code>
<code>}</code>
<code></code>
<code>function mousemove(e) {</code>
<code>    shoot.scopeX = e.clientX;</code>
<code>    shoot.scopeY = e.clientY;</code>
<code>}</code>
<code></code>
<code>function mousedown(e) {</code>
<code>    if (shoot.fire == false) {</code>
<code>        shoot.shotX = e.clientX;</code>
<code>        shoot.shotY = e.clientY;</code>
<code>        shoot.shotR = 0;</code>
<code>        shoot.count = 0;</code>
<code>        shoot.fire = true;</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function draw() {</code>
<code>    // 背景を塗りつぶし</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, 800, 600);</code>
<code></code>
<code>    // 家の描画</code>
<code>    houses.forEach(function (h) {</code>
<code>        ctx.drawImage(strip, (h.hit ? 20 : 0), 0, 20, 20, h.x, h.y, h.w, h.w);</code>
<code>    });</code>
<code></code>
<code>    // 自分のミサイルの描画</code>
<code>    shoot.draw(ctx);</code>
<code></code>
<code>    // 敵のミサイルの描画</code>
<code>    missiles.forEach(function (m) {</code>
<code>        if (m.x != 0 &amp;&amp; m.y != 0) {</code>
<code>            m.draw(ctx);</code>
<code>        }</code>
<code>    })</code>
<code></code>
<code>    // スコアの描画</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('00000' + score).slice(-5), 570, 30);</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 320, 150);</code>
<code>    }</code>
<code>}</code>
<code>&lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code>&lt;body onload="init();"&gt;</code>
<code>    &lt;canvas id="canvas" width="800" height="600"/&gt;</code>
<code>    &lt;img id="strip" src="strip.png" style="display:none;" /&gt;</code>
<code>    &lt;img id="scope" src="scope.png" style="display:none;" /&gt;</code>
<code>    &lt;audio id="explode" src="bomb.mp3"&gt;&lt;/audio&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-124">
<section>
<h2 id="calibre_link-330"><b>5-6-2　変数</b></h2>
<p>　使用している主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>houses = []</td>
  <td>Houseオブジェクト(家)を格納する配列</td>
</tr>
<tr>
  <td>missiles = []</td>
  <td>Missleオブジェクト（ミサイル）を格納する配列</td>
</tr>
<tr>
  <td>shoot</td>
  <td>Shootオブジェクト（自分のミサイル）</td>
</tr>
<tr>
  <td>timer = NaN</td>
  <td>タイマー</td>
</tr>
<tr>
  <td>count = 0</td>
  <td>メインループ1回を1とする時間管理用変数</td>
</tr>
<tr>
  <td>score = 0;</td>
  <td>現在のスコア</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00008.jpeg" />
<figcaption>ミサイルコマンドの主な変数</figcaption>
</figure>
<p>　このゲームでは、何時ミサイルが発射されるのか、爆発が始まっているところか、爆発が収束しているところかなどをメインループの実行回数を基準に制御しています。</p>
<p>　そのメインループの実行回数をグローバル変数countに保存しておき、それぞれのオブジェクトではそのcount値と自分のプロパティを比較することでいろいろな判断を行っています。</p>
<p>　たとえば、Missleが落ちてくるタイミングは事前に乱数で決めています。そのイメージを以下の図に示します。</p>
<figure>
<img src="images/00106.jpeg" />
<figcaption>Missleが落ちてくるタイミングの設定イメージ</figcaption>
</figure>
<p>　countはゲームの世界の時間を簡易的に表す変数と考えてください。</p>
</section>
</div>
<div id="calibre_link-83">
<section>
<h2 id="calibre_link-331"><b>5-6-3　オブジェクト</b></h2>
<h3 id="calibre_link-332">■Houseオブジェクト</h3>
<p>　家の状態を管理するオブジェクトです。xとyが座標、wが幅、hitはミサイルで破壊されたか否かを示しています。</p>
<p>Houseオブジェクト</p>
<pre>
<code>function House(x) {</code>
<code>    this.x = x;</code>
<code>    this.y = 550;</code>
<code>    this.w = 40;</code>
<code>    this.hit = false;</code>
<code>}</code>
</pre>
<h3 id="calibre_link-333">■Missleオブジェクト</h3>
<p>　空から落ちてくるミサイルを表すオブジェクトです。</p>
<p>Missleオブジェクト</p>
<pre>
<code>function Missle(){</code>
<code>    this.maxCount = 500;</code>
<code>    this.interval = 1000;</code>
<code></code>
<code>    this.reload = function(){</code>
<code>        this.sX = rand(800);</code>
<code>        this.eX = rand(800);</code>
<code>        this.interval = this.interval * 0.9;</code>
<code>        this.firetime = rand(this.interval) + count;</code>
<code>        this.x = 0;</code>
<code>        this.y = 0;</code>
<code>        this.r = 0;</code>
<code>    };</code>
<code></code>
<code>    this.draw = function(ctx){</code>
<code>        ctx.strokeStyle = ctx.fillStyle = 'rgb(0,255,255)';</code>
<code></code>
<code>        // 軌跡の描画</code>
<code>        line(ctx, this.sX, 0, this.x, this.y);</code>
<code></code>
<code>        // 爆発</code>
<code>        if(this.r &gt; 0){</code>
<code>            circle(ctx, this.x, this.y, this.r &lt; 50 ? this.r : (100 - this.r));</code>
<code>        }</code>
<code>    };</code>
<code></code>
<code>    this.reload();</code>
<code>}</code>
</pre>
<p>　maxCountはミサイルが落ちてきてから地上に墜落するまでにかかる時間（mainLoopが実行される回数）です。</p>
<figure>
<img src="images/00029.jpeg" />
<figcaption>ミサイルが地上に墜落するまでにかかる時間</figcaption>
</figure>
<p>　intervalは一度地上に落下したミサイルが次にどのくらいのタイミングで再度落ちてくるかを調整するパラメータです。次に発射する時刻を「rand(this.interval) + count;」で求めています。</p>
<figure>
<img src="images/00128.jpeg" />
<figcaption>次にミサイルが落ちてくるタイミング</figcaption>
</figure>
<p>　sXは落下開始場所の座標、eXは落下地点の座標です。それぞれ乱数で求めています。(x, y)は現在のミサイルの座標、rは爆発時の半径です。</p>
<figure>
<img src="images/00057.jpeg" />
<figcaption>落下開始場所と落下地点</figcaption>
</figure>
<p>　drawメソッドは、ミサイルの軌跡と爆発時にはその円を描画します。オブジェクト作成時、すなわちnew Missle()と呼ばれたときに、「this.reload();」と自分のメソッドを呼び出すことでミサイルの初期化を行っています。</p>
<h3 id="calibre_link-334">■Shootオブジェクト</h3>
<p>　自分の発射したミサイルを管理するオブジェクトです。</p>
<p>Shootオブジェクト</p>
<pre>
<code>function Shoot() {</code>
<code>    this.scopeX = 400;</code>
<code>    this.scopeY = 300;</code>
<code>    this.scopeW = 50;</code>
<code>    this.image = document.getElementById('scope');</code>
<code>    this.count = 0;</code>
<code>    this.shotX = 0;</code>
<code>    this.shotY = 0;</code>
<code>    this.shotR = 0;</code>
<code>    this.fire = false;</code>
<code>    this.draw = function (ctx) {</code>
<code>        ctx.strokeStyle = ctx.fillStyle = 'rgb(0,255,0)';</code>
<code></code>
<code>        // 照準器の描画</code>
<code>        ctx.drawImage(this.image,</code>
<code>            this.scopeX - this.scopeW / 2, this.scopeY - this.scopeW / 2);</code>
<code></code>
<code>        if (!this.fire) return;</code>
<code></code>
<code>        if (this.shotR == 0 &amp;&amp; this.count &lt; 100) {</code>
<code>            // 軌跡の描画</code>
<code>            var ratio = this.count / 100;</code>
<code></code>
<code>            var y = 600 - (600 - this.shotY) * ratio;</code>
<code></code>
<code>            // 左側レーザー</code>
<code>            line(ctx, 0, 600, (this.shotX * ratio), y);</code>
<code></code>
<code>            // 右側レーザー</code>
<code>            line(ctx, 800, 600, (800 - (800 - this.shotX) * ratio), y);</code>
<code></code>
<code>        } else if (this.shotR &gt; 0) {</code>
<code>            // 爆発</code>
<code>            circle(ctx, this.shotX, this.shotY, this.shotR);</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　scopeX、scopeY、scopeWは自分の照準器の場所と幅を保持するプロパティです。</p>
<p>　imageは照準器の画像です。</p>
<p>　countプロパティは自分のミサイルが発射されてからの経過時間です。グローバル変数のcountとは別の値であることに注意してください。</p>
<p>　shotX、shotYは自分が発射したミサイルの標的となる座標です。</p>
<p>　shotRは爆発時の半径です。</p>
<p>　fireはミサイル発射中か否かを保持するフラグです。</p>
<p>　drawメソッドは、照準器の画像をdrawImageで描画し、発射中でなければ（!this.fire）、メソッドからreturnで抜けます。それ以外の場合は、ミサイルの軌跡を描画中と爆発中で挙動が異なります。その条件判断を</p>
<p>
<br />
</p>
<pre>
<code>this.shotR == 0 &amp;&amp; this.count &lt; 100</code>
</pre>
<p>という式で行っています。爆発時半径が0で発射してから100カウント以内であれば、ミサイルが迎撃中として、軌跡を描画しています。左右から発射している様子を2つのline関数を使って描画しています。</p>
</section>
</div>
<div id="calibre_link-35">
<section>
<h2 id="calibre_link-335"><b>5-6-4　関数</b></h2>
<p>　いくつかユーティリティ的な関数を定義しています。</p>
<p>rand関数、line関数、circle関数</p>
<pre>
<code>function rand(r) { return Math.floor(Math.random() * r) }</code>
<code></code>
<code>function explodeSound() {</code>
<code>    document.getElementById('explode').play();</code>
<code>}</code>
<code></code>
<code>function line(ctx, x0, y0, x1, y1) {</code>
<code>    ctx.beginPath();</code>
<code>    ctx.moveTo(x0, y0);</code>
<code>    ctx.lineTo(x1, y1);</code>
<code>    ctx.closePath();</code>
<code>    ctx.stroke();</code>
<code>}</code>
<code></code>
<code>function circle(ctx, x, y, r) {</code>
<code>    if (r &lt;= 0) return;</code>
<code>    ctx.beginPath();</code>
<code>    ctx.arc(x, y, r, 0, Math.PI * 2, true);</code>
<code>    ctx.fill();</code>
<code>}</code>
</pre>
<p>　rand(r)は0～rまでの乱数を返します。</p>
<p>　explodeSound()は爆発音を鳴らします。</p>
<p>　line(ctx, x0, y0, x1, y1)は、(x0, y0)から(x1, y1)へ線を描画します。</p>
<p>　circle(ctx, x, y, r)は、(x, y)を中心座標とする半径rの円を描画します。</p>
<h3 id="calibre_link-336">■init()関数</h3>
<p>　init()は文書が読み込まれたときに実行される初期化用関数です。Shootオブジェクトの作成、コンテキストctxの取得とフォント設定、'mousemove'や'mousedown'といったイベントハンドラーを登録して、最後にstart()を呼び出しています。</p>
<p>init()関数</p>
<pre>
<code>function init() {</code>
<code>    shoot = new Shoot();</code>
<code></code>
<code>    var canvas = document.getElementById('canvas');</code>
<code>    ctx = canvas.getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code></code>
<code>    canvas.addEventListener('mousemove', mousemove);</code>
<code>    canvas.addEventListener('mousedown', mousedown);</code>
<code></code>
<code>    start();</code>
<code>}</code>
<code></code>
<code>function start() {</code>
<code>    score = 0;</code>
<code></code>
<code>    houses = [];</code>
<code>    for (var i = 0 ; i &lt; 13 ; i++) {</code>
<code>        houses.push(new House(i * 60 + 20));</code>
<code>    }</code>
<code></code>
<code>    missiles = [];</code>
<code>    for (var i = 0 ; i &lt; 8 ; i++) {</code>
<code>        missiles.push(new Missle());</code>
<code>    }</code>
<code></code>
<code>    timer = setInterval(mainLoop, 20);</code>
<code>}</code>
</pre>
<p>　start()は実質的にゲームの初期化を行う関数です。スコアを初期化し、Houseオブジェクトを作り、houses配列に格納し、Missleオブジェクトを作り、missiles配列に格納し、setIntervalでmainLoopをスタートさせています。</p>
<h3 id="calibre_link-337">■メインループ</h3>
<p>　mainLoop()がゲームのメインループです。長いので分割して説明します。</p>
<p>mainLoop()関数1</p>
<pre>
<code>function mainLoop() {</code>
<code>    count++;</code>
<code></code>
<code>    // 自分のミサイル発射時、その状態を更新</code>
<code>    if (shoot.fire) {</code>
<code>        shoot.count++;</code>
<code></code>
<code>        if (100 &lt;= shoot.count &amp;&amp; shoot.count &lt; 200) {</code>
<code>            shoot.shotR++;</code>
<code>        } else if (200 &lt;= shoot.count &amp;&amp; shoot.count &lt; 300) {</code>
<code>            shoot.shotR--;</code>
<code>        } else if (300 &lt;= shoot.count) {</code>
<code>            shoot.fire = false;</code>
<code>        }</code>
<code>    }</code>
</pre>
<p>　まず、count++でゲームの世界の時計を1つ進めます。自分のミサイルが発射中であれば、その状態を更新します。</p>
<p>　発射してから100以上で200未満（100 &lt;= shoot.count &amp;&amp; shoot.count &lt; 200）のときは、爆発半径を増加させています。</p>
<p>　200以上で300未満（200 &lt;= shoot.count &amp;&amp; shoot.count &lt; 300）のときは、爆発半径を減少させています。</p>
<p>　300以上になったときはfireプロパティをfalseにして、発射状態を解除しています。</p>
<p>　次はミサイルの状態を更新します。</p>
<p>mainLoop()関数2</p>
<pre>
<code>// ミサイルの状態を更新</code>
<code>missiles.forEach(function (m) {</code>
<code>    var c = count - m.firetime;</code>
<code>    if (c &lt; 0) {</code>
<code>        return;</code>
<code>    }</code>
<code>    if (m.r &gt; 0) { // 爆発</code>
<code>        if (m.r++ &gt; 100) {</code>
<code>            m.reload()</code>
<code>        }</code>
<code></code>
<code>    } else {</code>
</pre>
<p>　「var c = count - m.firetime」で現在時刻とミサイル発射時刻の差を求めています。この値が負であれば、ミサイル発射前なので、コールバック関数をreturnで抜けます。正の場合、cは発射からの経過時間を表すことになります。</p>
<p>　m.rが0よりも大きい場合、ミサイルが爆発していることになるので、その半径rを増やしていきます。rが100を超えたときに爆発を終了とみなして、次の発射時刻を設定するreload()を呼び出しています。</p>
<p>　ここで、処理を簡略化するためにrが0～50のときは爆発半径を増加させ、50～100のときは半径を減少させるように描画しています。詳しくはMissleオブジェクトのdrawメソッドをご覧ください。</p>
<p>　次に、ミサイルの座標を求めています。</p>
<p>mainLoop()関数3</p>
<pre>
<code>        } else {</code>
<code>            // ミサイルの場所更新</code>
<code>            m.x = (m.eX - m.sX) * c / m.maxCount + m.sX;</code>
<code>            m.y = 600 * c / m.maxCount;</code>
<code></code>
<code>            // 自分の迎撃ミサイルとの衝突判定</code>
<code>            var dx = Math.pow(shoot.shotX - m.x, 2);</code>
<code>            var dy = Math.pow(shoot.shotY - m.y, 2);</code>
<code>            if (dx + dy &lt; Math.pow(shoot.shotR, 2)) {</code>
<code>                m.r = 1;</code>
<code>                score += 100;</code>
<code>                explodeSound();</code>
<code>                return;</code>
<code>            }</code>
</pre>
<p>　落下開始から着地するまでの時間がmaxCount、発射から経過時間がcです。eXが落下開始場所、sXが着地場所、これらの情報を使ってm.xとm.yを求めています。次の図を見るとわかりやすいかもしれません。</p>
<figure>
<img src="images/00153.jpeg" />
<figcaption>eXが落下開始場所、sXが着地場所</figcaption>
</figure>
<p>　そのあとで、自分の迎撃ミサイルと敵のミサイルが衝突状態にあるか判定しています。一見難しそうに見えますが、行っていることは単なるピタゴラスの定理の計算です。</p>
<p>　Math.powはべき乗を計算する関数です。第1引数を第2引数回掛け算します。つまり、</p>
<p>
<br />
</p>
<pre>
<code>Math.pow(shoot.shotX - m.x, 2);</code>
</pre>
<p>は自分のミサイルの発射位置と敵のミサイルの現在位置のx座標の差分の自乗となります。同様に</p>
<p>
<br />
</p>
<pre>
<code>Math.pow(shoot.shotY - m.y, 2)</code>
</pre>
<p>はy座標の差分の自乗です。これを、自分のミサイルの爆発半径の自乗と比較することで、敵ミサイルと衝突しているか判定ができることになります。</p>
<figure>
<img src="images/00082.jpeg" />
<figcaption>衝突していない場合の爆発半径</figcaption>
</figure>
<figure>
<img src="images/00006.jpeg" />
<figcaption>衝突している場合の爆発半径</figcaption>
</figure>
<p>　衝突判定はゲームで非常によく利用されます。ぜひ、押さえておいてください。</p>
<p>　この関数の最後は地面に敵ミサイルが衝突したときの処理です。</p>
<p>mainLoop()関数4</p>
<pre>
<code>            // 地面に衝突時</code>
<code>            if (c &gt; m.maxCount) {</code>
<code></code>
<code>                // 家に衝突したか判定</code>
<code>                houses.forEach(function (house) {</code>
<code>                    if ((house.x + house.w &lt; m.x - 50) ||</code>
<code>                        (m.x + 50 &lt; house.x)) {</code>
<code>                    } else {</code>
<code>                        house.hit = true;</code>
<code>                    }</code>
<code>                });</code>
<code></code>
<code>                if (houses.every(function (house) {</code>
<code>                        return house.hit</code>
<code>                })) {</code>
<code>                    clearInterval(timer);</code>
<code>                    timer = NaN;</code>
<code>                }</code>
<code></code>
<code>                explodeSound();</code>
<code>                m.r = 1;</code>
<code>            }</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    draw();</code>
<code>}</code>
</pre>
<p>　地面に衝突したとき、すなわち敵ミサイル落下からの時間がmaxCountを超えたとき、houses.forEach()を使って、家に衝突したかどうかを判定します。Houseオブジェクトのxプロパティとwプロパティ、敵ミサイルのx座標を比較しているだけです。衝突している場合はHouseオブジェクトのhitプロパティをtrueに設定します。</p>
<p>　houses.every()はすべてのコールバックでtrueを返した場合のみ真を返します。すなわち、全部のHouseオブジェクトのhitプロパティがtrueの場合に真が返ります。その場合は、clearIntervalでタイマーを停止します。</p>
<p>　あとは、爆発音を鳴らして、敵ミサイルの爆発半径を1に設定します。最後にdraw()で画面を描画して、この関数を終了します。</p>
<h3 id="calibre_link-338">■mousemove関数、mousedown関数</h3>
<p>mousemoveとmousedownはマウスイベントの処理を行います。</p>
<p>mousemove関数、mousedown関数</p>
<pre>
<code>function mousemove(e) {</code>
<code>    shoot.scopeX = e.clientX;</code>
<code>    shoot.scopeY = e.clientY;</code>
<code>}</code>
<code></code>
<code>function mousedown(e) {</code>
<code>    if (shoot.fire == false) {</code>
<code>        shoot.shotX = e.clientX;</code>
<code>        shoot.shotY = e.clientY;</code>
<code>        shoot.shotR = 0;</code>
<code>        shoot.count = 0;</code>
<code>        shoot.fire = true;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　mousemoveは現在のマウスの位置に照準器を移動させます。mousedownはマウス押下時の処理を行います。現在発射中でない場合、自分のShootオブジェクトを現在のマウス位置で初期化し、fireプロパティをtrueに設定します。</p>
<h3 id="calibre_link-339">■draw()関数</h3>
<p>　最後に描画用のイベントです。ソースコード中にコメントがあるので、それを参考に読み進めてください。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // 背景を塗りつぶし</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, 800, 600);</code>
<code></code>
<code>    // 家の描画</code>
<code>    houses.forEach(function (h) {</code>
<code>        ctx.drawImage(strip, (h.hit ? 20 : 0), 0, 20, 20, h.x, h.y, h.w, h.w);</code>
<code>    });</code>
<code></code>
<code>    // 自分のミサイルの描画</code>
<code>    shoot.draw(ctx);</code>
<code></code>
<code>    // 敵のミサイルの描画</code>
<code>    missiles.forEach(function (m) {</code>
<code>        if (m.x != 0 &amp;&amp; m.y != 0) {</code>
<code>            m.draw(ctx);</code>
<code>        }</code>
<code>    })</code>
<code></code>
<code>    // スコアの描画</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('00000' + score).slice(-5), 570, 30);</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 320, 150);</code>
<code>    }</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-187">
<section>
<hgroup>
<h1 id="calibre_link-179"><b>5-7　全方位スクロールゲーム</b></h1>
</hgroup>
<p>　上下左右キーで宇宙船を操り、スペースキーでミサイルを発射するアステロイド風ゲームです。隕石にぶつからないように全部を撃破するとステージクリアです。</p>
<p>　アステロイドは1979年にアタリが発売したゲームです。全方位にスクロールするゲームで当時のゲームとしては一風変わったジャンルでした。オリジナルはベクターを使ったシンプルなものでしたが、画像をCanvasのrotateを使って回転させることで、スムーズな全方位スクロールを実現しています。Canvasの応用例として参照していただければと思います。</p>
<figure>
<img src="images/00104.jpeg" />
<figcaption>宇宙船からミサイルを発射して隕石を破壊。宇宙船が隕石にあたるとゲームオーバー</figcaption>
</figure>
<p>【使用している画像】</p>
<p>　本ゲームで使用している画像とその用途です。画像はどんな絵でもかまいません。Windowsに標準でついてくる「ペイント」で作ることもできますので、自分の好きな絵を作成して、世界で唯一のオリジナルゲームを作り上げてください。</p>
<figure>
<img src="images/00028.jpeg" />
</figure>
<p>
<br />
</p>
<figure>
<img src="images/00126.jpeg" />
<figcaption></figcaption>
</figure>
</section>
</div>
<div id="calibre_link-106">
<section>
<h2 id="calibre_link-340"><b>5-7-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Asteroid&lt;/title&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var ctx, ship, shots = [], rocks = [], level = 1,</code>
<code>        score = 0, clock = 0, timer = NaN, bgX = 0, bgY = 0;</code>
<code></code>
<code>    function Rock(x, y, s) {</code>
<code>        this.cx = x;</code>
<code>        this.cy = y;</code>
<code>        this.w = s;</code>
<code>        this.h = s;</code>
<code>        var a = Math.random() * Math.PI * 2;</code>
<code>        this.dx = Math.floor(Math.cos(a) * (128 / s));</code>
<code>        this.dy = Math.floor(Math.sin(a) * (128 / s));</code>
<code>        this.image = document.getElementById('rock');</code>
<code>    }</code>
<code></code>
<code>    function Shot() {</code>
<code>        this.cx = 0;</code>
<code>        this.cy = 0;</code>
<code>        this.w = 6;</code>
<code>        this.h = 6;</code>
<code>        this.dx = 0;</code>
<code>        this.dy = 0;</code>
<code>        this.count = this.maxCount;</code>
<code>        this.power = 10;</code>
<code>        this.maxCount = 40;</code>
<code>    }</code>
<code></code>
<code>    function Ship() {</code>
<code>        this.cx = 400;</code>
<code>        this.cy = 400;</code>
<code>        this.w = 90;</code>
<code>        this.h = 60;</code>
<code>        this.dx = 0;</code>
<code>        this.dy = 0;</code>
<code>        this.rotate = 0;</code>
<code>        this.power = 0;</code>
<code>        this.accel = 0;</code>
<code></code>
<code>        this.keyL = false;</code>
<code>        this.keyR = false;</code>
<code>        this.keyF = false;</code>
<code>        this.keyB = false;</code>
<code></code>
<code>        this.image = document.getElementById('ship');</code>
<code>    }</code>
<code></code>
<code>    Shot.prototype = Ship.prototype = Rock.prototype = {</code>
<code>        getX: function () { return this.cx - this.w / 2; },</code>
<code>        getY: function () { return this.cy - this.h / 2; },</code>
<code>        isHit: function (o) {</code>
<code>            return !(((o.getX() + o.w) &lt; this.getX()) ||</code>
<code>                ((this.getX() + this.w) &lt; o.getX()) ||</code>
<code>                ((o.getY() + o.h) &lt; this.getY()) ||</code>
<code>                ((this.getY() + this.h) &lt; o.getY()));</code>
<code>        },</code>
<code>        update: function () {</code>
<code>            this.cx = (this.cx + this.dx + 800) % 800;</code>
<code>            this.cy = (this.cy + this.dy + 800) % 800;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function rand(r) { return Math.floor(Math.random() * r) }</code>
<code></code>
<code>    function init() {</code>
<code>        ctx = document.getElementById('canvas').getContext('2d');</code>
<code>        ctx.font = "20pt Arial";</code>
<code></code>
<code>        ship = new Ship();</code>
<code></code>
<code>        // 弾丸の初期化</code>
<code>        for (var i = 0 ; i &lt; 7 ; i++) {</code>
<code>            shots.push(new Shot());</code>
<code>        }</code>
<code></code>
<code>        // キーイベントハンドラーの初期化</code>
<code>        window.addEventListener('keydown', function (e) {</code>
<code>            switch (e.keyCode) {</code>
<code>                case 37: ship.keyL = true; break;</code>
<code>                case 38: ship.keyF = true; break;</code>
<code>                case 39: ship.keyR = true; break;</code>
<code>                case 40: ship.keyB = true; break;</code>
<code>                case 32: ship.keyH = true; break;</code>
<code>            }</code>
<code>        });</code>
<code>        window.addEventListener('keyup', function (e) {</code>
<code>            switch (e.keyCode) {</code>
<code>                case 37: ship.keyL = false; break;</code>
<code>                case 38: ship.keyF = false; break;</code>
<code>                case 39: ship.keyR = false; break;</code>
<code>                case 40: ship.keyB = false; break;</code>
<code>                case 32: ship.keyH = false; break;</code>
<code>            }</code>
<code>        });</code>
<code></code>
<code>        start();</code>
<code></code>
<code>        if (isNaN(timer)) {</code>
<code>            timer = setInterval(mainLoop, 50);</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function start() {</code>
<code>        rocks = [];</code>
<code></code>
<code>        // 岩の初期化</code>
<code>        for (var i = 0 ; i &lt; level ; i++) {</code>
<code>            var x = rand(800), y = rand(800);</code>
<code>            while (true) {</code>
<code>                var r = new Rock(x, y, 64);</code>
<code>                if (!r.isHit(ship)) {</code>
<code>                    rocks.push(r);</code>
<code>                    break;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function mainLoop() {</code>
<code>        clock++;</code>
<code></code>
<code>        if (rocks.length == 0) {</code>
<code>            if (clock &gt; 100) {</code>
<code>                level++;</code>
<code>                start();</code>
<code>            }</code>
<code>            return;</code>
<code>        }</code>
<code></code>
<code>        // 船の場所・向きを更新</code>
<code>        if (ship.keyL) { ship.rotate -= 0.1; }</code>
<code>        if (ship.keyR) { ship.rotate += 0.1; }</code>
<code>        if (ship.keyF) { ship.accel = Math.min(+5, ship.accel + 0.2); }</code>
<code>        if (ship.keyB) { ship.accel = Math.max(-5, ship.accel - 0.1); }</code>
<code></code>
<code>        ship.power += ship.accel;</code>
<code>        ship.power *= 0.94;</code>
<code>        ship.accel *= 0.94;</code>
<code>        ship.dx = Math.cos(ship.rotate) * ship.power;</code>
<code>        ship.dy = Math.sin(ship.rotate) * ship.power;</code>
<code>        ship.update();</code>
<code></code>
<code>        bgX = (bgX + ship.dx / 2 + 1600) % 800;</code>
<code>        bgY = (bgY + ship.dy / 2 + 1600) % 800;</code>
<code></code>
<code>        // 弾丸の位置を更新</code>
<code>        var fire = false;</code>
<code>        shots.forEach(function (shot) {</code>
<code>            if (shot.count &lt; shot.maxCount) {</code>
<code>                shot.count++;</code>
<code>                shot.update();</code>
<code></code>
<code>                // 衝突検出</code>
<code>                var hit = -1, r = NaN;</code>
<code>                rocks.forEach(function (rock, i) {</code>
<code>                    if (rock.isHit(shot)) {</code>
<code>                        hit = i;</code>
<code>                        r = rock;</code>
<code>                    }</code>
<code>                });</code>
<code></code>
<code>                // 弾丸が岩に衝突</code>
<code>                if (hit &gt;= 0) {</code>
<code>                    rocks.splice(hit, 1);</code>
<code></code>
<code>                    score += (64 / r.w) * 10;</code>
<code>                    shot.count = shot.maxCount;</code>
<code></code>
<code>                    r.w /= 2;</code>
<code>                    if (r.w &gt;= 16) {</code>
<code>                        for (var i = 0 ; i &lt; 2 ; i++) {</code>
<code>                            rocks.push(new Rock(r.cx, r.cy, r.w));</code>
<code>                        }</code>
<code>                    }</code>
<code></code>
<code>                    // ステージクリア</code>
<code>                    if (rocks.length == 0) {</code>
<code>                        clock = 0;</code>
<code>                        draw();</code>
<code>                    }</code>
<code>                }</code>
<code>            }</code>
<code>            else if (!fire &amp;&amp; ship.keyH) {</code>
<code>                shot.count = 0;</code>
<code>                shot.cx = ship.cx;</code>
<code>                shot.cy = ship.cy;</code>
<code>                shot.r = ship.rotate;</code>
<code>                shot.dx = ship.dx + shot.power * Math.cos(shot.r);</code>
<code>                shot.dy = ship.dy + shot.power * Math.sin(shot.r);</code>
<code>                fire = true;</code>
<code>            }</code>
<code>        });</code>
<code></code>
<code>        // 岩の場所を更新</code>
<code>        rocks.forEach(function (rock) {</code>
<code>            rock.update();</code>
<code></code>
<code>            if (ship.isHit(rock)) {</code>
<code>                clearInterval(timer);</code>
<code>                timer = NaN;</code>
<code>            }</code>
<code>        });</code>
<code></code>
<code>        draw();</code>
<code>    }</code>
<code></code>
<code>    function draw() {</code>
<code>        // 背景を描画</code>
<code>        ctx.drawImage(bg, bgX, bgY, 400, 400, 0, 0, 800, 800);</code>
<code></code>
<code>        // 弾丸の描画</code>
<code>        ctx.fillStyle = 'rgb(0,255,255)';</code>
<code>        shots.forEach(function (shot) {</code>
<code>            if (shot.count &lt; shot.maxCount) {</code>
<code>                ctx.fillRect(shot.getX(), shot.getY(), shot.w, shot.h);</code>
<code>            }</code>
<code>        });</code>
<code></code>
<code>        // 岩の描画</code>
<code>        rocks.forEach(function (rock) {</code>
<code>            ctx.drawImage(rock.image, rock.getX(), rock.getY(), rock.w, rock.h);</code>
<code>        });</code>
<code></code>
<code>        // 船の描画</code>
<code>        ctx.save();</code>
<code>        ctx.translate(ship.cx, ship.cy);</code>
<code>        ctx.rotate(ship.rotate);</code>
<code>        ctx.drawImage(ship.image, -ship.w / 2, -ship.h / 2);</code>
<code>        ctx.restore();</code>
<code></code>
<code>        // スコアの描画</code>
<code>        ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>        ctx.fillText(('0000000' + score).slice(-7), 670, 30);</code>
<code></code>
<code>        if (rocks.length == 0) {</code>
<code>            ctx.fillText('STAGE CLEAR', 300, 150);</code>
<code>        }</code>
<code></code>
<code>        if (isNaN(timer)) {</code>
<code>            ctx.fillText('GAME OVER', 320, 150);</code>
<code>            ctx.drawImage(bang, ship.getX() - 50, ship.getY() - 50, 200, 200);</code>
<code>        }</code>
<code>    }</code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;div&gt;</code>
<code>    &lt;canvas id="canvas" width="800" height="800"&gt;&lt;/canvas&gt;</code>
<code>&lt;/div&gt;</code>
<code>&lt;img id="ship" src="ship.png" style="display:none;" /&gt;</code>
<code>&lt;img id="bg" src="bg.png" style="display:none;" /&gt;</code>
<code>&lt;img id="rock" src="rock.png" style="display:none;" /&gt;</code>
<code>&lt;img id="bang" src="bang.png" style="display:none;" /&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-46">
<section>
<h2 id="calibre_link-341"><b>5-7-2　変数</b></h2>
<p>　使用している主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>ship</td>
  <td>自機のオブジェクト</td>
</tr>
<tr>
  <td>shots</td>
  <td>個々の弾丸オブジェクトShotを格納する配列</td>
</tr>
<tr>
  <td>rocks</td>
  <td>岩オブジェクトRockを格納する配列</td>
</tr>
<tr>
  <td>level</td>
  <td>現在何ステージ目かを管理する変数</td>
</tr>
<tr>
  <td>score</td>
  <td>現在のスコア</td>
</tr>
<tr>
  <td>clock</td>
  <td>このゲームでの時間。mainLoopを実行するたびに1増加する</td>
</tr>
<tr>
  <td>bgX, bgY</td>
  <td>背景画像を描画する際にそのx,y座標を保持する変数</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00053.jpeg" />
<figcaption>Asteroidの主な変数</figcaption>
</figure>
<p>　ゲームを実行してみると気づいたかもしれませんが、背景はスムーズに動き、どこまで進んでも途切れる感じがしません。なぜでしょうか？</p>
<p>　そのわけは4枚の画像を組み合わせて作った背景画像です。自機の移動に合わせて背景画像の描画する領域を移動させていますが、1画像分進むと元に戻しているのです。</p>
<p>　例を見てみましょう。スタート地点は左上です。右に進んでいき、1画面分進むと、スタート地点に戻るようにしていますが、4枚の画像を組み合わせているため途切れた感じがあまりしないのです。このように画面の左右、もしくは上下を繋ぎ合わせた背景はシンプルなゲームでよく用いられます。ちょっとした小技として覚えておくとよいでしょう。</p>
<figure>
<img src="images/00149.jpeg" />
<figcaption>1画面分進むと、スタート地点に戻る</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-69">
<section>
<h2 id="calibre_link-342"><b>5-7-3　オブジェクト</b></h2>
<p>　このゲームでは、Rock、Shot、Shipという3つのオブジェクトを使用しています。それぞれ、同じprototypeオブジェクトを参照しています。その様子を次の図に示します。</p>
<figure>
<img src="images/00136.jpeg" />
<figcaption>Asteroidのオブジェクト</figcaption>
</figure>
<p>　それぞれのオブジェクトには、</p>
<ul>
<li>cx, cy ＝ 中心座標</li>
<li>w, h ＝ 矩形の幅と高さ</li>
<li>dx, dy ＝ 移動量</li>
</ul>
<p>という共通した特徴があります。</p>
<figure>
<img src="images/00005.jpeg" />
<figcaption>各オブジェクト共通</figcaption>
</figure>
<p>　prototypeでは、その特徴を使って、getX、getY、isHit、updateというメソッドを実装しています。</p>
<p>　getXとgetYは矩形の左上座標を取得するためものです。</p>
<p>　isHitはほかのオブジェクトとの衝突を調べます。</p>
<p>　updateはオブジェクトの位置を更新します。</p>
<p>　%演算子を使って、範囲外にはみ出さないようにしています。</p>
<h3 id="calibre_link-343">■isHit</h3>
<p>　isHitについては少し詳しく見てみましょう。2つの矩形領域が重なっているか否かを判定するのは、いろんなケースを想定する必要があるため、思ったより面倒な処理となります。そこで、!演算子を使って、「!（重なっていない条件）」を求めることにしました。以下のようにShip(this)とRock(o)の衝突を調べる状況を考えてみます。</p>
<figure>
<img src="images/00102.jpeg" />
<figcaption>Ship(this)とRock(o)の衝突</figcaption>
</figure>
<p>　重なっていないためには、以下の条件のどれかが成立していればよいことになります。</p>
<ul>
<li>条件1：(o.getX() + o.w) &lt; this.getX() ...... Rockの右端がShipの左端より小</li>
<li>条件2：(this.getX() + this.w) &lt; o.getX() ...... Shipの右端よりのRock左端のほうが大</li>
<li>条件3：(o.getY() + o.h) &lt; this.getY() ...... Rockの下端よりShipの上端のほうが大</li>
<li>条件4：(this.getY() + this.h) &lt; o.getY() ...... Shipの下端よりRockの上端のほうが大</li>
</ul>
<p>　逆に、重なっているということは「! (条件1||条件2||条件3||条件4)」が衝突条件となります。</p>
<h3 id="calibre_link-344">■Rockオブジェクト</h3>
<p>　Rockオブジェクトは以下の通りです。</p>
<p>Rockオブジェクト</p>
<pre>
<code>function Rock(x, y, s) {</code>
<code>    this.cx = x;</code>
<code>    this.cy = y;</code>
<code>    this.w = s;</code>
<code>    this.h = s;</code>
<code>    var a = Math.random() * Math.PI * 2;</code>
<code>    this.dx = Math.floor(Math.cos(a) * (128 / s));</code>
<code>    this.dy = Math.floor(Math.sin(a) * (128 / s));</code>
<code>    this.image = document.getElementById('rock');</code>
<code>}</code>
</pre>
<p>　cx,cyは中心座標、w,hは幅と高さ、aは進行方向、dx,dyは移動量、imageは画像への参照です。移動量に(128 / s)をかけることで小さいほどスピードが出るようにしています。</p>
<h3 id="calibre_link-345">■Shotオブジェクト</h3>
<p>　Shotオブジェクトは以下の通りです。ほかのオブジェクトと共通部分の説明は省略します。</p>
<p>Shotオブジェクト</p>
<pre>
<code>function Shot() {</code>
<code>    this.cx = 0;</code>
<code>    this.cy = 0;</code>
<code>    this.w = 6;</code>
<code>    this.h = 6;</code>
<code>    this.dx = 0;</code>
<code>    this.dy = 0;</code>
<code>    this.count = this.maxCount;</code>
<code>    this.power = 10;</code>
<code>    this.maxCount = 40;</code>
<code>}</code>
</pre>
<p>　Shotは一定距離を過ぎると消滅するようにしています。その最大距離をmaxCount、現在の距離をcountに保持しています。発射されたときにcountを0にセットし、mainLoopを実行するたびに増加させます。その値がmaxCountになると弾丸を停止させます。</p>
<p>　powerは弾丸のスピードです。</p>
<h3 id="calibre_link-346">■Shipオブジェクト</h3>
<p>　Shipオブジェクトは以下の通りです。ほかのオブジェクトと共通部分の説明は省略します。</p>
<p>Shipオブジェクト</p>
<pre>
<code>function Ship() {</code>
<code>    this.cx = 400;</code>
<code>    this.cy = 400;</code>
<code>    this.w = 90;</code>
<code>    this.h = 60;</code>
<code>    this.dx = 0;</code>
<code>    this.dy = 0;</code>
<code>    this.rotate = 0;</code>
<code>    this.power = 0;</code>
<code>    this.accel = 0;</code>
<code></code>
<code>    this.keyL = false;</code>
<code>    this.keyR = false;</code>
<code>    this.keyF = false;</code>
<code>    this.keyB = false;</code>
<code></code>
<code>    this.image = document.getElementById('ship');</code>
<code>}</code>
</pre>
<p>
<br />
</p>
<p>　rotateは進行方向、powerはスピード、accelは加速度です。keyLは左、keyRは右、keyFは上（前）、keyBは下（後）キーの押下状態を保持します。</p>
</section>
</div>
<div id="calibre_link-53">
<section>
<h2 id="calibre_link-347"><b>5-7-4　関数</b></h2>
<p>　randは0～rまでの整数の乱数を返します。init()は文書読み込み時に実行される関数です。</p>
<p>rand関数、init()関数</p>
<pre>
<code>function rand(r) { return Math.floor(Math.random() * r) }</code>
<code></code>
<code>function init() {</code>
<code>    ctx = document.getElementById('canvas').getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code></code>
<code>    ship = new Ship();</code>
<code></code>
<code>    // 弾丸の初期化</code>
<code>    for (var i = 0 ; i &lt; 7 ; i++) {</code>
<code>        shots.push(new Shot());</code>
<code>    }</code>
<code></code>
<code>    // キーイベントハンドラーの初期化</code>
<code>    window.addEventListener('keydown', function (e) {</code>
<code>        switch (e.keyCode) {</code>
<code>            case 37: ship.keyL = true; break;</code>
<code>            case 38: ship.keyF = true; break;</code>
<code>            case 39: ship.keyR = true; break;</code>
<code>            case 40: ship.keyB = true; break;</code>
<code>            case 32: ship.keyH = true; break;</code>
<code>        }</code>
<code>    });</code>
<code>    window.addEventListener('keyup', function (e) {</code>
<code>        switch (e.keyCode) {</code>
<code>            case 37: ship.keyL = false; break;</code>
<code>            case 38: ship.keyF = false; break;</code>
<code>            case 39: ship.keyR = false; break;</code>
<code>            case 40: ship.keyB = false; break;</code>
<code>            case 32: ship.keyH = false; break;</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    start();</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        timer = setInterval(mainLoop, 50);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　init()ではcanvasのコンテキストを取得し、フォントを設定しています。そして、自機Shipを初期化し、弾丸Shot7個のオブジェクトを作成し、配列shotsに格納しています。</p>
<p>　そのあとで、keydownとkeyupのイベントハンドラーを登録し、start()を実行しています。その後、setIntervalでmainLoopを開始しています。</p>
<h3 id="calibre_link-348">■start()関数</h3>
<p>　start()はinit()から、もしくはステージクリア後に呼び出されます。</p>
<p>start()関数</p>
<pre>
<code>function start() {</code>
<code>    rocks = [];</code>
<code></code>
<code>    // 岩の初期化</code>
<code>    for (var i = 0 ; i &lt; level ; i++) {</code>
<code>        var x = rand(800), y = rand(800);</code>
<code>        while (true) {</code>
<code>            var r = new Rock(x, y, 64);</code>
<code>            if (!r.isHit(ship)) {</code>
<code>                rocks.push(r);</code>
<code>                break;</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　岩オブジェクトRockをステージ数levelにあわせて生成し、配列rocksに格納しています。</p>
<h3 id="calibre_link-349">■メインループ</h3>
<p>　mainLoop()はメインループです。少し長いので分割して説明します。</p>
<p>mainLoop()関数1</p>
<pre>
<code>function mainLoop() {</code>
<code>    clock++;</code>
<code></code>
<code>    if (rocks.length == 0) {</code>
<code>        if (clock &gt; 100) {</code>
<code>            level++;</code>
<code>            start();</code>
<code>        }</code>
<code>        return;</code>
<code>    }</code>
</pre>
<p>　都度、clockの値をインクリメント（1増やす）し、岩が全部なくなったら（rocks.length == 0）、しばらくの間停止して、レベルlevelを1増加してstart()を呼び出します。</p>
<p>　次は、自機shipの向きと場所を更新しています。keyLとkeyRで向きを変化させ、keyFとkeyBで加速度を増減しています。加速度の範囲は-5から+5に収まるようにしています。</p>
<p>mainLoop()関数2</p>
<pre>
<code>// 船の場所・向きを更新</code>
<code>if (ship.keyL) { ship.rotate -= 0.1; }</code>
<code>if (ship.keyR) { ship.rotate += 0.1; }</code>
<code>if (ship.keyF) { ship.accel = Math.min(+5, ship.accel + 0.2); }</code>
<code>if (ship.keyB) { ship.accel = Math.max(-5, ship.accel - 0.1); }</code>
<code></code>
<code>ship.power += ship.accel;</code>
<code>ship.power *= 0.94;</code>
<code>ship.accel *= 0.94;</code>
<code>ship.dx = Math.cos(ship.rotate) * ship.power;</code>
<code>ship.dy = Math.sin(ship.rotate) * ship.power;</code>
<code>ship.update();</code>
<code></code>
<code>bgX = (bgX + ship.dx / 2 + 1600) % 800;</code>
<code>bgY = (bgY + ship.dy / 2 + 1600) % 800;</code>
</pre>
<p>　「ship.power *= 0.94;」と「ship.accel *= 0.94;」はshipにブレーキをかける働きをしています。何も操作しないとpower（速度）とaccel（加速度）が徐々に低減していきます。その後、dxとdyを更新し、updateでshipの位置を更新しています。</p>
<p>　また、shipの移動量に合わせて、背景画像の描画開始場所、bgXとbgYを更新しています。</p>
<p>　次は弾丸の位置を更新し、衝突を検出する部分です。弾丸オブジェクトは配列shotsに格納されています。それぞれのオブジェクトをforEachで順番に取り出しています。</p>
<p>　個々のオブジェクトについてコールバック関数が呼ばれ、その関数の引数shotとしてShotオブジェクトが渡されます。</p>
<p>mainLoop()関数3</p>
<pre>
<code>// 弾丸の位置を更新</code>
<code>var fire = false;</code>
<code>shots.forEach(function (shot) {</code>
<code>    if (shot.count &lt; shot.maxCount) {</code>
<code>        shot.count++;</code>
<code>        shot.update();</code>
<code></code>
<code>        // 衝突検出</code>
<code>        var hit = -1, r = NaN;</code>
<code>        rocks.forEach(function (rock, i) {</code>
<code>            if (rock.isHit(shot)) {</code>
<code>                hit = i;</code>
<code>                r = rock;</code>
<code>            }</code>
<code>        });</code>
</pre>
<p>　fireは弾丸を発射したかどうか判定するフラグです。一度にすべての弾丸を発射してしまうのを避けるために使用しています。「if (shot.count &lt; shot.maxCount)」は現在弾丸が発射中であるか判断しています。発射中の場合は、「shot.count++」でカウントを増やし、「shot.update();」で場所を更新します。</p>
<p>　岩は配列rocksに格納されています。それをforEachで順番に取り出し、弾丸shotと衝突しているかisHitを使って判定しています。</p>
<p>mainLoop()関数4</p>
<pre>
<code>rocks.forEach(function (rock, i) {</code>
<code>    if (rock.isHit(shot)) {</code>
</pre>
<p>　衝突していた場合は、その岩のインデックスをhitに、その岩オブジェクトをrに格納します。</p>
<p>　弾丸と岩が衝突していた場合（hit &gt;= 0）、spliceを使って、その岩を配列rocksから削除します。そして、スコアを更新し、弾丸のcountをmaxCountにして発射状態でなくします。</p>
<p>mainLoop()関数5</p>
<pre>
<code>// 弾丸が岩に衝突</code>
<code>if (hit &gt;= 0) {</code>
<code>    rocks.splice(hit, 1);</code>
<code></code>
<code>    score += (64 / r.w) * 10;</code>
<code>    shot.count = shot.maxCount;</code>
<code></code>
<code>    r.w /= 2;</code>
<code>    if (r.w &gt;= 16) {</code>
<code>        for (var i = 0 ; i &lt; 2 ; i++) {</code>
<code>            rocks.push(new Rock(r.cx, r.cy, r.w));</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    // ステージクリア</code>
<code>    if (rocks.length == 0) {</code>
<code>        clock = 0;</code>
<code>        draw();</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　「r.w /= 2」で岩の大きさを半分にしています。その大きさが16よりも大きければ、1つの岩を2つの小さな岩にしています。岩の残りが0になれば（rocks.length == 0）、ステージクリアの処理を行います。</p>
<p>　以下は弾丸が発射された直後の処理です。発射された弾丸がなく、スペースキーが押下されていたら（!fire &amp;&amp; ship.keyH）、その弾丸を発射状態にします。その際、座標と向きはshipと同じ値を使用しています。こうすることで、shipが向いている方向に弾丸が発射されます。</p>
<p>mainLoop()関数6</p>
<pre>
<code>else if (!fire &amp;&amp; ship.keyH) {</code>
<code>    shot.count = 0;</code>
<code>    shot.cx = ship.cx;</code>
<code>    shot.cy = ship.cy;</code>
<code>    shot.r = ship.rotate;</code>
<code>    shot.dx = ship.dx + shot.power * Math.cos(shot.r);</code>
<code>    shot.dy = ship.dy + shot.power * Math.sin(shot.r);</code>
<code>    fire = true;</code>
<code>}</code>
</pre>
<p>
<br />
</p>
<p>　最後に岩の場所を更新し、shipと衝突しているか否か判定しています。衝突している場合は、タイマーを停止します。</p>
<p>mainLoop()関数7</p>
<pre>
<code>    // 岩の場所を更新</code>
<code>    rocks.forEach(function (rock) {</code>
<code>        rock.update();</code>
<code></code>
<code>        if (ship.isHit(rock)) {</code>
<code>            clearInterval(timer);</code>
<code>            timer = NaN;</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    draw();</code>
<code>}</code>
</pre>
<h3 id="calibre_link-350">■draw()関数</h3>
<p>　最後に描画関数draw()です。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // 背景を描画</code>
<code>    ctx.drawImage(bg, bgX, bgY, 400, 400, 0, 0, 800, 800);</code>
<code></code>
<code>    // 弾丸の描画</code>
<code>    ctx.fillStyle = 'rgb(0,255,255)';</code>
<code>    shots.forEach(function (shot) {</code>
<code>        if (shot.count &lt; shot.maxCount) {</code>
<code>            ctx.fillRect(shot.getX(), shot.getY(), shot.w, shot.h);</code>
<code>        }</code>
<code>    });</code>
<code></code>
<code>    // 岩の描画</code>
<code>    rocks.forEach(function (rock) {</code>
<code>        ctx.drawImage(rock.image, rock.getX(), rock.getY(), rock.w, rock.h);</code>
<code>    });</code>
<code></code>
<code>    // 船の描画</code>
<code>    ctx.save();</code>
<code>    ctx.translate(ship.cx, ship.cy);</code>
<code>        ctx.rotate(ship.rotate);</code>
<code>        ctx.drawImage(ship.image, -ship.w / 2, -ship.h / 2);</code>
<code>        ctx.restore();</code>
<code></code>
<code>    // スコアの描画</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText(('0000000' + score).slice(-7), 670, 30);</code>
<code></code>
<code>    if (rocks.length == 0) {</code>
<code>        ctx.fillText('STAGE CLEAR', 300, 150);</code>
<code>    }</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 320, 150);</code>
<code>        ctx.drawImage(bang, ship.getX() - 50, ship.getY() - 50, 200, 200);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　まず、背景を描画します。弾丸、岩、船と描画していきます。</p>
<p>　船の描画は、translate(ship.cx, ship.cy)で中心座標をshipの中心に移動させ、rotate(ship.rotate)で自機の向きに合わせて座標系を回転させ、その後drawImageで描画します。こうすることで、回転した船が描画されます。</p>
<p>　一連の処理の前後をsave()とrestore()で囲んでいることに注目してください。</p>
<p>　あとは、スコアや各種メッセージを状況に応じて描画しているだけです。</p>
</section>
</div>
<div id="calibre_link-119">
<section>
<hgroup>
<h1 id="calibre_link-180"><b>5-8　リアルタイム陣取りゲーム</b></h1>
</hgroup>
<p>　迫りくる敵を避けながら自機を操作して領土を広げていくQIX風の陣取りゲームです。自分の領土にいる間はシールドに守られているので敵と衝突しても大丈夫です。しかし、領土を確保するために移動している最中に衝突するとゲームオーバーです。</p>
<p>　QIXはタイトーが1981年に発売した業務用ゲームです。日本での販売よりも先にアメリカでヒットしたそうです。</p>
<p>ここでは、学習用のサンプルとして、敵を避けながら陣地を広げていくというシンプルなものにしました。敵を描画するために複数のオブジェクトを組み合わせています。オブジェクトの使い方に注意して読み進めていただければと思います。</p>
<figure>
<img src="images/00025.jpeg" />
<figcaption>敵を避けながら領土を拡大。敵に衝突するとゲームオーバー</figcaption>
</figure>
<p>【使用している画像】</p>
<p>　本ゲームで使用している画像とその用途です。画像はどんな絵でもかまいません。Windowsに標準でついてくる「ペイント」で作ることもできますので、自分の好きな絵を作成して、世界で唯一のオリジナルゲームを作り上げてください。</p>
<figure>
<img src="images/00137.jpeg" />
<figcaption></figcaption>
</figure>
</section>
</div>
<div id="calibre_link-13">
<section>
<h2 id="calibre_link-351"><b>5-8-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Quicks&lt;/title&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var timer = NaN, areas = [], score = 0, enemy, ship, ctx;</code>
<code></code>
<code>    function Rect(left, top, right, bottom) {</code>
<code>        this.left = left;</code>
<code>        this.top = top;</code>
<code>        this.right = right;</code>
<code>        this.bottom = bottom;</code>
<code>        this.width = function () { return this.right - this.left }</code>
<code>        this.height = function () { return this.bottom - this.top }</code>
<code>        this.clone = function () { return new Rect(this.left, this.top, this.right, this.bottom); }</code>
<code>        this.draw = function (ctx) {</code>
<code>            ctx.fillStyle = 'lightgreen';</code>
<code>            ctx.fillRect(this.left, this.top, this.width(), this.height());</code>
<code>            ctx.strokeStyle = 'green';</code>
<code>            ctx.strokeRect(this.left, this.top, this.width(), this.height());</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function Edge(r, delta) {</code>
<code>        this.r = r;</code>
<code>        this.theta = 0;</code>
<code>        this.delta = delta;</code>
<code>        this.x = 0;</code>
<code>        this.y = 0;</code>
<code></code>
<code>        this.update = function () {</code>
<code>            this.theta = (this.theta + this.delta) % (Math.PI * 2);</code>
<code>            this.x = Math.cos(this.theta) * this.r;</code>
<code>            this.y = Math.sin(this.theta) * this.r;</code>
<code>        }</code>
<code></code>
<code>        this.isHit = function (cx, cy) {</code>
<code>            var dx = this.x / 10, dy = this.y / 10;</code>
<code>            for (var x0 = cx - this.x, y0 = cy - this.y,</code>
<code>                i = 0 ; i &lt; 20 ; i++, x0 += dx, y0 += dy) {</code>
<code>                if (ship.x - ship.w / 2 &lt; x0 &amp;&amp; x0 &lt; ship.x + ship.w / 2 &amp;&amp;</code>
<code>                    ship.y - ship.w / 2 &lt; y0 &amp;&amp; y0 &lt; ship.y + ship.w / 2) {</code>
<code>                    return true;</code>
<code>                }</code>
<code>            }</code>
<code>            return false;</code>
<code>        }</code>
<code></code>
<code>        this.draw = function (ctx, cx, cy) {</code>
<code>            ctx.strokeStyle = 'red';</code>
<code>            ctx.beginPath();</code>
<code>            ctx.moveTo(cx - this.x, cy - this.y);</code>
<code>            ctx.lineTo(cx + this.x, cy + this.y);</code>
<code>            ctx.closePath();</code>
<code>            ctx.stroke();</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function Enemy() {</code>
<code>        this.edges = [new Edge(20, 0.6),</code>
<code>                new Edge(40, 0.4),</code>
<code>                new Edge(60, 0.2),</code>
<code>                new Edge(100, 0.1)];</code>
<code></code>
<code>        this.prevX = this.x = rand(600);</code>
<code>        this.prevY = this.y = rand(600);</code>
<code>        this.nextX = rand(600);</code>
<code>        this.nextY = rand(600);</code>
<code>        this.count = 0;</code>
<code>        this.limit = rand(20) + 50;</code>
<code></code>
<code>        this.update = function () {</code>
<code>            if (++this.count &gt; this.limit) {</code>
<code>                // 次の移動場所の設定</code>
<code>                this.prevX = this.nextX;</code>
<code>                this.prevY = this.nextY;</code>
<code>                this.nextX = ship.rect.left + rand(ship.rect.width());</code>
<code>                this.nextY = ship.rect.top + rand(ship.rect.height());</code>
<code>                this.limit = rand(20) + 50;</code>
<code>                this.count = 0;</code>
<code>            } else {</code>
<code>                // 徐々に中心位置を移動</code>
<code>                this.x = this.prevX + (this.nextX - this.prevX) * this.count / this.limit;</code>
<code>                this.y = this.prevY + (this.nextY - this.prevY) * this.count / this.limit;</code>
<code>            }</code>
<code></code>
<code>            this.edges.forEach(function (e) {</code>
<code>                e.update();</code>
<code>            });</code>
<code>        };</code>
<code></code>
<code>        this.isHit = function () {</code>
<code>            var that = this;</code>
<code>            return this.edges.some(function (e) {</code>
<code>                return e.isHit(that.x, that.y);</code>
<code>            });</code>
<code>        }</code>
<code></code>
<code>        this.draw = function (ctx) {</code>
<code>            for (var i = 0 ; i &lt; this.edges.length ; i++) {</code>
<code>                this.edges[i].draw(ctx, this.x, this.y);</code>
<code>            }</code>
<code>        };</code>
<code>    }</code>
<code></code>
<code>    function Ship() {</code>
<code>        this.rect = new Rect(10, 10, 590, 590);</code>
<code>        this.x = this.rect.left;</code>
<code>        this.y = this.rect.top;</code>
<code>        this.w = 20;</code>
<code>        this.dx = 0;</code>
<code>        this.dy = 0;</code>
<code>        this.sx = 0;</code>
<code>        this.sy = 0;</code>
<code>        this.image = document.getElementById('ship');</code>
<code>        this.count = 0;</code>
<code></code>
<code>        this.keyL = false;</code>
<code>        this.keyU = false;</code>
<code>        this.keyR = false;</code>
<code>        this.keyD = false;</code>
<code></code>
<code>        this.update = function () {</code>
<code>            this.count++;</code>
<code></code>
<code>            if (this.dx != 0 || this.dy != 0) {</code>
<code>                // 移動中 ＝ 無防備モード</code>
<code>                this.x = Math.max(this.rect.left, Math.min(this.rect.right, this.x + this.dx));</code>
<code>                this.y = Math.max(this.rect.top, Math.min(this.rect.bottom, this.y + this.dy));</code>
<code></code>
<code>                var r = null;</code>
<code>                if (this.x == this.rect.left || this.x == this.rect.right) {</code>
<code>                    // 水平方向に分割</code>
<code>                    r = this.rect.clone();</code>
<code>                    if ((this.y - this.rect.top) &gt; (this.rect.bottom - this.y)) {</code>
<code>                        this.rect.bottom = r.top = this.y;</code>
<code>                    } else {</code>
<code>                        this.rect.top = r.bottom = this.y;</code>
<code>                    }</code>
<code>                }</code>
<code>                else if (this.y == this.rect.top || this.y == this.rect.bottom) {</code>
<code>                    // 垂直方向に分割</code>
<code>                    r = this.rect.clone();</code>
<code>                    if ((this.x - this.rect.left) &gt; (this.rect.right - this.x)) {</code>
<code>                        this.rect.right = r.left = this.x</code>
<code>                    } else {</code>
<code>                        this.rect.left = r.right = this.x</code>
<code>                    }</code>
<code>                }</code>
<code></code>
<code>                if (r) {</code>
<code>                    this.dx = this.dy = 0;</code>
<code>                    areas.push(r);</code>
<code>                    score += r.width() * r.height();</code>
<code>                }</code>
<code>                return;</code>
<code>            }</code>
<code></code>
<code>            // キー入力処理</code>
<code>            if (this.keyR &amp;&amp; this.x &lt; this.rect.right) {</code>
<code>                if (this.y == this.rect.top || this.y == this.rect.bottom) {</code>
<code>                    this.x = Math.min(this.rect.right, this.x + 10);</code>
<code>                } else {</code>
<code>                    this.dx = 10;</code>
<code>                    this.sx = this.x;</code>
<code>                    this.sy = this.y;</code>
<code>                }</code>
<code>            }</code>
<code></code>
<code>            if (this.keyL &amp;&amp; this.x &gt; this.rect.left) {</code>
<code>                if (this.y == this.rect.top || this.y == this.rect.bottom) {</code>
<code>                    this.x = Math.max(this.rect.left, this.x - 10);</code>
<code>                } else {</code>
<code>                    this.dx -= 10;</code>
<code>                    this.sx = this.x;</code>
<code>                    this.sy = this.y;</code>
<code>                }</code>
<code>            }</code>
<code></code>
<code>            if (this.keyU &amp;&amp; this.y &gt; this.rect.top) {</code>
<code>                if (this.x == this.rect.left || this.x == this.rect.right) {</code>
<code>                    this.y = Math.max(this.rect.top, this.y - 10);</code>
<code>                } else {</code>
<code>                    this.dy -= 10;</code>
<code>                    this.sx = this.x;</code>
<code>                    this.sy = this.y;</code>
<code>                }</code>
<code>            }</code>
<code></code>
<code>            if (this.keyD &amp;&amp; this.y &lt; this.rect.bottom) {</code>
<code>                if (this.x == this.rect.left || this.x == this.rect.right) {</code>
<code>                    this.y = Math.min(this.rect.bottom, this.y + 10);</code>
<code>                } else {</code>
<code>                    this.dy += 10;</code>
<code>                    this.sx = this.x;</code>
<code>                    this.sy = this.y;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        this.draw = function (ctx) {</code>
<code>            // 現在の範囲</code>
<code>            ctx.strokeStyle = 'blue';</code>
<code>            ctx.strokeRect(this.rect.left, this.rect.top,</code>
<code>                this.rect.width(), this.rect.height());</code>
<code></code>
<code>            // 自分自身を描画</code>
<code>            ctx.drawImage(this.image, this.x - this.w / 2, this.y - this.w / 2);</code>
<code></code>
<code>            // シールド時の描画</code>
<code>            if (this.dx == 0 &amp; this.dy == 0) {</code>
<code>                ctx.strokeStyle = 'white';</code>
<code>                ctx.beginPath();</code>
<code>                ctx.arc(this.x, this.y, 10 + this.count % 3, 0, Math.PI * 2, true);</code>
<code>                ctx.stroke();</code>
<code>            } else {</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(this.sx, this.sy);</code>
<code>                ctx.lineTo(this.x, this.y);</code>
<code>                ctx.stroke();</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function rand(r) {</code>
<code>        return Math.floor(Math.random() * r);</code>
<code>    }</code>
<code></code>
<code>    function init() {</code>
<code>        enemy = new Enemy();</code>
<code>        ship = new Ship();</code>
<code>        score = 0;</code>
<code>        areas = [];</code>
<code></code>
<code>        var canvas = document.getElementById('canvas');</code>
<code>        ctx = canvas.getContext('2d');</code>
<code>        ctx.font = "20pt Arial";</code>
<code>        timer = setInterval(mainLoop, 100);</code>
<code></code>
<code>        addEventListener('keydown', function (e) { toggleKey(e.keyCode, true) });</code>
<code>        addEventListener('keyup', function (e) { toggleKey(e.keyCode, false) });</code>
<code>    }</code>
<code></code>
<code>    function toggleKey(code, flag) {</code>
<code>        switch (code) {</code>
<code>            case 37: ship.keyL = flag; break;</code>
<code>            case 38: ship.keyU = flag; break;</code>
<code>            case 39: ship.keyR = flag; break;</code>
<code>            case 40: ship.keyD = flag; break;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function mainLoop() {</code>
<code>        enemy.update();</code>
<code>        ship.update();</code>
<code></code>
<code>        if (ship.dx != 0 || ship.dy != 0) {</code>
<code>            if (enemy.isHit()) {</code>
<code>                clearInterval(timer);</code>
<code>                timer = NaN;</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        draw();</code>
<code>    }</code>
<code></code>
<code>    function draw() {</code>
<code>        // 背景塗り潰し</code>
<code>        ctx.fillStyle = 'black';</code>
<code>        ctx.fillRect(0, 0, 600, 700);</code>
<code></code>
<code>        // 矩形の塗りつぶし</code>
<code>        areas.forEach(function (r) { r.draw(ctx) });</code>
<code></code>
<code>        // 敵の描画</code>
<code>        enemy.draw(ctx);</code>
<code></code>
<code>        // 自分の描画</code>
<code>        ship.draw(ctx);</code>
<code></code>
<code>        // 各種メッセージ</code>
<code>        ctx.fillStyle = 'green';</code>
<code>        var s = Math.floor(score / (600 * 600) * 10000);</code>
<code>        ctx.fillText('score:' + (s / 100) + '%', 400, 620);</code>
<code></code>
<code>        if (isNaN(timer)) {</code>
<code>            ctx.fillText('GAME OVER', 220, 650);</code>
<code>        }</code>
<code>    }</code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;canvas id="canvas" width="600" height="700"&gt;&lt;/canvas&gt;</code>
<code>&lt;img id="ship" src="ship.png" style="display:none;" /&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-112">
<section>
<h2 id="calibre_link-352"><b>5-8-2　変数</b></h2>
<p>　使用している主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>areas</td>
  <td>すでに獲得した領地（Rect）を格納する配列</td>
</tr>
<tr>
  <td>score</td>
  <td>現在のスコアを保持する</td>
</tr>
<tr>
  <td>enemy</td>
  <td>敵のオブジェクト（Enemy）を保持する</td>
</tr>
<tr>
  <td>ship</td>
  <td>自機のオブジェクト（Ship）を保持する</td>
</tr>
</tbody>
</table>
<figure>
<img src="images/00065.jpeg" />
<figcaption>QIXの主な変数</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-45">
<section>
<h2 id="calibre_link-353"><b>5-8-3　オブジェクト</b></h2>
<h3 id="calibre_link-354">■Rectオブジェクト</h3>
<p>　まずはRectオブジェクトです。これは矩形を表現、描画するためのオブジェクトです。</p>
<p>Rectオブジェクト</p>
<pre>
<code>function Rect(left, top, right, bottom) {</code>
<code>    this.left = left;</code>
<code>    this.top = top;</code>
<code>    this.right = right;</code>
<code>    this.bottom = bottom;</code>
<code>    this.width = function () { return this.right - this.left }</code>
<code>    this.height = function () { return this.bottom - this.top }</code>
<code>    this.clone = function () { return new Rect(this.left, this.top, this.right, this.bottom); }</code>
<code>    this.draw = function (ctx) {</code>
<code>        ctx.fillStyle = 'lightgreen';</code>
<code>        ctx.fillRect(this.left, this.top, this.width(), this.height());</code>
<code>        ctx.strokeStyle = 'green';</code>
<code>        ctx.strokeRect(this.left, this.top, this.width(), this.height());</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　4つの辺の座標を、left、top、right、bottomプロパティで管理しています。widthメソッドは幅を、heightメソッドは高さを返します。drawは自分自身を描画します。</p>
<h3 id="calibre_link-355">■Edgeオブジェクト</h3>
<p>　Edgeは敵であるEnemyを構成する1つの線のオブジェクトです。EnemyとEdgeの関係を下図左に、Edgeのプロパティを下図右に示します。</p>
<figure>
<img src="images/00164.jpeg" />
<figcaption>EnemyとEdgeの関係（左）Edgeのプロパティ（右）</figcaption>
</figure>
<p>Edgeオブジェクト</p>
<pre>
<code>function Edge(r, delta) {</code>
<code>    this.r = r;</code>
<code>    this.theta = 0;</code>
<code>    this.delta = delta;</code>
<code>    this.x = 0;</code>
<code>    this.y = 0;</code>
<code></code>
<code>    this.update = function () {</code>
<code>        this.theta = (this.theta + this.delta) % (Math.PI * 2);</code>
<code>        this.x = Math.cos(this.theta) * this.r;</code>
<code>        this.y = Math.sin(this.theta) * this.r;</code>
<code>    }</code>
<code></code>
<code>    this.isHit = function (cx, cy) {</code>
<code>        var dx = this.x / 10, dy = this.y / 10;</code>
<code>        for (var x0 = cx - this.x, y0 = cy - this.y,</code>
<code>            i = 0 ; i &lt; 20 ; i++, x0 += dx, y0 += dy) {</code>
<code>            if (ship.x - ship.w / 2 &lt; x0 &amp;&amp; x0 &lt; ship.x + ship.w / 2 &amp;&amp;</code>
<code>                ship.y - ship.w / 2 &lt; y0 &amp;&amp; y0 &lt; ship.y + ship.w / 2) {</code>
<code>                return true;</code>
<code>            }</code>
<code>        }</code>
<code>        return false;</code>
<code>    }</code>
<code></code>
<code>    this.draw = function (ctx, cx, cy) {</code>
<code>        ctx.strokeStyle = 'red';</code>
<code>        ctx.beginPath();</code>
<code>        ctx.moveTo(cx - this.x, cy - this.y);</code>
<code>        ctx.lineTo(cx + this.x, cy + this.y);</code>
<code>        ctx.closePath();</code>
<code>        ctx.stroke();</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　プロパティrは半径、プロパティthetaは現在の角度、プロパティdeltaは回転するスピード、xとyは線の端の座標を保持しています。updateは現在の角度thetaをdelta増やし、xとyの座標を更新しています。</p>
<p>　isHitは自機と線が衝突しているかどうか判定するメソッドです。自機の座標は(ship.x, ship.y)で取得できます。一方、敵Enemyの中心座標は引数(cx, cy)で与えられます。</p>
<p>　線の上にあるか厳密に調べるのは面倒なので、線を20等分して、その座標が自機と重なるかを調べています。</p>
<p>　まず</p>
<p>
<br />
</p>
<pre>
<code>var dx = this.x / 10, dy = this.y / 10;</code>
</pre>
<p>で増分を求めます。</p>
<p>　次に調べる座標を保持するx0とy0を、</p>
<p>
<br />
</p>
<pre>
<code>var x0 = cx - this.x, y0 = cy - this.y,</code>
</pre>
<p>で初期化し、毎回「x0 += dx」「y0 += dy」と増やしていきます。forを使い、これを20回繰り返しています。イメージを以下に示します。</p>
<figure>
<img src="images/00090.jpeg" />
<figcaption>線を20等分してその座標が自機と重なるかを調べる</figcaption>
</figure>
<p>　drawメソッドは赤色の線分を描画しています。</p>
<h3 id="calibre_link-356">■Enemyオブジェクト</h3>
<p>　Enemyは敵のオブジェクトです。edgesプロパティはEdgeオブジェクトを4つ格納している配列です。それぞれのEdgeの引数で、線分の長さと回転速度を指定しています。</p>
<p>Enemyオブジェクト</p>
<pre>
<code>function Enemy() {</code>
<code>    this.edges = [new Edge(20, 0.6),</code>
<code>            new Edge(40, 0.4),</code>
<code>            new Edge(60, 0.2),</code>
<code>            new Edge(100, 0.1)];</code>
<code></code>
<code>    this.prevX = this.x = rand(600);</code>
<code>    this.prevY = this.y = rand(600);</code>
<code>    this.nextX = rand(600);</code>
<code>    this.nextY = rand(600);</code>
<code>    this.count = 0;</code>
<code>    this.limit = rand(20) + 50;</code>
<code></code>
<code>    this.update = function () {</code>
<code>        if (++this.count &gt; this.limit) {</code>
<code>            // 次の移動場所の設定</code>
<code>            this.prevX = this.nextX;</code>
<code>            this.prevY = this.nextY;</code>
<code>            this.nextX = ship.rect.left + rand(ship.rect.width());</code>
<code>            this.nextY = ship.rect.top + rand(ship.rect.height());</code>
<code>            this.limit = rand(20) + 50;</code>
<code>            this.count = 0;</code>
<code>        } else {</code>
<code>            // 徐々に中心位置を移動</code>
<code>            this.x = this.prevX + (this.nextX - this.prevX) * this.count / this.limit;</code>
<code>            this.y = this.prevY + (this.nextY - this.prevY) * this.count / this.limit;</code>
<code>        }</code>
<code></code>
<code>        this.edges.forEach(function (e) {</code>
<code>            e.update();</code>
<code>        });</code>
<code>    };</code>
<code></code>
<code>    this.isHit = function () {</code>
<code>        var that = this;</code>
<code>        return this.edges.some(function (e) {</code>
<code>            return e.isHit(that.x, that.y);</code>
<code>        });</code>
<code>    }</code>
<code></code>
<code>    this.draw = function (ctx) {</code>
<code>        for (var i = 0 ; i &lt; this.edges.length ; i++) {</code>
<code>            this.edges[i].draw(ctx, this.x, this.y);</code>
<code>        }</code>
<code>    };</code>
<code>}</code>
</pre>
<p>　プロパティprevXとprevYは前の地点、プロパティnextXとnextYは次の目的地点、プロパティlimitは何回で目的地まで移動するか、countは現在の移動回数を保持します。その様子を以下の図に示します。</p>
<figure>
<img src="images/00140.jpeg" />
<figcaption>Enemyのプロパティ</figcaption>
</figure>
<p>　目的地点に到達したら（++this.count &gt; this.limit）、次の移動場所を設定します。そうでない場合は、徐々に目的地点に移動していきます。中心座標が決まったら、</p>
<p>
<br />
</p>
<pre>
<code>this.edges.forEach(function (e) {</code>
<code>    e.update();</code>
<code>});</code>
</pre>
<p>でそれぞれの線分の位置を更新します。また、衝突判定は以下の命令で行っています。</p>
<p>
<br />
</p>
<pre>
<code>this.isHit = function () {</code>
<code>    var that = this;</code>
<code>    return this.edges.some(function (e) {</code>
<code>        return e.isHit(that.x, that.y);</code>
<code>    });</code>
<code>}</code>
</pre>
<p>　Array.prototype.someは、コールバック関数のどれかが真を返すと全体が真となるメソッドです。このメソッドはArrayオブジェクトのprototypeで実装されているので、任意の配列オブジェクトからも利用できます。this.edgesも配列なので、このsomeメソッドを呼び出すことが可能です。上記のコードではこれを利用しています。配列edgesの要素は線分Edgeですが、配列の個々の要素が変数eとしてコールバック関数の引数に渡されます。そのEdgeのisHitを呼び出して、個々の線分との衝突を返しています。つまり、線分のどれかが衝突している場合に、敵と衝突したと判断しているのです。</p>
<h3 id="calibre_link-357">■Shipオブジェクト</h3>
<p>　Shipは自機のオブジェクトです。長いので分割して説明します。</p>
<p>Shipオブジェクト1</p>
<pre>
<code>function Ship() {</code>
<code>    this.rect = new Rect(10, 10, 590, 590);</code>
<code>    this.x = this.rect.left;</code>
<code>    this.y = this.rect.top;</code>
<code>    this.w = 20;</code>
<code>    this.dx = 0;</code>
<code>    this.dy = 0;</code>
<code>    this.sx = 0;</code>
<code>    this.sy = 0;</code>
<code>    this.image = document.getElementById('ship');</code>
<code>    this.count = 0;</code>
<code></code>
<code>    this.keyL = false;</code>
<code>    this.keyU = false;</code>
<code>    this.keyR = false;</code>
<code>    this.keyD = false;</code>
</pre>
<p>　プロパティrectは現在自分が移動できる領域を示す矩形です。</p>
<p>　xとyは現在の自機の座標、wは幅と高さ、dxとdyは移動量、sxとsyは4辺を離れたときの座標を保持しています。その様子を以下の図に示します。</p>
<figure>
<img src="images/00113.jpeg" />
<figcaption>rectプロパティ</figcaption>
</figure>
<p>　updateメソッドは自機の状態を更新します。(this.dx != 0 || this.dy != 0)が真のときは自機が移動中ということを意味します。</p>
<p>Shipオブジェクト2</p>
<pre>
<code>this.update = function () {</code>
<code>    this.count++;</code>
<code></code>
<code>    if (this.dx != 0 || this.dy != 0) {</code>
<code>        // 移動中 ＝ 無防備モード</code>
<code>        this.x = Math.max(this.rect.left, Math.min(this.rect.right, this.x + this.dx));</code>
<code>        this.y = Math.max(this.rect.top, Math.min(this.rect.bottom, this.y + this.dy));</code>
<code></code>
<code>        var r = null;</code>
<code>        if (this.x == this.rect.left || this.x == this.rect.right) {</code>
<code>            // 水平方向に分割</code>
<code>            r = this.rect.clone();</code>
<code>            if ((this.y - this.rect.top) &gt; (this.rect.bottom - this.y)) {</code>
<code>                this.rect.bottom = r.top = this.y;</code>
<code>            } else {</code>
<code>                this.rect.top = r.bottom = this.y;</code>
<code>            }</code>
<code>        }</code>
<code>        else if (this.y == this.rect.top || this.y == this.rect.bottom) {</code>
<code>            // 垂直方向に分割</code>
<code>            r = this.rect.clone();</code>
<code>            if ((this.x - this.rect.left) &gt; (this.rect.right - this.x)) {</code>
<code>                this.rect.right = r.left = this.x</code>
<code>            } else {</code>
<code>                this.rect.left = r.right = this.x</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        if (r) {</code>
<code>            this.dx = this.dy = 0;</code>
<code>            areas.push(r);</code>
<code>            score += r.width() * r.height();</code>
<code>        }</code>
<code>        return;</code>
<code>    }</code>
</pre>
<p>　現在の座標this.xにthis.dxを加えることで座標を更新しています。Math.maxとMath.minを組み合わせることで、座標の範囲がrectの中に収まるようにしています。y座標も同じです。</p>
<p>　水平方向に分割された場合（this.x == this.rect.left || this.x == this.rect.right）を見てみましょう。</p>
<figure>
<img src="images/00036.jpeg" />
<figcaption>水平方向に分割された場合</figcaption>
</figure>
<p>　分割されると、上の矩形と下の矩形に分割されます。面積の狭いほうをrとし、広いほうを自分の新しい矩形rectとします。コードと上の図を見比べてみてください。垂直方向に分割する場合も考え方は同じです。</p>
<p>　以下はキー入力の処理を行う部分です。</p>
<p>Shipオブジェクト3</p>
<pre>
<code>// キー入力処理</code>
<code>if (this.keyR &amp;&amp; this.x &lt; this.rect.right) {</code>
<code>    if (this.y == this.rect.top || this.y == this.rect.bottom) {</code>
<code>        this.x = Math.min(this.rect.right, this.x + 10);</code>
<code>    } else {</code>
<code>        this.dx = 10;</code>
<code>        this.sx = this.x;</code>
<code>        this.sy = this.y;</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　上記は右キーが押下された場合です。</p>
<p>　まず、現在のx座標が右辺rect.rightより小さいことを判定しています。</p>
<p>　その後、自機が上辺か下辺のどちらにいるか判定しています。その場合は、単にx座標を増やしているだけです。</p>
<p>　それ以外の場合は、右方向へ移動を開始するということなのでdxを10とし、辺を離れた座標sx、syをとして保存します。</p>
<figure>
<img src="images/00064.jpeg" />
<figcaption>右キーが押下された場合</figcaption>
</figure>
<p>　 左、上、下キーが押された場合も、処理内容は同じなので説明は省略します。</p>
<p>　最後はdrawメソッドです。自機を描画します。まず自分の範囲をstrokeRectを使い「'blue'」で描画します。</p>
<p>Shipオブジェクト4</p>
<pre>
<code>        this.draw = function (ctx) {</code>
<code>            // 現在の範囲</code>
<code>            ctx.strokeStyle = 'blue';</code>
<code>            ctx.strokeRect(this.rect.left, this.rect.top,</code>
<code>                this.rect.width(), this.rect.height());</code>
<code></code>
<code>            // 自分自身を描画</code>
<code>            ctx.drawImage(this.image, this.x - this.w / 2, this.y - this.w / 2);</code>
<code></code>
<code>            // シールド時の描画</code>
<code>            if (this.dx == 0 &amp; this.dy == 0) {</code>
<code>                ctx.strokeStyle = 'white';</code>
<code>                ctx.beginPath();</code>
<code>                ctx.arc(this.x, this.y, 10 + this.count % 3, 0, Math.PI * 2, true);</code>
<code>                ctx.stroke();</code>
<code>            } else {</code>
<code>                ctx.beginPath();</code>
<code>                ctx.moveTo(this.sx, this.sy);</code>
<code>                ctx.lineTo(this.x, this.y);</code>
<code>                ctx.stroke();</code>
<code>            }</code>
<code>        }</code>
</pre>
<p>　その後、drawImageで自機の画像を描画します。自分の範囲の枠の上にいるとき、すなわち自動で移動していないとき（this.dx == 0 &amp; this.dy == 0）、はarcでシールドを描画しています。移動中の場合は、辺を離れた座標（this.sx, this.sy）から現在位置（this.x, this.y）まで直線を描画しています。</p>
</section>
</div>
<div id="calibre_link-113">
<section>
<h2 id="calibre_link-358"><b>5-8-4　関数</b></h2>
<h3 id="calibre_link-359">■rand関数、init()関数</h3>
<p>　rand(r)は0～rまでの整数rの乱数を返します。init()は文書読み込み時に呼び出されます。</p>
<p>rand関数、init()関数</p>
<pre>
<code>    function rand(r) {</code>
<code>        return Math.floor(Math.random() * r);</code>
<code>    }</code>
<code></code>
<code>    function init() {</code>
<code>        enemy = new Enemy();</code>
<code>        ship = new Ship();</code>
<code>        score = 0;</code>
<code>        areas = [];</code>
<code></code>
<code>        var canvas = document.getElementById('canvas');</code>
<code>        ctx = canvas.getContext('2d');</code>
<code>        ctx.font = "20pt Arial";</code>
<code>        timer = setInterval(mainLoop, 100);</code>
<code></code>
<code>        addEventListener('keydown', function (e) { toggleKey(e.keyCode, true) });</code>
<code>        addEventListener('keyup', function (e) { toggleKey(e.keyCode, false) });</code>
<code>    }</code>
</pre>
<p>　EnemyオブジェクトとShipオブジェクトを作成し、「'canvas'」のコンテキストを取得し、フォントを設定しています。そして、メインループmainLoopをsetIntervalで開始しています。あとは「'keydown'」と「'keyup'」のイベントハンドラーを登録しています。</p>
<h3 id="calibre_link-360">■toggleKey関数</h3>
<p>　toggleKey()はキーの押下、リリースに応じてShipオブジェクトの該当するプロパティを更新しています。mainLoopでは敵enemyと自機shipの状態を更新します。</p>
<p>toggleKey関数</p>
<pre>
<code>function toggleKey(code, flag) {</code>
<code>    switch (code) {</code>
<code>        case 37: ship.keyL = flag; break;</code>
<code>        case 38: ship.keyU = flag; break;</code>
<code>        case 39: ship.keyR = flag; break;</code>
<code>        case 40: ship.keyD = flag; break;</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function mainLoop() {</code>
<code>    enemy.update();</code>
<code>    ship.update();</code>
<code></code>
<code>    if (ship.dx != 0 || ship.dy != 0) {</code>
<code>        if (enemy.isHit()) {</code>
<code>            clearInterval(timer);</code>
<code>            timer = NaN;</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    draw();</code>
<code>}</code>
</pre>
<p>　自機が移動中の場合（ship.dx != 0 || ship.dy != 0）、敵と衝突していないか判定し（enemy.isHit()）、衝突している場合はタイマーを停止します。最後にdraw()を呼び出して描画を更新します。</p>
<h3 id="calibre_link-361">■draw()関数</h3>
<p>　draw()は画面を再描画しています。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // 背景塗り潰し</code>
<code>    ctx.fillStyle = 'black';</code>
<code>    ctx.fillRect(0, 0, 600, 700);</code>
<code></code>
<code>    // 矩形の塗りつぶし</code>
<code>    areas.forEach(function (r) { r.draw(ctx) });</code>
<code></code>
<code>    // 敵の描画</code>
<code>    enemy.draw(ctx);</code>
<code></code>
<code>    // 自分の描画</code>
<code>    ship.draw(ctx);</code>
<code></code>
<code>    // 各種メッセージ</code>
<code>    ctx.fillStyle = 'green';</code>
<code>    var s = Math.floor(score / (600 * 600) * 10000);</code>
<code>    ctx.fillText('score:' + (s / 100) + '%', 400, 620);</code>
<code></code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 220, 650);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　まず背景を黒で塗りつぶし、すでに確保した領域部分をareas.forEach(function (r) { r.draw(ctx) })で塗りつぶします。続いて、敵と自分を描画し、最後に各種メッセージを表示しています。</p>
</section>
</div>
<div id="calibre_link-77">
<section>
<hgroup>
<h1 id="calibre_link-181"><b>5-9　落ちもの系ゲーム</b></h1>
</hgroup>
<p>　落ちもの系ゲームの元祖といえばテトリスですが、このゲームは元々はソビエト連邦の科学者が教育用として開発した作品だそうです。本家に敬意を表しつつ、ごく基本的な部分のみを作ってみました。落ちもの系ゲームがどのようにできているか、実装の一例としてご紹介します。みなさんが独自ゲームを作成する際の参考になればと思います。</p>
<figure>
<img src="images/00063.jpeg" />
<figcaption>横に1行揃うと消去される。ブロックが上までつかえるとゲームオーバー</figcaption>
</figure>
</section>
</div>
<div id="calibre_link-6">
<section>
<h2 id="calibre_link-362"><b>5-9-1　ソースコード</b></h2>
<p>　ソースコードを自分の手で入力して実行してみましょう。</p>
<p>ソースコード</p>
<pre>
<code>&lt;!DOCTYPE html&gt;</code>
<code>&lt;html&gt;</code>
<code>&lt;head&gt;</code>
<code>    &lt;title&gt;Tetris&lt;/title&gt;</code>
<code>    &lt;script type="text/javascript"&gt;</code>
<code>    var ctx, W = 12, H = 22, field, block, nextBlock, keyevents = [];</code>
<code>    var interval = 40, count, score, timer;</code>
<code></code>
<code>    var colors = ['black', 'orange', 'blue', 'aqua',</code>
<code>        'lime', 'fuchsia', 'yellow', 'red', 'gray'];</code>
<code></code>
<code>    var blocks = [</code>
<code>        [</code>
<code>            [</code>
<code>                0, 0, 1,</code>
<code>                1, 1, 1,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 1</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                1, 1, 1,</code>
<code>                1, 0, 0</code>
<code>            ], [</code>
<code>                1, 1, 0,</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 0</code>
<code>            ],</code>
<code>        ], [</code>
<code>            [</code>
<code>                2, 0, 0,</code>
<code>                2, 2, 2,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 2, 2,</code>
<code>                0, 2, 0,</code>
<code>                0, 2, 0</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                2, 2, 2,</code>
<code>                0, 0, 2</code>
<code>            ], [</code>
<code>                0, 2, 0,</code>
<code>                0, 2, 0,</code>
<code>                2, 2, 0</code>
<code>            ]</code>
<code>        ], [</code>
<code>            [</code>
<code>                0, 3, 0,</code>
<code>                3, 3, 3,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 3, 0,</code>
<code>                0, 3, 3,</code>
<code>                0, 3, 0</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                3, 3, 3,</code>
<code>                0, 3, 0</code>
<code>            ], [</code>
<code>                0, 3, 0,</code>
<code>                3, 3, 0,</code>
<code>                0, 3, 0</code>
<code>            ]</code>
<code>        ], [</code>
<code>            [</code>
<code>                4, 4, 0,</code>
<code>                0, 4, 4,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 0, 4,</code>
<code>                0, 4, 4,</code>
<code>                0, 4, 0</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                4, 4, 0,</code>
<code>                0, 4, 4</code>
<code>            ], [</code>
<code>                0, 4, 0,</code>
<code>                4, 4, 0,</code>
<code>                4, 0, 0</code>
<code>            ]</code>
<code>        ], [</code>
<code>            [</code>
<code>                0, 5, 5,</code>
<code>                5, 5, 0,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 5, 0,</code>
<code>                0, 5, 5,</code>
<code>                0, 0, 5</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                0, 5, 5,</code>
<code>                5, 5, 0</code>
<code>            ], [</code>
<code>                5, 0, 0,</code>
<code>                5, 5, 0,</code>
<code>                0, 5, 0</code>
<code>            ]</code>
<code>        ], [</code>
<code>            [</code>
<code>                6, 6,</code>
<code>                6, 6</code>
<code>            ], [</code>
<code>                6, 6,</code>
<code>                6, 6</code>
<code>            ], [</code>
<code>                6, 6,</code>
<code>                6, 6</code>
<code>            ], [</code>
<code>                6, 6,</code>
<code>                6, 6</code>
<code>            ]</code>
<code>        ], [</code>
<code>            [</code>
<code>                0, 7, 0, 0,</code>
<code>                0, 7, 0, 0,</code>
<code>                0, 7, 0, 0,</code>
<code>                0, 7, 0, 0</code>
<code>            ], [</code>
<code>                0, 0, 0, 0,</code>
<code>                7, 7, 7, 7,</code>
<code>                0, 0, 0, 0,</code>
<code>                0, 0, 0, 0</code>
<code>            ], [</code>
<code>                0, 0, 7, 0,</code>
<code>                0, 0, 7, 0,</code>
<code>                0, 0, 7, 0,</code>
<code>                0, 0, 7, 0</code>
<code>            ], [</code>
<code>                0, 0, 0, 0,</code>
<code>                0, 0, 0, 0,</code>
<code>                7, 7, 7, 7,</code>
<code>                0, 0, 0, 0</code>
<code>            ]</code>
<code>        ]</code>
<code>    ];</code>
<code></code>
<code>    function Block() {</code>
<code>        this.turn = rand(4);                    // 向き</code>
<code>        this.type = blocks[rand(blocks.length)];</code>
<code>        this.data = this.type[this.turn];</code>
<code></code>
<code>        this.w = Math.sqrt(this.data.length);   // 2 or 3 or 4</code>
<code>        this.x = rand(6 - this.w) + 2;          // 落下開始時のx座標</code>
<code>        this.y = 1 - this.w;</code>
<code>        this.fire = interval + count;</code>
<code></code>
<code>        this.update = function () {</code>
<code>            // 一番下に到達？</code>
<code>            if (isHit(this.x, this.y + 1, this.turn)) {</code>
<code>                processBlockCells(function (x, y, value) {</code>
<code>                    field[y][x] = value;</code>
<code>                });</code>
<code></code>
<code>                var erased = eraseLine();</code>
<code>                if (erased &gt; 0) {</code>
<code>                    score += Math.pow(2, erased) * 10;</code>
<code>                }</code>
<code></code>
<code>                keyevents = [];</code>
<code>                goNextBlock();</code>
<code>            }</code>
<code></code>
<code>            // ブロックを1行下へ移動</code>
<code>            if (this.fire &lt; count) {</code>
<code>                this.fire = count + interval;</code>
<code>                this.y++;</code>
<code>            }</code>
<code></code>
<code>            // キーイベントの処理</code>
<code>            while (keyevents.length &gt; 0) {</code>
<code>                var code = keyevents.shift();</code>
<code>                var dx = 0, dy = 0, nd = this.turn;</code>
<code></code>
<code>                switch (code) {</code>
<code>                    case 32: nd = (nd + 1) % 4; break;</code>
<code>                    case 37: dx = -1; break;</code>
<code>                    case 39: dx = +1; break;</code>
<code>                    case 40: dy = +1; break;</code>
<code>                    default: continue;</code>
<code>                }</code>
<code></code>
<code>                if (!isHit(this.x + dx, this.y + dy, nd)) {</code>
<code>                    this.x = this.x + dx;</code>
<code>                    this.y = this.y + dy;</code>
<code>                    this.turn = nd;</code>
<code>                    this.data = this.type[this.turn];</code>
<code>                }</code>
<code>            }</code>
<code>        };</code>
<code></code>
<code>        this.draw = function (ctx) {</code>
<code>            processBlockCells(function (x, y, value) {</code>
<code>                ctx.fillStyle = colors[value];</code>
<code>                ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);</code>
<code>            });</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function rand(r) {</code>
<code>        return Math.floor(Math.random() * r);</code>
<code>    }</code>
<code></code>
<code>    function processBlockCells(func) {</code>
<code>        for (var i = 0 ; i &lt; block.data.length ; i++) {</code>
<code>            var x = i % block.w;</code>
<code>            var y = Math.floor(i / block.w);</code>
<code>            var v = block.data[i];</code>
<code>            if (0 &lt;= y + block.y &amp;&amp; y + block.y &lt; H &amp;&amp;</code>
<code>                0 &lt;= x + block.x &amp;&amp; x + block.x &lt; W &amp;&amp; v != 0) {</code>
<code>                func(x + block.x, y + block.y, v);</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    function init() {</code>
<code>        var canvas = document.getElementById('canvas');</code>
<code>        ctx = canvas.getContext('2d');</code>
<code>        ctx.font = "20pt Arial";</code>
<code></code>
<code>        addEventListener('keydown', function (e) { keyevents.push(e.keyCode) });</code>
<code></code>
<code>        count = 0;</code>
<code>        score = 0;</code>
<code></code>
<code>        // フィールドの初期化</code>
<code>        field = new Array(H);</code>
<code>        for (var y = 0 ; y &lt; H ; y++) {</code>
<code>            field[y] = new Array(W);</code>
<code>            for (var x = 0 ; x &lt; W ; x++) {</code>
<code>                field[y][x] = (x == 0 || x == W - 1) ? 8 : 0;</code>
<code>            }</code>
<code>        }</code>
<code>        for (var i = 0 ; i &lt; W ; i++) {</code>
<code>            field[H - 1][i] = 8;</code>
<code>        }</code>
<code></code>
<code>        // ブロックの初期化</code>
<code>        goNextBlock();</code>
<code></code>
<code>        // メインループの開始</code>
<code>        timer = setInterval(mainLoop, 10);</code>
<code>    }</code>
<code></code>
<code>    function mainLoop() {</code>
<code>        count++;</code>
<code></code>
<code>        // スピードアップ</code>
<code>        if (count % 1000 == 0) {</code>
<code>            interval = Math.max(1, interval - 1);</code>
<code>        }</code>
<code></code>
<code>        // ブロックの位置を更新</code>
<code>        block.update();</code>
<code></code>
<code>        // ゲームオーバーの判定</code>
<code>        if (isGameOver()) {</code>
<code>            clearInterval(timer);</code>
<code>            timer = NaN;</code>
<code>        }</code>
<code></code>
<code>        draw();</code>
<code>    }</code>
<code></code>
<code>    function isGameOver() {</code>
<code>        var filled = 0;</code>
<code>        field[0].forEach(function (c) {</code>
<code>            if (c != 0) { filled++ }</code>
<code>        });</code>
<code>        return filled &gt; 2;</code>
<code>    }</code>
<code></code>
<code>    function goNextBlock() {</code>
<code>        block = nextBlock || new Block();</code>
<code>        nextBlock = new Block();</code>
<code>    }</code>
<code></code>
<code>    function isHit(x, y, r) {</code>
<code>        var data = block.type[r];</code>
<code>        for (var i = 0 ; i &lt; block.w ; i++) {</code>
<code>            for (var j = 0 ; j &lt; block.w ; j++) {</code>
<code>                if (i + y &gt;= 0 &amp;&amp; j + x &gt;= 0 &amp;&amp; i + y &lt; H &amp;&amp; j + x &lt; W &amp;&amp;</code>
<code>                    field[i + y][j + x] != 0 &amp;&amp; data[i * block.w + j] != 0) {</code>
<code>                    return true;</code>
<code>                }</code>
<code>            }</code>
<code>        }</code>
<code>        return false;</code>
<code>    }</code>
<code></code>
<code>    function eraseLine() {</code>
<code>        var erased = 0;</code>
<code>        for (var y = 20 ; y &gt;= 0 ; y--) {   // 下から上へ</code>
<code>            if (field[y].every(function (v) { return v != 0 })) {</code>
<code>                erased++;</code>
<code>                field.splice(y, 1);             // 1行削除</code>
<code>                field.unshift(new Array(W));    // 1行追加</code>
<code>                for (var i = 0 ; i &lt; W ; i++) {</code>
<code>                    field[0][i] = (i == 0 || i == W - 1) ? 8 : 0;</code>
<code>                }</code>
<code>                y++;    // 消去した行からもう一度チェック</code>
<code>            }</code>
<code>        }</code>
<code>        return erased;</code>
<code>    }</code>
<code></code>
<code>    function draw() {</code>
<code>        // 背景の塗りつぶし</code>
<code>        ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>        ctx.fillRect(0, 0, 600, 600);</code>
<code></code>
<code>        // フィールドの描画</code>
<code>        for (var y = 0 ; y &lt; H ; y++) {</code>
<code>            for (var x = 0 ; x &lt; W ; x++) {</code>
<code>                var v = field[y][x];</code>
<code>                ctx.fillStyle = colors[v];</code>
<code>                ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);</code>
<code>            }</code>
<code>        }</code>
<code></code>
<code>        // 落下中のブロックの描画</code>
<code>        block.draw(ctx);</code>
<code></code>
<code>        // 次に出現するブロックの描画</code>
<code>        nextBlock.data.forEach(function (v, i, data) {</code>
<code>            var w = Math.sqrt(data.length);</code>
<code>            var x = i % w;</code>
<code>            var y = Math.floor(i / w);</code>
<code>            ctx.fillStyle = colors[v];</code>
<code>            ctx.fillRect(400 + x * 25, 300 + y * 25, 24, 24);</code>
<code>        });</code>
<code></code>
<code>        // 各種情報の描画</code>
<code>        ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>        ctx.fillText('score:', 400, 130);</code>
<code>        ctx.fillText('next:', 400, 270);</code>
<code>        ctx.fillText(('0000000' + score).slice(-7), 400, 170);</code>
<code>        if (isNaN(timer)) {</code>
<code>            ctx.fillText('GAME OVER', 380, 70);</code>
<code>        }</code>
<code>    }</code>
<code>    &lt;/script&gt;</code>
<code>&lt;/head&gt;</code>
<code></code>
<code>&lt;body onload="init()"&gt;</code>
<code>&lt;div&gt;</code>
<code>    &lt;canvas id="canvas" width="600" height="600"/&gt;</code>
<code>&lt;/div&gt;</code>
<code>&lt;/body&gt;</code>
<code>&lt;/html&gt;</code>
</pre>
</section>
</div>
<div id="calibre_link-27">
<section>
<h2 id="calibre_link-363"><b>5-9-2　変数</b></h2>
<p>　まず、キーとなる配列が2つあります。</p>
<table>
<caption>主な配列</caption>
<tbody>
<tr>
  <th>配列</th>
  <th>説明</th>
</tr>
<tr>
  <td>colors</td>
  <td>色番号と色を対応づける配列</td>
</tr>
<tr>
  <td>blocks</td>
  <td>落下するブロックのデータ（色番号）を保持する2次元配列</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　このblocksについては少し詳しく説明しましょう。ソースコードでは以下のように記述されています。</p>
<p>配列blocks</p>
<pre>
<code>    var blocks = [</code>
<code>        [</code>
<code>            [</code>
<code>                0, 0, 1,</code>
<code>                1, 1, 1,</code>
<code>                0, 0, 0</code>
<code>            ], [</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 1</code>
<code>            ], [</code>
<code>                0, 0, 0,</code>
<code>                1, 1, 1,</code>
<code>                1, 0, 0</code>
<code>            ], [</code>
<code>                1, 1, 0,</code>
<code>                0, 1, 0,</code>
<code>                0, 1, 0</code>
<code>            ],</code>
<code>        ], [</code>
<code>            [</code>
<code>...</code>
</pre>
<p>　これを図で表すと以下のようになります。</p>
<figure>
<img src="images/00161.jpeg" />
<figcaption>blocks配列</figcaption>
</figure>
<p>　このように各ブロックについて、それぞれの向きのデータを用意しています。こうすることで、回転ができるかどうか、さらに下がれるかどうかなどの判定が容易になります。</p>
<p>　このゲームで使用する主な変数は以下の通りです。</p>
<table>
<caption>主な変数</caption>
<tbody>
<tr>
  <th>変数</th>
  <th>説明</th>
</tr>
<tr>
  <td>W = 12</td>
  <td>作業領域の横幅</td>
</tr>
<tr>
  <td>H = 22</td>
  <td>作業領域の高さ</td>
</tr>
<tr>
  <td>field</td>
  <td>ブロックの状態を管理する2次元配列</td>
</tr>
<tr>
  <td>block</td>
  <td>現在落下中のブロックオブジェクト</td>
</tr>
<tr>
  <td>nextBlock</td>
  <td>次に出現するブロックオブジェクト</td>
</tr>
<tr>
  <td>keyevents</td>
  <td>キー入力を保持する配列</td>
</tr>
<tr>
  <td>count</td>
  <td>このゲームの世界の時計</td>
</tr>
<tr>
  <td>score</td>
  <td>現在のスコア</td>
</tr>
</tbody>
</table>
<p>
<br />
</p>
<p>　このプログラムで特徴的なのfield変数です。field変数は作業領域の状態を管理する2次元配列で、値として色番号を保持します。</p>
<p>　落下中のブロックは、回転、移動、落下という処理が必要になるので、別のblock変数で管理します。次に出現するブロックはnextBlock変数で保持しています。その様子を以下の図に示します。</p>
<figure>
<img src="images/00087.jpeg" />
<figcaption>テトリスの主な変数</figcaption>
</figure>
<p>　一番下まで到達すると、そのblockの内容をfieldにコピーします。</p>
<p>　回転可能か否かの判定がどのように行われるかを見てみましょう。次の図をご覧ください。</p>
<figure>
<img src="images/00013.jpeg" />
<figcaption>block変数、field変数、nextBlock変数のイメージ</figcaption>
</figure>
<p>　最上段が現在のblockとfield（の一部分）の状態です。</p>
<p>　blockを左に回転すると中段のようになります。このときblockとfieldのデータが衝突することはないので、回転が可能と判断できます。</p>
<p>　さらにblockを左に回転させるとは最下段のようになりますが、この場合はblockとfieldのデータが衝突してしまいます。すなわち、回転ができないと判断できるのです。</p>
<p>　一番下の段に到達した場合も同様です。次の図は、同一のfieldで、同じ場所に同じblockがある場合です。ただし、向きが異なります。左の状況では、左端の「2」の下に「5」があるので、これ以上下に進むことはできません。つまり、ブロックが積み上がった状態となります。一方、右側の場合は、まだ下に下がることができます。このように向きが違うと下に行けたり、行けなかったりします。</p>
<figure>
<img src="images/00111.jpeg" />
<figcaption>向きが違うと下に行けたり、行けなかったりする</figcaption>
</figure>
<p>　積み上がった（これ以上blockが下に進めない）という状況になったときは、blockの内容をfieldにコピーし、消せるラインがあるかどうか判定します。</p>
<figure>
<img src="images/00080.jpeg" />
<figcaption>積み上がると消せるラインがあるかどうか判定する</figcaption>
</figure>
<p>　ここまでの説明をまとめると以下のようになります。</p>
<ul>
<li>落下中のブロックblockと、積み上がったブロックfieldを別々に管理する</li>
<li>それぞれのブロックにつき、4つの向きのデータを用意する</li>
<li>積み上がったときはblockの内容をfieldにコピー、行が消せるか判定し、消せる場合は上の行のデータを順番に下に詰める</li>
<li>一番上までブロックが到達したらゲームオーバーとする</li>
</ul>
<p>　この考え方がわかればプログラムを読み進めるのも大分容易になるはずです。</p>
</section>
</div>
<div id="calibre_link-30">
<section>
<h2 id="calibre_link-364"><b>5-9-3　オブジェクト</b></h2>
<p>　このゲームで使用するオブジェクトはBlock1つだけです。ただコードが少々長いので分割して説明します。</p>
<h3 id="calibre_link-365">■落下中のブロックの情報を管理する</h3>
<p>Blockオブジェクト1</p>
<pre>
<code>    function Block() {</code>
<code>        this.turn = rand(4);                    // 向き</code>
<code>        this.type = blocks[rand(blocks.length)];</code>
<code>        this.data = this.type[this.turn];</code>
<code></code>
<code>        this.w = Math.sqrt(this.data.length);   // 2 or 3 or 4</code>
<code>        this.x = rand(6 - this.w) + 2;          // 落下開始時のx座標</code>
<code>        this.y = 1 - this.w;</code>
<code>        this.fire = interval + count;</code>
</pre>
<p>　randは0から引数までの乱数を返す関数です。turnは現在のブロックの向きを0～3の値で保持します。</p>
<p>　typeはどのブロックを参照するか保持するプロパティです。ブロックの種類の個数はblocks.lengthで取得できます。その値をrand関数に渡して、乱数でブロックを選んでいます。</p>
<p>　dataプロパティは、そのタイプ、その向きに特化したデータを保持しています。その様子を以下の図に示します。</p>
<figure>
<img src="images/00133.jpeg" />
<figcaption>落下中のブロックの情報</figcaption>
</figure>
<p>　プロパティwは縦横のサイズを表します。ブロックの数の平方根から求めています。xとyはブロックの座標、fireは次に落下する時刻を保持しています。</p>
<h3 id="calibre_link-366">■update()メソッドでブロックの状態を更新する</h3>
<p>　update()メソッドはブロックの状態を更新します。</p>
<p>Blockオブジェクト2</p>
<pre>
<code>this.update = function () {</code>
<code>    // 一番下に到達？</code>
<code>    if (isHit(this.x, this.y + 1, this.turn)) {</code>
<code>        processBlockCells(function (x, y, value) {</code>
<code>            field[y][x] = value;</code>
<code>        });</code>
<code></code>
<code>        var erased = eraseLine();</code>
<code>        if (erased &gt; 0) {</code>
<code>            score += Math.pow(2, erased) * 10;</code>
<code>        }</code>
<code></code>
<code>        keyevents = [];</code>
<code>        goNextBlock();</code>
<code>    }</code>
</pre>
<p>　isHit（ブロックのx座標、ブロックのy座標、ブロックの向き）は、指定された場所と向きでブロックが衝突するか判定する関数です。ブロックのy座標の値に1を加えて引数に渡すことで、さらに下に進めるか否かチェックしています。進めない場合は、以下の処理でblockの内容をfieldにコピーしています。</p>
<p>
<br />
</p>
<pre>
<code>processBlockCells(function (x, y, value) {</code>
<code>    field[y][x] = value;</code>
<code>});</code>
</pre>
<h3 id="calibre_link-367">■関数を引数で渡す</h3>
<p>　ここでprocessBlockCellsという関数にfunctionを渡していることに注目してください。</p>
<p>　ここまで、関数には値や変数を引数として渡すことができると説明してきました。実は、JavaScriptでは関数もオブジェクトとして扱うことができ、それを引数として渡すことができるのです。「関数を引数で渡す」ということに関してはもう少し説明が必要でしょう。</p>
<p>　そもそも、なぜこのようなことをする必要があるのでしょうか？このゲームでは、blockのすべてのマスに対して処理を行う状況が2つ存在します。</p>
<ul>
<li>blockの各マス目を描画する</li>
<li>blockの各マス目をfieldにコピーする</li>
</ul>
<p>　どちらの処理も、ブロックのマス目を走査していき、そのマス目について処理を行います。それぞれを関数として実装すると以下のようになります。ブロックが端に来たときも考慮する必要があるので少々面倒な処理となっています。</p>
<p>各マス目の描画とコピーを別の関数で定義した場合</p>
<pre>
<code>function drawBlock() {    // 各マス目を描画する</code>
<code>    for (var i = 0 ; i &lt; block.data.length ; i++) {</code>
<code>        var x = i % block.w;</code>
<code>        var y = Math.floor(i / block.w);</code>
<code>        var v = block.data[i];</code>
<code>        if (0 &lt;= y + block.y &amp;&amp; y + block.y &lt; H &amp;&amp;</code>
<code>            0 &lt;= x + block.x &amp;&amp; x + block.x &lt; W &amp;&amp; v != 0) {</code>
<code>            ctx.fillStyle = colors[v];</code>
<code>            ctx.fillRect(50 + (x + block.x) * 25, 25 + (y + block.y) * 25, 24, 24);</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>function copyBlock() {    // 各マス目をfieldにコピーする</code>
<code>    for (var i = 0 ; i &lt; block.data.length ; i++) {</code>
<code>        var x = i % block.w;</code>
<code>        var y = Math.floor(i / block.w);</code>
<code>        var v = block.data[i];</code>
<code>        if (0 &lt;= y + block.y &amp;&amp; y + block.y &lt; H &amp;&amp;</code>
<code>            0 &lt;= x + block.x &amp;&amp; x + block.x &lt; W &amp;&amp; v != 0) {</code>
<code>            field[x + block.x][y + block.y] = v;</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　かなり重複している部分があることに気づかされます。これらの関数で異なるのは、各マス目に対する操作の部分だけです。</p>
<p>　その処理自体を引数として渡すことができれば、重複した処理をまとめることが可能になります。これが、関数を引数として渡すことの効果です。そのイメージを以下に示します。</p>
<figure>
<img src="images/00060.jpeg" />
<figcaption>重複した処理は関数にして渡す</figcaption>
</figure>
<p>　関数をオブジェクトとして扱うには慣れが必要です。最初は難しいと感じるかもしれません。しかし、実はいろいろな場所ですでに関数オブジェクトを使っていたのです。たとえば、以下のような使い方です。これらも、関数オブジェクトにほかなりません。</p>
<p>
<br />
</p>
<pre>
<code>addEventListener('keydown', function (e) { ...  });</code>
<code>field[0].forEach(function (c) {...});</code>
</pre>
<p>　このことからも関数オブジェクトの重要性がわかると思います。</p>
<h3 id="calibre_link-368">■eraseLine()で行を消す</h3>
<p>　話が少し脱線してしまったので元に戻しましょう。ブロックが下に到着したら、eraseLine()で行を消します。もし、消せた場合はその行数が戻り値で返るので、「score += Math.pow(2, erased) * 10;」でスコアを加算します。一度に消す行が多いほど点数が高くなっています。次に、goNextBlock()で新しいブロックに切り替えています。</p>
<h3 id="calibre_link-369">■ブロックを下に移動させる時間をセットする</h3>
<p>　fireはブロックを下に移動させる時間を保持しています。mainLoopが実行されるたびにcountが増加します。時間が経過したら（this.fire &lt; count）、次の時間をセットして、ブロックをthis.y++で下に移動します。キーイベントは配列keyeventsに格納されているので順に処理していきます。</p>
<p>Blockオブジェクト3</p>
<pre>
<code>    // ブロックを1行下へ移動</code>
<code>    if (this.fire &lt; count) {</code>
<code>        this.fire = count + interval;</code>
<code>        this.y++;</code>
<code>    }</code>
<code></code>
<code>    // キーイベントの処理</code>
<code>    while (keyevents.length &gt; 0) {</code>
<code>        var code = keyevents.shift();</code>
<code>        var dx = 0, dy = 0, nd = this.turn;</code>
<code></code>
<code>        switch (code) {</code>
<code>            case 32: nd = (nd + 1) % 4; break;</code>
<code>            case 37: dx = -1; break;</code>
<code>            case 39: dx = +1; break;</code>
<code>            case 40: dy = +1; break;</code>
<code>            default: continue;</code>
<code>        }</code>
<code></code>
<code>        if (!isHit(this.x + dx, this.y + dy, nd)) {</code>
<code>            this.x = this.x + dx;</code>
<code>            this.y = this.y + dy;</code>
<code>            this.turn = nd;</code>
<code>            this.data = this.type[this.turn];</code>
<code>        }</code>
<code>    }</code>
</pre>
<p>　keyeventsが空になるまで（keyevents.length &gt; 0）、while文を繰り返します。</p>
<p>　keyevents.shift()で、1つイベントを取り出します。dxは次のx座標、dyは次のy座標、ndは次の向きを格納します。</p>
<p>　スペースキー（32）押下時は、「nd = (nd + 1) % 4」で次の向きを求めています。％演算子を使って0→1→2→3→0→...と順番に向きが変わることに注目してください。</p>
<p>　次の座標と向きが衝突しないか否かを判定し（isHit(this.x + dx, this.y + dy, nd)）、もし大丈夫であれば、blockのプロパティx、y、turn、dataを更新しています。</p>
<h3 id="calibre_link-370">■blockのセルを描画する</h3>
<p>　drawメソッドはblockのセルを描画します。先ほどと同じprocessBlockCellsを使っています。</p>
<p>drawメソッド</p>
<pre>
<code>this.draw = function (ctx) {</code>
<code>    processBlockCells(function (x, y, value) {</code>
<code>        ctx.fillStyle = colors[value];</code>
<code>        ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);</code>
<code>    });</code>
<code>}</code>
</pre>
</section>
</div>
<div id="calibre_link-114">
<section>
<h2 id="calibre_link-371"><b>5-9-4　関数</b></h2>
<h3 id="calibre_link-372">■rand関数、processBlockCells関数</h3>
<p>　randは0～rまでの整数の乱数を返す関数です。processBlockCellsは、前に説明した通り、関数オブジェクトを引数にとり、blockの各マスについてその関数オブジェクトを実行します。</p>
<p>rand関数、processBlockCells関数</p>
<pre>
<code>function rand(r) {</code>
<code>    return Math.floor(Math.random() * r);</code>
<code>}</code>
<code></code>
<code>function processBlockCells(func) {</code>
<code>    for (var i = 0 ; i &lt; block.data.length ; i++) {</code>
<code>        var x = i % block.w;</code>
<code>        var y = Math.floor(i / block.w);</code>
<code>        var v = block.data[i];</code>
<code>        if (0 &lt;= y + block.y &amp;&amp; y + block.y &lt; H &amp;&amp;</code>
<code>            0 &lt;= x + block.x &amp;&amp; x + block.x &lt; W &amp;&amp; v != 0) {</code>
<code>            func(x + block.x, y + block.y, v);</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　iとx、yの関係を以下に示します。1次元の配列をもとにして、x、yを求めています。</p>
<figure>
<img src="images/00157.jpeg" />
<figcaption>ブロックの処理</figcaption>
</figure>
<p>　x、yが一定の範囲に収まっている場合、funcを呼び出しています。funcは引数で受け取った関数オブジェクトです。funcの引数はblockを基準としての「x、y、そのセルの値」となります。</p>
<h3 id="calibre_link-373">■init()関数</h3>
<p>　init()は最初に実行される関数です。ctxのコンテキストを取得し、フォントをセットします。次にkeydownイベントのハンドラーを登録しています。キー押下時にそのkeyCodeを配列keyeventsに格納しているだけです。</p>
<p>init()関数</p>
<pre>
<code>function init() {</code>
<code>    var canvas = document.getElementById('canvas');</code>
<code>    ctx = canvas.getContext('2d');</code>
<code>    ctx.font = "20pt Arial";</code>
<code></code>
<code>    addEventListener('keydown', function (e) { keyevents.push(e.keyCode) });</code>
<code></code>
<code>    count = 0;</code>
<code>    score = 0;</code>
<code></code>
<code>    // フィールドの初期化</code>
<code>    field = new Array(H);</code>
<code>    for (var y = 0 ; y &lt; H ; y++) {</code>
<code>        field[y] = new Array(W);</code>
<code>        for (var x = 0 ; x &lt; W ; x++) {</code>
<code>            field[y][x] = (x == 0 || x == W - 1) ? 8 : 0;</code>
<code>        }</code>
<code>    }</code>
<code>    for (var i = 0 ; i &lt; W ; i++) {</code>
<code>        field[H - 1][i] = 8;</code>
<code>    }</code>
<code></code>
<code>    // ブロックの初期化</code>
<code>    goNextBlock();</code>
<code></code>
<code>    // メインループの開始</code>
<code>    timer = setInterval(mainLoop, 10);</code>
<code>}</code>
</pre>
<p>　その次に、fieldを初期化しています。2次元配列を作り、端「x == 0 || x == W - 1」と、底「field[H - 1][i]」を壁にするために8を代入しています。</p>
<p>　あとはgoNextBlock()で落下ブロックを初期化し、setIntervalでメインループを開始しています。</p>
<h3 id="calibre_link-374">■メインループ</h3>
<p>　次はメインループmainLoop()です。</p>
<p>mainLoop()関数</p>
<pre>
<code>function mainLoop() {</code>
<code>    count++;</code>
<code></code>
<code>    // スピードアップ</code>
<code>    if (count % 1000 == 0) {</code>
<code>        interval = Math.max(1, interval - 1);</code>
<code>    }</code>
<code></code>
<code>    // ブロックの位置を更新</code>
<code>    block.update();</code>
<code></code>
<code>    // ゲームオーバーの判定</code>
<code>    if (isGameOver()) {</code>
<code>        clearInterval(timer);</code>
<code>        timer = NaN;</code>
<code>    }</code>
<code></code>
<code>    draw();</code>
<code>}</code>
</pre>
<p>　実行するたびにcountを1増加させ、1000単位でintervalを減少させてスピードアップしています。</p>
<p>　「block.update();」でブロックの位置を更新し、ゲームオーバーの場合isGameOver()は、タイマーを停止し、draw()で描画を更新しています。</p>
<h3 id="calibre_link-375">■isGameOver()関数</h3>
<p>　isGameOver()はゲームオーバーか否かを判定する関数です。0行目、すなわち一番上の行で、その中で0以外のマス目の数を数えています。左右の壁もあるため、その数が2より大きい場合に真を返しています。</p>
<p>isGameOver()関数</p>
<pre>
<code>function isGameOver() {</code>
<code>    var filled = 0;</code>
<code>    field[0].forEach(function (c) {</code>
<code>        if (c != 0) { filled++ }</code>
<code>    });</code>
<code>    return filled &gt; 2;</code>
<code>}</code>
<code></code>
<code>function goNextBlock() {</code>
<code>    block = nextBlock || new Block();</code>
<code>    nextBlock = new Block();</code>
<code>}</code>
</pre>
<p>　goNextBlock()は次のブロックに切り替える関数です。</p>
<p>　「block = nextBlock || new Block();」は、||演算子の少し変わった使い方です。もし、nextBlockが偽でない場合、すなわち何らかの値が格納されている場合は、その内容がblockに格納されます。</p>
<p>　nextBlockが空のときは、new Block()の値がblockに格納されます。</p>
<p>　ゲーム開始直後はnextBlockが空ですが、いったんゲームが始まるとnextBlockには次のブロックが格納されています。どちらの場合にも対処できるようにしたかったので、このような処理としました。</p>
<h3 id="calibre_link-376">■isHit関数</h3>
<p>　isHit(x, y, r)は、ブロックがx, yの位置で、向きがrのときに衝突するか否か判定する関数です。</p>
<p>isHit関数</p>
<pre>
<code>function isHit(x, y, r) {</code>
<code>    var data = block.type[r];</code>
<code>    for (var i = 0 ; i &lt; block.w ; i++) {</code>
<code>        for (var j = 0 ; j &lt; block.w ; j++) {</code>
<code>            if (i + y &gt;= 0 &amp;&amp; j + x &gt;= 0 &amp;&amp; i + y &lt; H &amp;&amp; j + x &lt; W &amp;&amp;</code>
<code>                field[i + y][j + x] != 0 &amp;&amp; data[i * block.w + j] != 0) {</code>
<code>                return true;</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    return false;</code>
<code>}</code>
</pre>
<p>　処理の様子を図にすると以下のようになります。「field[i + y][j + x]」でfieldの値を参照し、「data[i * block.w + j]」でblockの値を参照しています。それらの値がともに0でない場合、衝突したことになるので、trueを返しています。</p>
<figure>
<img src="images/00086.jpeg" />
<figcaption>衝突の判定</figcaption>
</figure>
<h3 id="calibre_link-377">■eraseLine()関数</h3>
<p>　eraseLine()は、ブロックが一番下に到達したときに行が消せるかチェックしている関数です。「for (var y = 20 ; y &gt;= 0 ; y--)」で下から上へチェックしてることに注目してください。</p>
<p>eraseLine()関数</p>
<pre>
<code>function eraseLine() {</code>
<code>    var erased = 0;</code>
<code>    for (var y = 20 ; y &gt;= 0 ; y--) {   // 下から上へ</code>
<code>        if (field[y].every(function (v) { return v != 0 })) {</code>
<code>            erased++;</code>
<code>            field.splice(y, 1);             // 1行削除</code>
<code>            field.unshift(new Array(W));    // 1行追加</code>
<code>            for (var i = 0 ; i &lt; W ; i++) {</code>
<code>                field[0][i] = (i == 0 || i == W - 1) ? 8 : 0;</code>
<code>            }</code>
<code>            y++;    // 消去した行からもう一度チェック</code>
<code>        }</code>
<code>    }</code>
<code>    return erased;</code>
<code>}</code>
</pre>
<p>　行が全部埋まっているか否かは、「field[y].every(function (v) { return v != 0 })」で判定しています。</p>
<p>　everyは、配列の要素に対してコールバックを呼び出し、それらのコールバックがすべて真を返したときに全体が真となります。</p>
<p>　その場合は、該当する行を「field.splice(y, 1);」で削除し、「field.unshift(new Array(W));」で一番上に行を追加しています。また、その際に壁も設定しています。</p>
<p>　1行消去した場合は、またその行からチェックをする必要があるため、y++としています。</p>
<h3 id="calibre_link-378">■draw()関数</h3>
<p>　最後は描画用関数draw()です。</p>
<p>draw()関数</p>
<pre>
<code>function draw() {</code>
<code>    // 背景の塗りつぶし</code>
<code>    ctx.fillStyle = 'rgb(0,0,0)';</code>
<code>    ctx.fillRect(0, 0, 600, 600);</code>
<code></code>
<code>    // フィールドの描画</code>
<code>    for (var y = 0 ; y &lt; H ; y++) {</code>
<code>        for (var x = 0 ; x &lt; W ; x++) {</code>
<code>            var v = field[y][x];</code>
<code>            ctx.fillStyle = colors[v];</code>
<code>            ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);</code>
<code>        }</code>
<code>    }</code>
<code></code>
<code>    // 落下中のブロックの描画</code>
<code>    block.draw(ctx);</code>
<code></code>
<code>    // 次に出現するブロックの描画</code>
<code>    nextBlock.data.forEach(function (v, i, data) {</code>
<code>        var w = Math.sqrt(data.length);</code>
<code>        var x = i % w;</code>
<code>        var y = Math.floor(i / w);</code>
<code>        ctx.fillStyle = colors[v];</code>
<code>        ctx.fillRect(400 + x * 25, 300 + y * 25, 24, 24);</code>
<code>    });</code>
<code></code>
<code>    // 各種情報の描画</code>
<code>    ctx.fillStyle = 'rgb(0,255,0)';</code>
<code>    ctx.fillText('score:', 400, 130);</code>
<code>    ctx.fillText('next:', 400, 270);</code>
<code>    ctx.fillText(('0000000' + score).slice(-7), 400, 170);</code>
<code>    if (isNaN(timer)) {</code>
<code>        ctx.fillText('GAME OVER', 380, 70);</code>
<code>    }</code>
<code>}</code>
</pre>
<p>　処理内容はシンプルです。まず、背景を塗りつぶし、fieldの全体を描画し、block.draw(ctx)で落下中のブロックを描画します。次に出現するブロックをnextBlock.data.forEach(...)で描画し、最後にスコアやゲームオーバーの表示など各種情報を描画しています。</p>
</section>
</div>
<div id="calibre_link-25">
<section>
<hgroup>
<h1 id="calibre_link-182"><b>あとがき</b></h1>
</hgroup>
<p>　2013年、横浜サイエンスフロンティア高校において「Windowsストアアプリ講座」を担当させて頂けるという機会に恵まれました。HTML/JavaScript/CSSの基礎から、アプリの完成までを全10回の講義でカバーすることになったのですが、本書はその講座で使用するテキストとして書き下ろしたものです。</p>
<p>
<br />
</p>
<p>　最初はスライドを使って授業をするつもりでしたが、たまたま、インプレス井芹様より「Next Publishingという新しい出版モデルができたので、何か良いネタはない？」とお声掛けをいただきました。「高校で授業をすることになったので、その教材であれば...」とお答えしたことが、本書を執筆するきっかけとなりました。HTML/CSS/JavaScriptの基礎からわかりやすく説明するとともに、ゲームを題材にすることで興味を持ってもらいたいという思いで大急ぎで執筆を進めました。</p>
<p>
<br />
</p>
<p>　優秀でやる気のある20数名の高校生が相手ということもあり、講義は非常に楽しく進めることができました。短い期間で広い範囲をカバーせざるを得なかったため、プログラム初心者の人には多少つらい思いをさせてしまったかもしれません。その点に関しては申し訳なく思っています。ただ、プログラミングの基礎を体験して、アプリを作り、それを発表するというプロセスを経験したことは今後の皆さんの将来において決して無駄にはならないと信じています。</p>
<p>
<br />
</p>
<p>　土曜日の朝8時半という厳しい条件の下、自分の拙い講義に出席してくれた生徒の皆さん、このような素晴らしい機会を提供してくださった横浜サイエンスフロンティア高校の佐野和夫先生、本当にどうもありがとうございました。また、本書の校正や内容に関してご助言をいただくとともに編集作業をしてくださったピーチプレス芹川宏様、電子書籍制作についてのサポートをいただいたインプレス栗原翔様、出版の機会をくださったインプレス井芹昌信様、どうもありがとうございました。この場を借りて厚く御礼申し上げます。</p>
<p>
<br />
</p>
<p>　プログラミングは楽しいアクティビティです。将来プログラマーを目指す人はもちろん、そうでない人にとっても、プログラミングを体験することは非常に意義があることだと思います。将来を担う学生の方々にとって、本書が少しでも役にたつことを切に願っています。</p>
<p>
<br />
</p>
<p>2013年 8月 吉日</p>
<p>田中 賢一郎</p>
</section>
</div>
<div id="calibre_link-50">
<section>
<h1 id="calibre_link-183">◎著者紹介</h1>
<dl>
<dt><b>田中 賢一郎<span>（たなか けんいちろう）</span></b></dt>
<dd>1994年慶應義塾大学理工学部計測工学科修了。同年キヤノン株式会社に入社。2000年にデジタル放送立ち上げの会社に出向。その間に一人でデータ放送ブラウザを実装し、マイクロソフトへソースライセンスする。2008年より Windows Media Center TVチームの開発者としてマイクロソフト ディベロップメント株式会社へ。現在はWindows開発統括本部にて、パートナーのエンゲージメントをサポートするとともにWindows新規機能の検討に携わる。趣味はジャズピアノ演奏。宮澤隆氏に師事。週末は横浜界隈のジャムセッションに出没。</dd>
</dl>
<hr />
</section>
</div>
<div id="calibre_link-131">
<section>
<h1 id="calibre_link-379">◎本書スタッフ</h1>
<table>
<tr>
<th>AD／装丁</th>
<td>岡田 章志＋GY</td>
</tr>
<tr>
<th>編集</th>
<td>芹川 宏（ピーチプレス）</td>
</tr>
</table>
<hr />
<dl>
<dt><b>●本書の内容についてのお問い合わせ先</b></dt>
<dd>株式会社インプレスR&amp;D　メール窓口<br /><a href="mailto:np-info@impress.co.jp">np-info@impress.co.jp</a><br />
件名に「『ゲームを作りながら楽しく学べるHTML5+CSS+JavaScriptプログラミング』問い合わせ係」と明記してお送りください。<br />
電話やFAX、郵便でのご質問にはお答えできません。返信までには、しばらくお時間をいただく場合があります。なお、本書の範囲を超えるご質問にはお答えしかねますので、あらかじめご了承ください。</dd>
</dl>
</section>
</div>
<div id="calibre_link-54">
<section>
<h1 id="calibre_link-380">ゲームを作りながら楽しく学べるHTML5+CSS+JavaScriptプログラミング</h1>
<hr />
<p>2013年10月16日　初版発行Ver.1.0（リフロー版）</p>
<p>2014年5月15日　Ver.1.1</p>
<table>
<tbody>
<tr>
  <th>著　者</th>
  <td>田中 賢一郎</td>
</tr>
<tr>
  <th>編集人</th>
  <td>桜井 徹</td>
</tr>
<tr>
  <th>発行人</th>
  <td>井芹 昌信</td>
</tr>
<tr>
  <th>発　行</th>
  <td>株式会社インプレスR&amp;D［NextPublishing］</td>
</tr>
<tr>
  <th></th>
  <td>〒102-0075　東京都千代田区三番町20</td>
</tr>
<tr>
  <th></th>
  <td>
    <a href="http://www.impressRD.jp/">http://www.impressRD.jp/</a>
  </td>
</tr>
</tbody>
</table>
<hr />
<p>◉本書は著作権法上の保護を受けています。本書の一部あるいは全部について株式会社インプレスR&amp;Dから文書による許諾を得ずに、いかなる方法においても無断で複写、複製することは禁じられています。</p>
<p>©2013 Kenichiro Tanaka. All rights reserved.</p>
<p>ISBN978-4-8443-9596-6</p>
<p>
<br />
</p>
<figure>
<img src="images/00009.jpeg" />
</figure>
</section>
</div>
<div id="calibre_link-188">
<section>
<hgroup>
<h1 id="calibre_link-381"><b>好評既刊 NextPublishing</b></h1>
</hgroup>
<p>
<strong><b>Visual BasicによるKinect基本プログラミング　</b></strong>センサーを使ったアプリ開発を学ぶ</p>
<p>薬師寺 国安　著</p>
<p>印刷書籍版：A5正寸判／292ページ／小売希望価格 2,400円（税別）</p>
<p>電子書籍版：EPUB3/PDF／小売希望価格 1,600円（税別）</p>
<p>ISBN：978-4-8443-9579-9</p>
<hr />
<p>
<strong><b>iPadでは物足りない人のためのNexus 7スピード入門　</b></strong>Nexus 7(2012)/(2013)・Android 4.3対応</p>
<p>塩田 紳二　著</p>
<p>印刷書籍版：A5正寸判／142ページ／小売希望価格 1,600円（税別）</p>
<p>電子書籍版：EPUB3/PDF／小売希望価格 1,100円（税別）</p>
<p>ISBN：978-4-8443-9591-1</p>
<hr />
<p>
<strong><b>モチベーションを科学する　</b></strong>チームメンバーの成長欲求を引き出す12の法則</p>
<p>大塚 雅樹 著</p>
<p>印刷書籍版：A5正寸判／190ページ／小売希望価格 1,600円（税別）</p>
<p>電子書籍版：EPUB3/PDF／小売希望価格 800円（税別）</p>
<p>ISBN：978-4-8443-9525-6</p>
<hr />
<p>
<strong><b>日本のIT なんか変？　</b></strong>次世代のデジタル産業を担う若者たちへ</p>
<p>木内 里美 著</p>
<p>印刷書籍版：A5正寸判／182ページ／小売希望価格 1,900円（税別）</p>
<p>電子書籍版：EPUB3/PDF／小売希望価格 1,280円（税別）</p>
<p>ISBN：978-4-8443-9566-9</p>
<hr />
<p>
<strong><b>日本人が知らない中国インターネット市場［2011.11-2012.10］　</b></strong>現地発ITジャーナリストが報告する5億人市場の真実</p>
<p>山谷 剛史 著</p>
<p>印刷書籍版：A5正寸判／204ページ／小売希望価格 2,400円（税別）</p>
<p>電子書籍版：EPUB3/PDF／小売希望価格 1,600円（税別）</p>
<p>ISBN：978-4-8443-9530-0</p>
</section>
</div>
<div id="calibre_link-128">
<section>
<hgroup>
<h1 id="calibre_link-382"><b>既刊一覧 NextPublishing</b></h1>
</hgroup>
<p>
<strong><b>DSP/RTBオーディエンスターゲティング入門</b></strong>　横山 隆治／菅原 健一／楳田 良輝[著]</p>
<p>
<strong><b>日本の電子出版を創ってきた男たち　</b></strong>OnDeck編集部[編]</p>
<p>
<strong><b>黒船特許の正体　</b></strong>松倉 秀実[著]</p>
<p>
<strong><b>知らないと始められない電子出版最新用語集　</b></strong>OnDeck編集部[編]</p>
<p>
<strong><b>オープンクラウド入門　</b></strong>林 雅之[著]</p>
<p>
<strong><b>テレビのＩＴ革命（上）　</b></strong>清水 計宏[著]</p>
<p>
<strong><b>APT対策入門</b></strong>特定非営利活動法人 日本セキュリティ監査協会 APTによる攻撃対策と情報セキュリティ監査研究会[編]</p>
<p>
<strong><b>電子書籍端末の最新技術　</b></strong>藤原 隆弘[著]</p>
<p>
<strong><b>インターネット・サイエンスの歴史人物館　</b></strong>岩山 知三郎[著]</p>
<p>
<strong><b>ロンドン五輪でソーシャルメディアはどう使われたのか　</b></strong>野々下 裕子[著]</p>
<p>
<strong><b>アプリビジネスで転ばないためのスマートフォンプライバシーの基礎知識　</b></strong>寺田 眞治[著]</p>
<p>
<strong><b>プロフェッショナルのためのGoogleアナリティクス完全マニュアルVer.5対応版</b></strong>衣袋 宏美[著]</p>
<p>
<strong><b>情報セキュリティ内部監査の教科書　</b></strong>特定非営利活動法人 日本セキュリティ監査協会[編]</p>
<p>
<strong><b>SDN/OpenFlowで進化する仮想ネットワーク入門　</b></strong>伊勢 幸一[著]</p>
<p>
<strong><b>おとなのIT法律事件簿　</b></strong>蒲 俊郎[著]</p>
<p>
<strong><b>企業システムのためのパブリッククラウド入門　</b></strong>加藤 章[著]</p>
<p>
<strong><b>SPREAD情報セキュリティサポーター能力検定公式テキスト　</b></strong>セキュリティ対策推進協議会[編]</p>
<p>
<strong><b>Visual BasicによるKinect基本プログラミング　</b></strong>薬師寺 国安[著]</p>
<p>
<strong><b>ひと目で伝わる！　ワンランク上のグラフ作成術　</b></strong>衣袋 宏美[著]</p>
<p>
<strong><b>調査統計データのリテラシー超入門　</b></strong>衣袋 宏美[著]</p>
<p>
<strong><b>編集後記　</b></strong>勝峰 富雄[著]</p>
<p>
<strong><b>顧客を知るためのデータマネジメントプラットフォーム　DMP入門　</b></strong>横山 隆治／菅原 健一／草野 隆史[著]</p>
<p>
<strong><b>これからの「教育」の話をしよう　</b></strong>学校広報ソーシャルメディア活用勉強会[編]</p>
<p>
<strong><b>クラウドソーシングの衝撃　</b></strong>比嘉 邦彦／井川 甲作[著]</p>
<p>
<strong><b>改訂新版クラウド環境におけるアイデンティティ管理ガイドライン　</b></strong>特定非営利活動法人 日本ネットワークセキュリティ協会　アイデンティティ管理ワーキンググループ[編]</p>
<p>
<strong><b>電子書籍ストア利用動向調査-OnDeck 2013年4月調査版　</b></strong>OnDeck編集部[編]</p>
<p>
<strong><b>トリップアドバイザー/旅行者が選ぶ 人生で一度は行ってみたい島30　</b></strong>トリップアドバイザー[著]</p>
<p>
<strong><b>「電子書籍に関する公立図書館での検討状況のアンケート」実施報告書　</b></strong>一般社団法人　電子出版制作・流通協議会　公共ビジネス部会[著]</p>
<p>
<strong><b>米国モバイル通信市場アウトルック2013　</b></strong>前田 正明[著]</p>
</section>
</div>




<script>function myFunction(){document.getElementById("tateyoko").classList.toggle("tateread")}</script></body></html>